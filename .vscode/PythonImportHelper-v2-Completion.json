[
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "product",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bisect",
        "description": "bisect",
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "MyHashTable",
        "importPath": "hashtable.structures",
        "description": "hashtable.structures",
        "isExtraImport": true,
        "detail": "hashtable.structures",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "importPath": "ch14_tree.binarytree.structures",
        "description": "ch14_tree.binarytree.structures",
        "isExtraImport": true,
        "detail": "ch14_tree.binarytree.structures",
        "documentation": {}
    },
    {
        "label": "make_tree_by",
        "importPath": "chap14.binarytree.prac",
        "description": "chap14.binarytree.prac",
        "isExtraImport": true,
        "detail": "chap14.binarytree.prac",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "chap9.structures",
        "description": "chap9.structures",
        "isExtraImport": true,
        "detail": "chap9.structures",
        "documentation": {}
    },
    {
        "label": "Stack",
        "importPath": "chap9.structures",
        "description": "chap9.structures",
        "isExtraImport": true,
        "detail": "chap9.structures",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "chap9.structures",
        "description": "chap9.structures",
        "isExtraImport": true,
        "detail": "chap9.structures",
        "documentation": {}
    },
    {
        "label": "rotate90",
        "kind": 2,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "def rotate90(arr):\n    return list(zip(*arr[::-1]))\n# 날짜변환\nfrom datetime import datetime, timedelta\nstart_date = datetime(2023, 1, 1)\nend_date = datetime(2023, 12, 31)\ncurrent_date = start_date\nwhile current_date <= end_date:\n    is_weekend = \"Weekend\" if current_date.weekday() >= 5 else \"Weekday\"\n    print(f\"{current_date.strftime('%Y-%m-%d')} - {current_date.strftime('%A')} - {is_weekend}\")",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "generate_permutations",
        "kind": 2,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "def generate_permutations(s):\n    # 문자열 s의 모든 순열을 생성하여 리스트로 반환\n    return [''.join(permutation) for permutation in permutations(s)]\n# 예시\ns = \"abc\"\nall_permutations = generate_permutations(s)\nprint(all_permutations)\nfrom itertools import permutations\ndef generate_permutations(s, length):\n    # 문자열 s의 길이가 length인 모든 순열을 생성하여 리스트로 반환",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "generate_permutations",
        "kind": 2,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "def generate_permutations(s, length):\n    # 문자열 s의 길이가 length인 모든 순열을 생성하여 리스트로 반환\n    return [''.join(permutation) for permutation in permutations(s, length)]\ns = \"abc\"\nn = len(s)\nall_permutations = []\nfor length in range(1, n + 1):\n    all_permutations.extend(generate_permutations(s, length))\n# n진법 변환\ndef convert(n, base):",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "def convert(n, base):\n    T = \"0123456789ABCDEF\"\n    result = ''\n    while n > 0:\n        q, r = divmod(n, base)\n        result = T[r] + result\n        n = q\n    return result\ndef convert(n, base):\n    T = \"0123456789ABCDEF\"",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "def convert(n, base):\n    T = \"0123456789ABCDEF\"\n    q, r = divmod(n, base)\n    if q == 0:\n        return T[r]\n    else:\n        return convert(q, base) + T[r]\ndef convert_to_base_n(number, base):\n    if number == 0:\n        return '0'",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "convert_to_base_n",
        "kind": 2,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "def convert_to_base_n(number, base):\n    if number == 0:\n        return '0'\n    result = ''\n    while number > 0:\n        number, remainder = divmod(number, base)\n        if remainder < 10:\n            result = str(remainder) + result\n        else:\n            result = chr(remainder - 10 + ord('A')) + result",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "is_prime",
        "kind": 2,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "def is_prime(number): # 소수판별\n    if number == 2:\n        return True\n    if number <= 1:\n        return False\n    if number%2 ==0:\n        return False\n    for i in range(3, int(number ** 0.5) + 1, 2):\n        if number % i == 0:\n            return False",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "binary_search_builtin",
        "kind": 2,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "def binary_search_builtin(nums, target):\n    idx = bisect.bisect_left(nums, target)\n    # idx == len(nums) 가능하기 떄문.\n    if idx < len(nums) and nums[idx] == target:\n        return idx\n    else:  # 만약 없는경우 같거나 큰 가장 첫번째\n        # 수의 idx를 반환한다.\n        return -1\n#######################2차원 배열 선언하기\n# COLUM : 가로 길이",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "rotated",
        "kind": 2,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "def rotated(a):\n    n = len(a)  # row\n    m = len(a[0])  # col\n    result = [[0] * n for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            result[j][n - i - 1] = a[i][j]\n    return result\n#######################[Python] 두 리스트(배열) 각 요소들의 값 더하기\n# 1. list comprehension 을 사용하기",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "dijkstra_pq",
        "kind": 2,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "def dijkstra_pq(graph, start):\n    N = len(graph)\n    dist = [INF] * N\n    q = []\n    # 튜플일 경우 0번째 요소 기준으로 최소 힙 구조.\n    # 첫 번째 방문 누적 비용은 0이다.\n    heapq.heappush(q, (0, start))\n    dist[start] = 0\n    while q:\n        # 누적 비용이 가장 작은 녀석을 꺼낸다.",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "prime_list",
        "kind": 2,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "def prime_list(n):\n    # 에라토스테네스의 체 초기화: n개 요소에 True 설정(소수로 간주)\n    sieve = [True] * n\n    # n의 최대 약수가 sqrt(n) 이하이므로 i=sqrt(n)까지 검사\n    m = int(n ** 0.5)\n    for i in range(2, m + 1):\n        if sieve[i] == True:  # i가 소수인 경우\n            for j in range(i + i, n, i):  # i이후 i의 배수들을 False 판정\n                sieve[j] = False\n    # 소수 목록 산출",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "start_date",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "start_date = datetime(2023, 1, 1)\nend_date = datetime(2023, 12, 31)\ncurrent_date = start_date\nwhile current_date <= end_date:\n    is_weekend = \"Weekend\" if current_date.weekday() >= 5 else \"Weekday\"\n    print(f\"{current_date.strftime('%Y-%m-%d')} - {current_date.strftime('%A')} - {is_weekend}\")\n    current_date += timedelta(days=1)  # Move to the next day\nfrom itertools import permutations\ndef generate_permutations(s):\n    # 문자열 s의 모든 순열을 생성하여 리스트로 반환",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "end_date",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "end_date = datetime(2023, 12, 31)\ncurrent_date = start_date\nwhile current_date <= end_date:\n    is_weekend = \"Weekend\" if current_date.weekday() >= 5 else \"Weekday\"\n    print(f\"{current_date.strftime('%Y-%m-%d')} - {current_date.strftime('%A')} - {is_weekend}\")\n    current_date += timedelta(days=1)  # Move to the next day\nfrom itertools import permutations\ndef generate_permutations(s):\n    # 문자열 s의 모든 순열을 생성하여 리스트로 반환\n    return [''.join(permutation) for permutation in permutations(s)]",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "current_date",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "current_date = start_date\nwhile current_date <= end_date:\n    is_weekend = \"Weekend\" if current_date.weekday() >= 5 else \"Weekday\"\n    print(f\"{current_date.strftime('%Y-%m-%d')} - {current_date.strftime('%A')} - {is_weekend}\")\n    current_date += timedelta(days=1)  # Move to the next day\nfrom itertools import permutations\ndef generate_permutations(s):\n    # 문자열 s의 모든 순열을 생성하여 리스트로 반환\n    return [''.join(permutation) for permutation in permutations(s)]\n# 예시",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "s = \"abc\"\nall_permutations = generate_permutations(s)\nprint(all_permutations)\nfrom itertools import permutations\ndef generate_permutations(s, length):\n    # 문자열 s의 길이가 length인 모든 순열을 생성하여 리스트로 반환\n    return [''.join(permutation) for permutation in permutations(s, length)]\ns = \"abc\"\nn = len(s)\nall_permutations = []",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "all_permutations",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "all_permutations = generate_permutations(s)\nprint(all_permutations)\nfrom itertools import permutations\ndef generate_permutations(s, length):\n    # 문자열 s의 길이가 length인 모든 순열을 생성하여 리스트로 반환\n    return [''.join(permutation) for permutation in permutations(s, length)]\ns = \"abc\"\nn = len(s)\nall_permutations = []\nfor length in range(1, n + 1):",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "s = \"abc\"\nn = len(s)\nall_permutations = []\nfor length in range(1, n + 1):\n    all_permutations.extend(generate_permutations(s, length))\n# n진법 변환\ndef convert(n, base):\n    T = \"0123456789ABCDEF\"\n    result = ''\n    while n > 0:",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "n = len(s)\nall_permutations = []\nfor length in range(1, n + 1):\n    all_permutations.extend(generate_permutations(s, length))\n# n진법 변환\ndef convert(n, base):\n    T = \"0123456789ABCDEF\"\n    result = ''\n    while n > 0:\n        q, r = divmod(n, base)",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "all_permutations",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "all_permutations = []\nfor length in range(1, n + 1):\n    all_permutations.extend(generate_permutations(s, length))\n# n진법 변환\ndef convert(n, base):\n    T = \"0123456789ABCDEF\"\n    result = ''\n    while n > 0:\n        q, r = divmod(n, base)\n        result = T[r] + result",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "split_str",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "split_str = re.split(r\"([0-9]+)\", string)  # +는 기준으로나오는거 전부다 엮기\n# asdfsdf123123asdfsdf 를 > asdfasdf, 123123, asdfasdf 로 나눠준다.\n# https://whatisthenext.tistory.com/116 를 참고 하면 좋을듯?\n############### input 시간 줄이면서 리스트로 입력 받기\nimport sys\ninput = sys.stdin.readline\nhome = list(map(int, input().split()))\n# 스플릿의 경우 .strip() 붙여주면 \\n을 방지할수 있다.\n###################### 이진탐색\nstart = 0",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "input = sys.stdin.readline\nhome = list(map(int, input().split()))\n# 스플릿의 경우 .strip() 붙여주면 \\n을 방지할수 있다.\n###################### 이진탐색\nstart = 0\nend = len(lst)\ntarget = 4\nwhile start < end:\n    mid = (start + end) // 2\n    if lst[mid] < target:",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "home = list(map(int, input().split()))\n# 스플릿의 경우 .strip() 붙여주면 \\n을 방지할수 있다.\n###################### 이진탐색\nstart = 0\nend = len(lst)\ntarget = 4\nwhile start < end:\n    mid = (start + end) // 2\n    if lst[mid] < target:\n        start = mid + 1",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "start",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "start = 0\nend = len(lst)\ntarget = 4\nwhile start < end:\n    mid = (start + end) // 2\n    if lst[mid] < target:\n        start = mid + 1\n    elif lst[mid] > target:\n        end = mid\n    else:",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "end",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "end = len(lst)\ntarget = 4\nwhile start < end:\n    mid = (start + end) // 2\n    if lst[mid] < target:\n        start = mid + 1\n    elif lst[mid] > target:\n        end = mid\n    else:\n        print(lst[mid])",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "target = 4\nwhile start < end:\n    mid = (start + end) // 2\n    if lst[mid] < target:\n        start = mid + 1\n    elif lst[mid] > target:\n        end = mid\n    else:\n        print(lst[mid])\n        break",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "board",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "board = [[0 for i in range(COLUM)] for j in range(ROW)]\nresult = [[0] * row for _ in range(col)]\n########################2차원 배열 zip하기\n# https://juhee-maeng.tistory.com/entry/Python%EB%82%B4%EC%9E%A5%ED%95%A8%EC%88%98-zip%ED%95%A8%EC%88%98%EC%99%80-args-kwargs-%EB%9E%80\n# https://codingdog.tistory.com/entry/%ED%8C%8C%EC%9D%B4%EC%8D%AC-2%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4-%ED%9A%8C%EC%A0%84%EC%9D%84-1%EC%A4%84%EC%97%90-%EA%B5%AC%ED%98%84%ED%95%B4-%EB%B4%85%EC%8B%9C%EB%8B%A4\n# zip함수에 *args를 인수로 넣을 수 있다.\n# 리스트를 그냥 입력하지 말고, *를 붙여서 입력하면 col끼리 서로 엮어준다.\nfor i in zip(*alist):\n    print(i)\n# <output>",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "result = [[0] * row for _ in range(col)]\n########################2차원 배열 zip하기\n# https://juhee-maeng.tistory.com/entry/Python%EB%82%B4%EC%9E%A5%ED%95%A8%EC%88%98-zip%ED%95%A8%EC%88%98%EC%99%80-args-kwargs-%EB%9E%80\n# https://codingdog.tistory.com/entry/%ED%8C%8C%EC%9D%B4%EC%8D%AC-2%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4-%ED%9A%8C%EC%A0%84%EC%9D%84-1%EC%A4%84%EC%97%90-%EA%B5%AC%ED%98%84%ED%95%B4-%EB%B4%85%EC%8B%9C%EB%8B%A4\n# zip함수에 *args를 인수로 넣을 수 있다.\n# 리스트를 그냥 입력하지 말고, *를 붙여서 입력하면 col끼리 서로 엮어준다.\nfor i in zip(*alist):\n    print(i)\n# <output>\n# (1, 4, 7)",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "blist",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "blist = list(map(list, zip(*alist)))\n# <output>\n# blist\n# [[1, 2, 3], [1, 2, 3], [1, 2, 3]]\n##################### 2차원 배열 회전하기\ndef rotated(a):\n    n = len(a)  # row\n    m = len(a[0])  # col\n    result = [[0] * n for _ in range(m)]\n    for i in range(n):",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "INF",
        "kind": 5,
        "importPath": "0_shortcut.go",
        "description": "0_shortcut.go",
        "peekOfCode": "INF = int(1e9)\ndef dijkstra_pq(graph, start):\n    N = len(graph)\n    dist = [INF] * N\n    q = []\n    # 튜플일 경우 0번째 요소 기준으로 최소 힙 구조.\n    # 첫 번째 방문 누적 비용은 0이다.\n    heapq.heappush(q, (0, start))\n    dist[start] = 0\n    while q:",
        "detail": "0_shortcut.go",
        "documentation": {}
    },
    {
        "label": "count_pairs",
        "kind": 2,
        "importPath": "0_shortcut.test",
        "description": "0_shortcut.test",
        "peekOfCode": "def count_pairs(lst):\n    lst.sort()  # Sort the list\n    left = 0  # Initialize left pointer\n    count = 0\n    n = len(lst)\n    for right in range(n):\n        while lst[right] - lst[left] > 4:\n            left += 1  # Move left pointer forward if difference is more than 4\n        count += right - left  # Count pairs for the current right pointer\n    return count",
        "detail": "0_shortcut.test",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "0_shortcut.test",
        "description": "0_shortcut.test",
        "peekOfCode": "numbers = [1, 5, 9, 12, 15, 20, 24]\n# Function call and print result\nresult = count_pairs(numbers)\nprint(\"Number of pairs with difference of 4 or less:\", result)",
        "detail": "0_shortcut.test",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "0_shortcut.test",
        "description": "0_shortcut.test",
        "peekOfCode": "result = count_pairs(numbers)\nprint(\"Number of pairs with difference of 4 or less:\", result)",
        "detail": "0_shortcut.test",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "1eetcode.22",
        "description": "1eetcode.22",
        "peekOfCode": "class Solution:\n    def dfs(self,n,start_count, end_count,atom,answer):\n        if start_count==n and end_count==n:\n            answer.append(atom)\n            return answer\n        if start_count >= end_count:\n            if start_count < n:\n                self.dfs(n,start_count+1, end_count,atom+\"(\",answer)\n                self.dfs(n,start_count, end_count+1,atom+\")\",answer)\n            else:",
        "detail": "1eetcode.22",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "1eetcode.46",
        "description": "1eetcode.46",
        "peekOfCode": "class Solution:\n    def dfs(self,visited,nums,atom,temp):\n        if len(atom)==len(nums):\n            temp.append(atom[:]) #shallow copy 때문에 \n            return temp\n        for i in range(len(nums)):\n            if visited[i]==0:\n                atom.append(nums[i])\n                visited[i]=1\n                self.dfs(visited,nums,atom,temp)",
        "detail": "1eetcode.46",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "1eetcode.46",
        "description": "1eetcode.46",
        "peekOfCode": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        return [list(perm) for perm in permutations(nums)]",
        "detail": "1eetcode.46",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "1eetcode.530",
        "description": "1eetcode.530",
        "peekOfCode": "class Solution:\n    # 리스트로 만들어서 정렬후에 +1 자리와 비교?\n    # inorder를 사용할 시에 오름차순 정렬이 된다.\n    # 차이값을 계산하기위해 노드를 2개이상 발견했는지에 대한 판단 필요\n    def __init__(self):\n        self.init = False\n        self.prev = None\n        self.min_val = float('inf')\n    def inorder(self, root: TreeNode):\n        if root is None:",
        "detail": "1eetcode.530",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "1eetcode.589",
        "description": "1eetcode.589",
        "peekOfCode": "class Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\nclass Solution:\n    def dfs(self,node,answer):\n        answer.append(node.val)\n        if len(node.children) == 0:\n            return answer",
        "detail": "1eetcode.589",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "1eetcode.589",
        "description": "1eetcode.589",
        "peekOfCode": "class Solution:\n    def dfs(self,node,answer):\n        answer.append(node.val)\n        if len(node.children) == 0:\n            return answer\n        for child in node.children:\n            self.dfs(child,answer)\n        return answer\n    def preorder(self, root: 'Node') -> List[int]:\n        # 트리 순회 dfs",
        "detail": "1eetcode.589",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "1eetcode.876",
        "description": "1eetcode.876",
        "peekOfCode": "class Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # ListNode를 list형태로 만들어서 나머지 절반을 출력한다?\n        # 리스트 길이//2 + 1 번째 부터 출력 \n        # return 형이 listNode 여야 하나봐\n        if head.next is None:\n            return [head.val]\n        linked_list=[]\n        while head.next is not None:\n            linked_list.append(head.val)",
        "detail": "1eetcode.876",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "1eetcode.876",
        "description": "1eetcode.876",
        "peekOfCode": "class Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # ListNode를 list형태로 만들어서 나머지 절반을 출력한다?\n        # 리스트 길이//2 + 1 번째 부터 출력 \n        # return 형이 listNode 여야 하나봐\n        head_coppied = head\n        if head.next is None:\n            return head\n        count=0\n        while head.next is not None:",
        "detail": "1eetcode.876",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "1eetcode.98",
        "description": "1eetcode.98",
        "peekOfCode": "class Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        return self.validate(root, float('-inf'), float('inf'))\n    # 왼쪽 서브트리와 오른쪽 서브트리에 대해 재귀적으로 호출\n    # 현재 노드의 값이 범위 밖에 있는지 확인\n    # 왼쪽 서브트리는 현재 노드의 값보다 작아야 하며, 최대값은 현재 노드의 값이 됨\n    # 오른쪽 서브트리는 현재 노드의 값보다 커야 하며, 최소값은 현재 노드의 값이 됨\n    def validate(self, node, min_val, max_val):\n        if not node:\n            return True",
        "detail": "1eetcode.98",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "1eetcode.98",
        "description": "1eetcode.98",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def check_bst(self, node: Optional[TreeNode],direction):\n        root_val = node.val\n        if direction == 'L':\n            if not node.left.val < node.val:",
        "detail": "1eetcode.98",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "1eetcode.98",
        "description": "1eetcode.98",
        "peekOfCode": "class Solution:\n    def check_bst(self, node: Optional[TreeNode],direction):\n        root_val = node.val\n        if direction == 'L':\n            if not node.left.val < node.val:\n                return False\n            node=node.left\n            if node.left is not None:\n                if not node.left.val < root_val:\n                    return False",
        "detail": "1eetcode.98",
        "documentation": {}
    },
    {
        "label": "child",
        "kind": 5,
        "importPath": "1eetcode.98",
        "description": "1eetcode.98",
        "peekOfCode": "child = TreeNode(val=1)\nparent = TreeNode(val=1,left=child)\nprint(parent.val)\nprint(parent.left.val)\nsolution = Solution.isValidBST(parent)",
        "detail": "1eetcode.98",
        "documentation": {}
    },
    {
        "label": "parent",
        "kind": 5,
        "importPath": "1eetcode.98",
        "description": "1eetcode.98",
        "peekOfCode": "parent = TreeNode(val=1,left=child)\nprint(parent.val)\nprint(parent.left.val)\nsolution = Solution.isValidBST(parent)",
        "detail": "1eetcode.98",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "1eetcode.98",
        "description": "1eetcode.98",
        "peekOfCode": "solution = Solution.isValidBST(parent)",
        "detail": "1eetcode.98",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "2cote.antena",
        "description": "2cote.antena",
        "peekOfCode": "input = sys.stdin.readline\nn = int(input())\nhome = list(map(int, input().split()))\nhome.sort()\nres=(len(home)-1)//2\nprint(home[res])\n# #\n# # 논리\n# # home의 i번째 인덱스를 기준으로 삼고, 그때 각 거리를 비교하여 더한다.\n# # 거리를 비교하여 가장 작은 값일때의 i번째 인덱스를 출력한다.",
        "detail": "2cote.antena",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.antena",
        "description": "2cote.antena",
        "peekOfCode": "n = int(input())\nhome = list(map(int, input().split()))\nhome.sort()\nres=(len(home)-1)//2\nprint(home[res])\n# #\n# # 논리\n# # home의 i번째 인덱스를 기준으로 삼고, 그때 각 거리를 비교하여 더한다.\n# # 거리를 비교하여 가장 작은 값일때의 i번째 인덱스를 출력한다.\n# #",
        "detail": "2cote.antena",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 5,
        "importPath": "2cote.antena",
        "description": "2cote.antena",
        "peekOfCode": "home = list(map(int, input().split()))\nhome.sort()\nres=(len(home)-1)//2\nprint(home[res])\n# #\n# # 논리\n# # home의 i번째 인덱스를 기준으로 삼고, 그때 각 거리를 비교하여 더한다.\n# # 거리를 비교하여 가장 작은 값일때의 i번째 인덱스를 출력한다.\n# #\n# for i in home:",
        "detail": "2cote.antena",
        "documentation": {}
    },
    {
        "label": "slicing",
        "kind": 2,
        "importPath": "2cote.any",
        "description": "2cote.any",
        "peekOfCode": "def slicing(q, cnt, temp):  # cnt 는 zip count이면서 cursor 역할까지.\n    if len(q) == 1:\n        temp += q[0]\n        print(temp)\n        print(len(temp))\n        return len(temp)\n    if q[0] == q[1]:  # 처음원소와 다음원소가 같다면.\n        cnt += 1\n    else:\n        if cnt > 1:",
        "detail": "2cote.any",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "2cote.any",
        "description": "2cote.any",
        "peekOfCode": "s = 'aaaacbbd'\na = list(s)\nq = deque(a)\nprint(slicing(q, 1, 'test: '))",
        "detail": "2cote.any",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "2cote.any",
        "description": "2cote.any",
        "peekOfCode": "a = list(s)\nq = deque(a)\nprint(slicing(q, 1, 'test: '))",
        "detail": "2cote.any",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "2cote.any",
        "description": "2cote.any",
        "peekOfCode": "q = deque(a)\nprint(slicing(q, 1, 'test: '))",
        "detail": "2cote.any",
        "documentation": {}
    },
    {
        "label": "list1",
        "kind": 5,
        "importPath": "2cote.bignum_greedy",
        "description": "2cote.bignum_greedy",
        "peekOfCode": "list1 = list(input('index 입력 (%d)개 : ' % n).split())\nlist1.sort()\nprint(list1)\nlist1_int = list(map(int, list1))    #list의 형변환\nprint(list1_int)\ntemp = 0\ncnt = 0\nfor i in range(m):  # n=5, m=8, k=3\n    # m회가 되었을때 더한 숫자를 출력한다.\n    if cnt >= m: break",
        "detail": "2cote.bignum_greedy",
        "documentation": {}
    },
    {
        "label": "list1_int",
        "kind": 5,
        "importPath": "2cote.bignum_greedy",
        "description": "2cote.bignum_greedy",
        "peekOfCode": "list1_int = list(map(int, list1))    #list의 형변환\nprint(list1_int)\ntemp = 0\ncnt = 0\nfor i in range(m):  # n=5, m=8, k=3\n    # m회가 되었을때 더한 숫자를 출력한다.\n    if cnt >= m: break\n    for j in range(k):\n        # 가장큰수를 k번 더하고 그 다음 큰수를 1번 더한다.\n        if cnt >= m: break",
        "detail": "2cote.bignum_greedy",
        "documentation": {}
    },
    {
        "label": "temp",
        "kind": 5,
        "importPath": "2cote.bignum_greedy",
        "description": "2cote.bignum_greedy",
        "peekOfCode": "temp = 0\ncnt = 0\nfor i in range(m):  # n=5, m=8, k=3\n    # m회가 되었을때 더한 숫자를 출력한다.\n    if cnt >= m: break\n    for j in range(k):\n        # 가장큰수를 k번 더하고 그 다음 큰수를 1번 더한다.\n        if cnt >= m: break\n        temp += list1_int[-1]\n        cnt += 1",
        "detail": "2cote.bignum_greedy",
        "documentation": {}
    },
    {
        "label": "cnt",
        "kind": 5,
        "importPath": "2cote.bignum_greedy",
        "description": "2cote.bignum_greedy",
        "peekOfCode": "cnt = 0\nfor i in range(m):  # n=5, m=8, k=3\n    # m회가 되었을때 더한 숫자를 출력한다.\n    if cnt >= m: break\n    for j in range(k):\n        # 가장큰수를 k번 더하고 그 다음 큰수를 1번 더한다.\n        if cnt >= m: break\n        temp += list1_int[-1]\n        cnt += 1\n    temp += list1_int[-2]",
        "detail": "2cote.bignum_greedy",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "2cote.bignum_greedy",
        "description": "2cote.bignum_greedy",
        "peekOfCode": "result = temp\nprint(result)",
        "detail": "2cote.bignum_greedy",
        "documentation": {}
    },
    {
        "label": "nToBin",
        "kind": 5,
        "importPath": "2cote.binary",
        "description": "2cote.binary",
        "peekOfCode": "nToBin = format(17, 'b')\ntemp = 0\nfor x in nToBin:\n    # print(x)\n    temp += int(x)\ntemp2 = 0\narr = []\nfor i in range(1, 17):\n    iToBin = format(i, 'b')\n    # print('itobin : ', iToBin)",
        "detail": "2cote.binary",
        "documentation": {}
    },
    {
        "label": "temp",
        "kind": 5,
        "importPath": "2cote.binary",
        "description": "2cote.binary",
        "peekOfCode": "temp = 0\nfor x in nToBin:\n    # print(x)\n    temp += int(x)\ntemp2 = 0\narr = []\nfor i in range(1, 17):\n    iToBin = format(i, 'b')\n    # print('itobin : ', iToBin)",
        "detail": "2cote.binary",
        "documentation": {}
    },
    {
        "label": "temp2",
        "kind": 5,
        "importPath": "2cote.binary",
        "description": "2cote.binary",
        "peekOfCode": "temp2 = 0\narr = []\nfor i in range(1, 17):\n    iToBin = format(i, 'b')\n    # print('itobin : ', iToBin)",
        "detail": "2cote.binary",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "2cote.binary",
        "description": "2cote.binary",
        "peekOfCode": "arr = []\nfor i in range(1, 17):\n    iToBin = format(i, 'b')\n    # print('itobin : ', iToBin)",
        "detail": "2cote.binary",
        "documentation": {}
    },
    {
        "label": "treenode",
        "kind": 6,
        "importPath": "2cote.binary_search_findthing",
        "description": "2cote.binary_search_findthing",
        "peekOfCode": "class treenode:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n# 어떻게 해야 빨리 찾을수 있을지..\n# sort해서 midium값 기준으로 tree를 만들고 탐색한다.?\n# for i in find > find[i] is in thing?\n# 불균형트리일수도 있는데 고유번호라고 했으니 중복index가 없는 균형 트리로 풀자\n#                     7",
        "detail": "2cote.binary_search_findthing",
        "documentation": {}
    },
    {
        "label": "maketree",
        "kind": 2,
        "importPath": "2cote.binary_search_findthing",
        "description": "2cote.binary_search_findthing",
        "peekOfCode": "def maketree(lst):\n    if not lst:\n        return None\n    mid = len(lst) // 2\n    node = treenode(lst[mid])\n    node.left = maketree(lst[:mid])\n    node.right = maketree(lst[mid + 1:])\n    return node\n# main 함수\ndef search(thing, find):",
        "detail": "2cote.binary_search_findthing",
        "documentation": {}
    },
    {
        "label": "search",
        "kind": 2,
        "importPath": "2cote.binary_search_findthing",
        "description": "2cote.binary_search_findthing",
        "peekOfCode": "def search(thing, find):\n    # result=[] 원래 이렇게 하려고 했음.\n    result = ['no'] * len(find)  # yes no를 넣을 list\n    root = maketree(thing)\n    def dfs(find, root):\n        if not root:\n            return\n        for i in range(len(find)):\n            if find[i] == root.val:\n                print('find[i]: ', i, find[i])",
        "detail": "2cote.binary_search_findthing",
        "documentation": {}
    },
    {
        "label": "thing",
        "kind": 5,
        "importPath": "2cote.binary_search_findthing",
        "description": "2cote.binary_search_findthing",
        "peekOfCode": "thing = [8, 3, 7, 9, 2]  # [2,3,7,8,9]\nfind = [5, 7, 9]\nthing.sort()\nsearch(thing, find)\n###############################################\n# class treenode:\n#\n#     def __init__(self, val, left=None, right=None):\n#         self.val = val\n#         self.left = left",
        "detail": "2cote.binary_search_findthing",
        "documentation": {}
    },
    {
        "label": "find",
        "kind": 5,
        "importPath": "2cote.binary_search_findthing",
        "description": "2cote.binary_search_findthing",
        "peekOfCode": "find = [5, 7, 9]\nthing.sort()\nsearch(thing, find)\n###############################################\n# class treenode:\n#\n#     def __init__(self, val, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right",
        "detail": "2cote.binary_search_findthing",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "2cote.binary_search_pinpoint",
        "description": "2cote.binary_search_pinpoint",
        "peekOfCode": "lst = [-15, -14, -10, -5, 1, 2, 3, 4, 9, 13, 15, 24]\nstart=0\nend = len(lst)\ntarget=4\nwhile start < end:\n    mid = (start+end) // 2\n    print('mid: ',mid)\n    if lst[mid] < target:\n        start = mid + 1\n    elif lst[mid] > target:",
        "detail": "2cote.binary_search_pinpoint",
        "documentation": {}
    },
    {
        "label": "end",
        "kind": 5,
        "importPath": "2cote.binary_search_pinpoint",
        "description": "2cote.binary_search_pinpoint",
        "peekOfCode": "end = len(lst)\ntarget=4\nwhile start < end:\n    mid = (start+end) // 2\n    print('mid: ',mid)\n    if lst[mid] < target:\n        start = mid + 1\n    elif lst[mid] > target:\n        end = mid\n    else:",
        "detail": "2cote.binary_search_pinpoint",
        "documentation": {}
    },
    {
        "label": "bfs",
        "kind": 2,
        "importPath": "2cote.dfs_bfs4_maze",
        "description": "2cote.dfs_bfs4_maze",
        "peekOfCode": "def bfs(x, y):\n    # 큐(Queue) 구현을 위해 deque 라이브러리 사용\n    queue = deque()\n    queue.append((x, y))\n    # 큐가 빌 때까지 반복하기\n    while queue:\n        print('queue: ', queue)\n        x, y = queue.popleft()\n        print('after pop.queue: ', queue)\n        # 현재 위치에서 4가지 방향으로의 위치 확인",
        "detail": "2cote.dfs_bfs4_maze",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "2cote.dfs_bfs4_maze",
        "description": "2cote.dfs_bfs4_maze",
        "peekOfCode": "graph = [\n    [1, 1, 1, 0, 1, 0],\n    [0, 1, 0, 1, 1, 1],\n    [1, 1, 0, 0, 0, 1],\n    [1, 0, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1]\n]\n# for i in range(n):\n#     graph.append(list(map(int, input())))\n# 이동할 네 가지 방향 정의 (상, 하, 좌, 우)",
        "detail": "2cote.dfs_bfs4_maze",
        "documentation": {}
    },
    {
        "label": "dx",
        "kind": 5,
        "importPath": "2cote.dfs_bfs4_maze",
        "description": "2cote.dfs_bfs4_maze",
        "peekOfCode": "dx = [-1, 1, 0, 0]\ndy = [0, 0, -1, 1]\n# BFS 소스코드 구현\ndef bfs(x, y):\n    # 큐(Queue) 구현을 위해 deque 라이브러리 사용\n    queue = deque()\n    queue.append((x, y))\n    # 큐가 빌 때까지 반복하기\n    while queue:\n        print('queue: ', queue)",
        "detail": "2cote.dfs_bfs4_maze",
        "documentation": {}
    },
    {
        "label": "dy",
        "kind": 5,
        "importPath": "2cote.dfs_bfs4_maze",
        "description": "2cote.dfs_bfs4_maze",
        "peekOfCode": "dy = [0, 0, -1, 1]\n# BFS 소스코드 구현\ndef bfs(x, y):\n    # 큐(Queue) 구현을 위해 deque 라이브러리 사용\n    queue = deque()\n    queue.append((x, y))\n    # 큐가 빌 때까지 반복하기\n    while queue:\n        print('queue: ', queue)\n        x, y = queue.popleft()",
        "detail": "2cote.dfs_bfs4_maze",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "2cote.dfs_searchcity",
        "description": "2cote.dfs_searchcity",
        "peekOfCode": "input = sys.stdin.readline\nN, M, K, X = map(int, input().split())  # 도시개수,도로개수,최단거리,출발도시의번호\ngraph = [[] for _ in range(1 + N)]\nfor i in range(M):  # 도로정보입력받기\n    a, b = map(int, input().split())\n    graph[a].append(b)  # 1 2 / 1 3 / 2 3 / 2 4  딕셔너리로 하려고 했지만 이방법이 더 쉬운듯.\nprint(graph)\ndistance = [-1] * (N + 1)  # 최단거리가 k인 도시가 존재하지 않을경우 -1을 return하므로..\n                           # N+1을 하는이유는 idx_num과 도시num 맞추려고\ndistance[X] = 0",
        "detail": "2cote.dfs_searchcity",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "2cote.dfs_searchcity",
        "description": "2cote.dfs_searchcity",
        "peekOfCode": "graph = [[] for _ in range(1 + N)]\nfor i in range(M):  # 도로정보입력받기\n    a, b = map(int, input().split())\n    graph[a].append(b)  # 1 2 / 1 3 / 2 3 / 2 4  딕셔너리로 하려고 했지만 이방법이 더 쉬운듯.\nprint(graph)\ndistance = [-1] * (N + 1)  # 최단거리가 k인 도시가 존재하지 않을경우 -1을 return하므로..\n                           # N+1을 하는이유는 idx_num과 도시num 맞추려고\ndistance[X] = 0\nprint('distance: ', distance)\nq = deque([X])",
        "detail": "2cote.dfs_searchcity",
        "documentation": {}
    },
    {
        "label": "distance",
        "kind": 5,
        "importPath": "2cote.dfs_searchcity",
        "description": "2cote.dfs_searchcity",
        "peekOfCode": "distance = [-1] * (N + 1)  # 최단거리가 k인 도시가 존재하지 않을경우 -1을 return하므로..\n                           # N+1을 하는이유는 idx_num과 도시num 맞추려고\ndistance[X] = 0\nprint('distance: ', distance)\nq = deque([X])\nwhile q:\n    now = q.popleft()\n    for next in graph[now]:\n        if distance[next] == -1:  # 아직 가지 않았다면\n            distance[next] = distance[now] + 1",
        "detail": "2cote.dfs_searchcity",
        "documentation": {}
    },
    {
        "label": "distance[X]",
        "kind": 5,
        "importPath": "2cote.dfs_searchcity",
        "description": "2cote.dfs_searchcity",
        "peekOfCode": "distance[X] = 0\nprint('distance: ', distance)\nq = deque([X])\nwhile q:\n    now = q.popleft()\n    for next in graph[now]:\n        if distance[next] == -1:  # 아직 가지 않았다면\n            distance[next] = distance[now] + 1\n            q.append(next)  # bfs\nflag = 1",
        "detail": "2cote.dfs_searchcity",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "2cote.dfs_searchcity",
        "description": "2cote.dfs_searchcity",
        "peekOfCode": "q = deque([X])\nwhile q:\n    now = q.popleft()\n    for next in graph[now]:\n        if distance[next] == -1:  # 아직 가지 않았다면\n            distance[next] = distance[now] + 1\n            q.append(next)  # bfs\nflag = 1\nfor i in range(1, N + 1):\n    if distance[i] == K:  # 최단거리가 k인 도시의 번호 출력",
        "detail": "2cote.dfs_searchcity",
        "documentation": {}
    },
    {
        "label": "flag",
        "kind": 5,
        "importPath": "2cote.dfs_searchcity",
        "description": "2cote.dfs_searchcity",
        "peekOfCode": "flag = 1\nfor i in range(1, N + 1):\n    if distance[i] == K:  # 최단거리가 k인 도시의 번호 출력\n        print(i)\n        flag = 0\nif flag == 1:  # 최단거리가 k가 없다면 print(-1)\n    print(-1)\n# # 도시의 갯수 N, 도로의 갯수 M,\n# # 거리정보 K, 출발 도시의 번호 X\n#",
        "detail": "2cote.dfs_searchcity",
        "documentation": {}
    },
    {
        "label": "row",
        "kind": 5,
        "importPath": "2cote.game_dev",
        "description": "2cote.game_dev",
        "peekOfCode": "row = 4\ncol = 4\ngame_map = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1], [1, 1, 1, 1]]\n# 시작 값\nr = 1  # 횡\nc = 1  # 종\ndirection = 0\n# 북 동 남 서 0 1 2 3 // -1 => 3\ndr = [-1, 0, 1, 0]\ndc = [0, 1, 0, -1]",
        "detail": "2cote.game_dev",
        "documentation": {}
    },
    {
        "label": "col",
        "kind": 5,
        "importPath": "2cote.game_dev",
        "description": "2cote.game_dev",
        "peekOfCode": "col = 4\ngame_map = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1], [1, 1, 1, 1]]\n# 시작 값\nr = 1  # 횡\nc = 1  # 종\ndirection = 0\n# 북 동 남 서 0 1 2 3 // -1 => 3\ndr = [-1, 0, 1, 0]\ndc = [0, 1, 0, -1]\ngame_map[r][c] = 2  # 초기 방문 위치",
        "detail": "2cote.game_dev",
        "documentation": {}
    },
    {
        "label": "game_map",
        "kind": 5,
        "importPath": "2cote.game_dev",
        "description": "2cote.game_dev",
        "peekOfCode": "game_map = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1], [1, 1, 1, 1]]\n# 시작 값\nr = 1  # 횡\nc = 1  # 종\ndirection = 0\n# 북 동 남 서 0 1 2 3 // -1 => 3\ndr = [-1, 0, 1, 0]\ndc = [0, 1, 0, -1]\ngame_map[r][c] = 2  # 초기 방문 위치\ncount = 1",
        "detail": "2cote.game_dev",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "2cote.game_dev",
        "description": "2cote.game_dev",
        "peekOfCode": "r = 1  # 횡\nc = 1  # 종\ndirection = 0\n# 북 동 남 서 0 1 2 3 // -1 => 3\ndr = [-1, 0, 1, 0]\ndc = [0, 1, 0, -1]\ngame_map[r][c] = 2  # 초기 방문 위치\ncount = 1\nrotate = 0\nwhile True:",
        "detail": "2cote.game_dev",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": "2cote.game_dev",
        "description": "2cote.game_dev",
        "peekOfCode": "c = 1  # 종\ndirection = 0\n# 북 동 남 서 0 1 2 3 // -1 => 3\ndr = [-1, 0, 1, 0]\ndc = [0, 1, 0, -1]\ngame_map[r][c] = 2  # 초기 방문 위치\ncount = 1\nrotate = 0\nwhile True:\n    direction -= 1  # 반시계 회전",
        "detail": "2cote.game_dev",
        "documentation": {}
    },
    {
        "label": "direction",
        "kind": 5,
        "importPath": "2cote.game_dev",
        "description": "2cote.game_dev",
        "peekOfCode": "direction = 0\n# 북 동 남 서 0 1 2 3 // -1 => 3\ndr = [-1, 0, 1, 0]\ndc = [0, 1, 0, -1]\ngame_map[r][c] = 2  # 초기 방문 위치\ncount = 1\nrotate = 0\nwhile True:\n    direction -= 1  # 반시계 회전\n    if direction == -1:",
        "detail": "2cote.game_dev",
        "documentation": {}
    },
    {
        "label": "dr",
        "kind": 5,
        "importPath": "2cote.game_dev",
        "description": "2cote.game_dev",
        "peekOfCode": "dr = [-1, 0, 1, 0]\ndc = [0, 1, 0, -1]\ngame_map[r][c] = 2  # 초기 방문 위치\ncount = 1\nrotate = 0\nwhile True:\n    direction -= 1  # 반시계 회전\n    if direction == -1:\n        direction = 3\n    nr = r + dr[direction]",
        "detail": "2cote.game_dev",
        "documentation": {}
    },
    {
        "label": "dc",
        "kind": 5,
        "importPath": "2cote.game_dev",
        "description": "2cote.game_dev",
        "peekOfCode": "dc = [0, 1, 0, -1]\ngame_map[r][c] = 2  # 초기 방문 위치\ncount = 1\nrotate = 0\nwhile True:\n    direction -= 1  # 반시계 회전\n    if direction == -1:\n        direction = 3\n    nr = r + dr[direction]\n    nc = c + dc[direction]",
        "detail": "2cote.game_dev",
        "documentation": {}
    },
    {
        "label": "game_map[r][c]",
        "kind": 5,
        "importPath": "2cote.game_dev",
        "description": "2cote.game_dev",
        "peekOfCode": "game_map[r][c] = 2  # 초기 방문 위치\ncount = 1\nrotate = 0\nwhile True:\n    direction -= 1  # 반시계 회전\n    if direction == -1:\n        direction = 3\n    nr = r + dr[direction]\n    nc = c + dc[direction]\n    # 회전 후 갈 수 있을때",
        "detail": "2cote.game_dev",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 5,
        "importPath": "2cote.game_dev",
        "description": "2cote.game_dev",
        "peekOfCode": "count = 1\nrotate = 0\nwhile True:\n    direction -= 1  # 반시계 회전\n    if direction == -1:\n        direction = 3\n    nr = r + dr[direction]\n    nc = c + dc[direction]\n    # 회전 후 갈 수 있을때\n    if game_map[nr][nc] == 0:",
        "detail": "2cote.game_dev",
        "documentation": {}
    },
    {
        "label": "rotate",
        "kind": 5,
        "importPath": "2cote.game_dev",
        "description": "2cote.game_dev",
        "peekOfCode": "rotate = 0\nwhile True:\n    direction -= 1  # 반시계 회전\n    if direction == -1:\n        direction = 3\n    nr = r + dr[direction]\n    nc = c + dc[direction]\n    # 회전 후 갈 수 있을때\n    if game_map[nr][nc] == 0:\n        game_map[nr][nc] = 2",
        "detail": "2cote.game_dev",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.greedy_cantmake",
        "description": "2cote.greedy_cantmake",
        "peekOfCode": "n = int(input())\nlst = list(map(int, input().split()))\nres = [[]]\nresult = []\nif min(lst) != 1:\n    print(min(lst) - 1)\nelse:\n    for i in lst:  # res=[[]]\n        size = len(res)\n        for j in range(size):",
        "detail": "2cote.greedy_cantmake",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "2cote.greedy_cantmake",
        "description": "2cote.greedy_cantmake",
        "peekOfCode": "lst = list(map(int, input().split()))\nres = [[]]\nresult = []\nif min(lst) != 1:\n    print(min(lst) - 1)\nelse:\n    for i in lst:  # res=[[]]\n        size = len(res)\n        for j in range(size):\n            res.append(res[j] + [i])",
        "detail": "2cote.greedy_cantmake",
        "documentation": {}
    },
    {
        "label": "res",
        "kind": 5,
        "importPath": "2cote.greedy_cantmake",
        "description": "2cote.greedy_cantmake",
        "peekOfCode": "res = [[]]\nresult = []\nif min(lst) != 1:\n    print(min(lst) - 1)\nelse:\n    for i in lst:  # res=[[]]\n        size = len(res)\n        for j in range(size):\n            res.append(res[j] + [i])\n            print(res)",
        "detail": "2cote.greedy_cantmake",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "2cote.greedy_cantmake",
        "description": "2cote.greedy_cantmake",
        "peekOfCode": "result = []\nif min(lst) != 1:\n    print(min(lst) - 1)\nelse:\n    for i in lst:  # res=[[]]\n        size = len(res)\n        for j in range(size):\n            res.append(res[j] + [i])\n            print(res)\n    for i in range(len(res)):",
        "detail": "2cote.greedy_cantmake",
        "documentation": {}
    },
    {
        "label": "weights",
        "kind": 5,
        "importPath": "2cote.greedy_choiceball",
        "description": "2cote.greedy_choiceball",
        "peekOfCode": "weights = list(map(int, input().split()))\n# value를 가진 경우의 수\nlst = [0] * m\nresult = 0\nfor i in weights:\n    lst[i - 1] += 1\nfor i in range(m):\n    n -= lst[i]  # a를 고르고\n    result += lst[i] * n  # b를 골라\nprint(result)",
        "detail": "2cote.greedy_choiceball",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "2cote.greedy_choiceball",
        "description": "2cote.greedy_choiceball",
        "peekOfCode": "lst = [0] * m\nresult = 0\nfor i in weights:\n    lst[i - 1] += 1\nfor i in range(m):\n    n -= lst[i]  # a를 고르고\n    result += lst[i] * n  # b를 골라\nprint(result)\n#\n# # sol) n^2",
        "detail": "2cote.greedy_choiceball",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "2cote.greedy_choiceball",
        "description": "2cote.greedy_choiceball",
        "peekOfCode": "result = 0\nfor i in weights:\n    lst[i - 1] += 1\nfor i in range(m):\n    n -= lst[i]  # a를 고르고\n    result += lst[i] * n  # b를 골라\nprint(result)\n#\n# # sol) n^2\n# lst = []",
        "detail": "2cote.greedy_choiceball",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "2cote.greedy_choiceballt2",
        "description": "2cote.greedy_choiceballt2",
        "peekOfCode": "lst = list(map(int, input().split()))\ncnt = 0\nfor i in range(len(lst) - 1):\n    for j in range(i+1, len(lst)):\n        if lst[i] != lst[j]:\n            cnt += 1\nprint(cnt)",
        "detail": "2cote.greedy_choiceballt2",
        "documentation": {}
    },
    {
        "label": "cnt",
        "kind": 5,
        "importPath": "2cote.greedy_choiceballt2",
        "description": "2cote.greedy_choiceballt2",
        "peekOfCode": "cnt = 0\nfor i in range(len(lst) - 1):\n    for j in range(i+1, len(lst)):\n        if lst[i] != lst[j]:\n            cnt += 1\nprint(cnt)",
        "detail": "2cote.greedy_choiceballt2",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.greedy_invertString",
        "description": "2cote.greedy_invertString",
        "peekOfCode": "n = input()\nlst = []\nfor i in n:\n    lst.append(i)\noneM = 0\ntwoM = 0\nflag = 0\nlast = lst.pop()\nwhile lst:  # 00  11  00\n    temp = lst.pop()",
        "detail": "2cote.greedy_invertString",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "2cote.greedy_invertString",
        "description": "2cote.greedy_invertString",
        "peekOfCode": "lst = []\nfor i in n:\n    lst.append(i)\noneM = 0\ntwoM = 0\nflag = 0\nlast = lst.pop()\nwhile lst:  # 00  11  00\n    temp = lst.pop()\n    if temp == last:",
        "detail": "2cote.greedy_invertString",
        "documentation": {}
    },
    {
        "label": "oneM",
        "kind": 5,
        "importPath": "2cote.greedy_invertString",
        "description": "2cote.greedy_invertString",
        "peekOfCode": "oneM = 0\ntwoM = 0\nflag = 0\nlast = lst.pop()\nwhile lst:  # 00  11  00\n    temp = lst.pop()\n    if temp == last:\n        continue\n    else:\n        if flag == 0:",
        "detail": "2cote.greedy_invertString",
        "documentation": {}
    },
    {
        "label": "twoM",
        "kind": 5,
        "importPath": "2cote.greedy_invertString",
        "description": "2cote.greedy_invertString",
        "peekOfCode": "twoM = 0\nflag = 0\nlast = lst.pop()\nwhile lst:  # 00  11  00\n    temp = lst.pop()\n    if temp == last:\n        continue\n    else:\n        if flag == 0:\n            oneM += 1",
        "detail": "2cote.greedy_invertString",
        "documentation": {}
    },
    {
        "label": "flag",
        "kind": 5,
        "importPath": "2cote.greedy_invertString",
        "description": "2cote.greedy_invertString",
        "peekOfCode": "flag = 0\nlast = lst.pop()\nwhile lst:  # 00  11  00\n    temp = lst.pop()\n    if temp == last:\n        continue\n    else:\n        if flag == 0:\n            oneM += 1\n            flag = 1",
        "detail": "2cote.greedy_invertString",
        "documentation": {}
    },
    {
        "label": "last",
        "kind": 5,
        "importPath": "2cote.greedy_invertString",
        "description": "2cote.greedy_invertString",
        "peekOfCode": "last = lst.pop()\nwhile lst:  # 00  11  00\n    temp = lst.pop()\n    if temp == last:\n        continue\n    else:\n        if flag == 0:\n            oneM += 1\n            flag = 1\n        else:",
        "detail": "2cote.greedy_invertString",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.greedy_mulsum",
        "description": "2cote.greedy_mulsum",
        "peekOfCode": "n = input()\nlst = []\nfor i in n:\n    lst.append(i)\nlst2 = list(map(int, lst))\nq = deque(lst2)\nres = q.popleft()\nwhile q:\n    temp = q.popleft()\n    if res == 0:",
        "detail": "2cote.greedy_mulsum",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "2cote.greedy_mulsum",
        "description": "2cote.greedy_mulsum",
        "peekOfCode": "lst = []\nfor i in n:\n    lst.append(i)\nlst2 = list(map(int, lst))\nq = deque(lst2)\nres = q.popleft()\nwhile q:\n    temp = q.popleft()\n    if res == 0:\n        res += temp",
        "detail": "2cote.greedy_mulsum",
        "documentation": {}
    },
    {
        "label": "lst2",
        "kind": 5,
        "importPath": "2cote.greedy_mulsum",
        "description": "2cote.greedy_mulsum",
        "peekOfCode": "lst2 = list(map(int, lst))\nq = deque(lst2)\nres = q.popleft()\nwhile q:\n    temp = q.popleft()\n    if res == 0:\n        res += temp\n    elif temp == 0 or temp == 1:\n        res += temp\n    else:",
        "detail": "2cote.greedy_mulsum",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "2cote.greedy_mulsum",
        "description": "2cote.greedy_mulsum",
        "peekOfCode": "q = deque(lst2)\nres = q.popleft()\nwhile q:\n    temp = q.popleft()\n    if res == 0:\n        res += temp\n    elif temp == 0 or temp == 1:\n        res += temp\n    else:\n        res *= temp",
        "detail": "2cote.greedy_mulsum",
        "documentation": {}
    },
    {
        "label": "res",
        "kind": 5,
        "importPath": "2cote.greedy_mulsum",
        "description": "2cote.greedy_mulsum",
        "peekOfCode": "res = q.popleft()\nwhile q:\n    temp = q.popleft()\n    if res == 0:\n        res += temp\n    elif temp == 0 or temp == 1:\n        res += temp\n    else:\n        res *= temp\nprint(res)",
        "detail": "2cote.greedy_mulsum",
        "documentation": {}
    },
    {
        "label": "eating",
        "kind": 2,
        "importPath": "2cote.greedy_muzieating",
        "description": "2cote.greedy_muzieating",
        "peekOfCode": "def eating(lst, cnt_down, cycle):  # [1, 0, 0]\n    pointer = 0\n    for _ in range(cnt_down):\n        while lst[pointer % cycle] == 0:\n            pointer += 1\n        lst[pointer % cycle] -= 1\n        pointer += 1\n    while lst[pointer % cycle] == 0:\n        pointer += 1\n    return pointer % cycle + 1",
        "detail": "2cote.greedy_muzieating",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "2cote.greedy_muzieating",
        "description": "2cote.greedy_muzieating",
        "peekOfCode": "def solution(food_times, k):  # k=cnt_down\n    if sum(food_times) - k <= 0:\n        return -1\n    cycle = len(food_times)\n    return eating(food_times, k, cycle)",
        "detail": "2cote.greedy_muzieating",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.greed_guild",
        "description": "2cote.greed_guild",
        "peekOfCode": "n = int(input())\nlst = list(map(int, input().split()))\nlst.sort()\nq = deque(lst)\ncnt = 0\n# 2 3 1 2 2 >> 3 2 2 2 1\nwhile q:\n    for _ in range(q[0]):\n        q.popleft()\n        if len(q) == 0:",
        "detail": "2cote.greed_guild",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "2cote.greed_guild",
        "description": "2cote.greed_guild",
        "peekOfCode": "lst = list(map(int, input().split()))\nlst.sort()\nq = deque(lst)\ncnt = 0\n# 2 3 1 2 2 >> 3 2 2 2 1\nwhile q:\n    for _ in range(q[0]):\n        q.popleft()\n        if len(q) == 0:\n            break  # 함수로 만들어서 리턴하면더 깔끔할듯?",
        "detail": "2cote.greed_guild",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "2cote.greed_guild",
        "description": "2cote.greed_guild",
        "peekOfCode": "q = deque(lst)\ncnt = 0\n# 2 3 1 2 2 >> 3 2 2 2 1\nwhile q:\n    for _ in range(q[0]):\n        q.popleft()\n        if len(q) == 0:\n            break  # 함수로 만들어서 리턴하면더 깔끔할듯?\n    if len(q) == 0:\n        break",
        "detail": "2cote.greed_guild",
        "documentation": {}
    },
    {
        "label": "cnt",
        "kind": 5,
        "importPath": "2cote.greed_guild",
        "description": "2cote.greed_guild",
        "peekOfCode": "cnt = 0\n# 2 3 1 2 2 >> 3 2 2 2 1\nwhile q:\n    for _ in range(q[0]):\n        q.popleft()\n        if len(q) == 0:\n            break  # 함수로 만들어서 리턴하면더 깔끔할듯?\n    if len(q) == 0:\n        break\n    cnt += 1",
        "detail": "2cote.greed_guild",
        "documentation": {}
    },
    {
        "label": "icecream",
        "kind": 2,
        "importPath": "2cote.iced_drink",
        "description": "2cote.iced_drink",
        "peekOfCode": "def icecream(iced):\n    cnt = 0\n    def dfs(row, col):\n        if iced[row][col] == 1:\n            return\n        iced[row][col] = 1\n        for i in range(4):  # 상하좌우 가야됨\n            nr = row + dr[i]\n            nc = col + dc[i]\n            if nr < 0 or nc < 0 or nr >= 4 or nc >= 5:  # 멈춰",
        "detail": "2cote.iced_drink",
        "documentation": {}
    },
    {
        "label": "iced",
        "kind": 5,
        "importPath": "2cote.iced_drink",
        "description": "2cote.iced_drink",
        "peekOfCode": "iced = [[0, 1, 0, 1, 0],\n        [0, 1, 1, 0, 1],\n        [1, 0, 1, 0, 1],\n        [0, 1, 0, 1, 0]]\n# 상 하 좌 우\ndr = [-1, 1, 0, 0]\ndc = [0, 0, -1, 1]\n# print(len(iced[0]))\ndef icecream(iced):\n    cnt = 0",
        "detail": "2cote.iced_drink",
        "documentation": {}
    },
    {
        "label": "dr",
        "kind": 5,
        "importPath": "2cote.iced_drink",
        "description": "2cote.iced_drink",
        "peekOfCode": "dr = [-1, 1, 0, 0]\ndc = [0, 0, -1, 1]\n# print(len(iced[0]))\ndef icecream(iced):\n    cnt = 0\n    def dfs(row, col):\n        if iced[row][col] == 1:\n            return\n        iced[row][col] = 1\n        for i in range(4):  # 상하좌우 가야됨",
        "detail": "2cote.iced_drink",
        "documentation": {}
    },
    {
        "label": "dc",
        "kind": 5,
        "importPath": "2cote.iced_drink",
        "description": "2cote.iced_drink",
        "peekOfCode": "dc = [0, 0, -1, 1]\n# print(len(iced[0]))\ndef icecream(iced):\n    cnt = 0\n    def dfs(row, col):\n        if iced[row][col] == 1:\n            return\n        iced[row][col] = 1\n        for i in range(4):  # 상하좌우 가야됨\n            nr = row + dr[i]",
        "detail": "2cote.iced_drink",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "2cote.mainsubject",
        "description": "2cote.mainsubject",
        "peekOfCode": "input = sys.stdin.readline\nn = int(input())\nlst = []\nfor i in range(n):\n    name, guk, yo, su = input().split()\n    Guk = int(guk)\n    Yo = int(yo)\n    Su = int(su)\n    lst.append([name, Guk, Yo, Su])\nlst.sort(key=lambda x: (-x[1], x[2], -x[3], x[0]))  # 무친 덱압축 -x[1] 이거 str 에러 때문에 구글링 하다가 찾음",
        "detail": "2cote.mainsubject",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.mainsubject",
        "description": "2cote.mainsubject",
        "peekOfCode": "n = int(input())\nlst = []\nfor i in range(n):\n    name, guk, yo, su = input().split()\n    Guk = int(guk)\n    Yo = int(yo)\n    Su = int(su)\n    lst.append([name, Guk, Yo, Su])\nlst.sort(key=lambda x: (-x[1], x[2], -x[3], x[0]))  # 무친 덱압축 -x[1] 이거 str 에러 때문에 구글링 하다가 찾음\nfor i in range(len(lst)):",
        "detail": "2cote.mainsubject",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "2cote.mainsubject",
        "description": "2cote.mainsubject",
        "peekOfCode": "lst = []\nfor i in range(n):\n    name, guk, yo, su = input().split()\n    Guk = int(guk)\n    Yo = int(yo)\n    Su = int(su)\n    lst.append([name, Guk, Yo, Su])\nlst.sort(key=lambda x: (-x[1], x[2], -x[3], x[0]))  # 무친 덱압축 -x[1] 이거 str 에러 때문에 구글링 하다가 찾음\nfor i in range(len(lst)):\n    print(lst[i][0])",
        "detail": "2cote.mainsubject",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.make_ddeok",
        "description": "2cote.make_ddeok",
        "peekOfCode": "n = 8\nm = 9\nlst = [10, 4, 7, 6, 2, 3, 5, 5]\nlst.sort()\n# 이진탐색이니까 가운데부터 드가자\ncut = lst[n // 2]\nprint('초기 cut: ', cut)\nwhile True:\n    target = []\n    print('target ini: ',target)",
        "detail": "2cote.make_ddeok",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "2cote.make_ddeok",
        "description": "2cote.make_ddeok",
        "peekOfCode": "m = 9\nlst = [10, 4, 7, 6, 2, 3, 5, 5]\nlst.sort()\n# 이진탐색이니까 가운데부터 드가자\ncut = lst[n // 2]\nprint('초기 cut: ', cut)\nwhile True:\n    target = []\n    print('target ini: ',target)\n    sum_cut = 0",
        "detail": "2cote.make_ddeok",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "2cote.make_ddeok",
        "description": "2cote.make_ddeok",
        "peekOfCode": "lst = [10, 4, 7, 6, 2, 3, 5, 5]\nlst.sort()\n# 이진탐색이니까 가운데부터 드가자\ncut = lst[n // 2]\nprint('초기 cut: ', cut)\nwhile True:\n    target = []\n    print('target ini: ',target)\n    sum_cut = 0\n    for i in lst:",
        "detail": "2cote.make_ddeok",
        "documentation": {}
    },
    {
        "label": "cut",
        "kind": 5,
        "importPath": "2cote.make_ddeok",
        "description": "2cote.make_ddeok",
        "peekOfCode": "cut = lst[n // 2]\nprint('초기 cut: ', cut)\nwhile True:\n    target = []\n    print('target ini: ',target)\n    sum_cut = 0\n    for i in lst:\n        if i > cut:\n            target.append(i)\n    print('target appended: ',target)",
        "detail": "2cote.make_ddeok",
        "documentation": {}
    },
    {
        "label": "rotated",
        "kind": 2,
        "importPath": "2cote.make_key_lock",
        "description": "2cote.make_key_lock",
        "peekOfCode": "def rotated(key):  # 90도 회전하기\n    row = len(key)  # row\n    col = len(key[0])  # col\n    result = [[0] * row for _ in range(col)]\n    for i in range(row):\n        for j in range(col):\n            result[j][row - i - 1] = key[i][j]\n    return result\ndef search(key, lock, start_row, start_col):\n    length = (2 * len(key)) + len(lock)  # 확장시킬 한 변의 길이",
        "detail": "2cote.make_key_lock",
        "documentation": {}
    },
    {
        "label": "search",
        "kind": 2,
        "importPath": "2cote.make_key_lock",
        "description": "2cote.make_key_lock",
        "peekOfCode": "def search(key, lock, start_row, start_col):\n    length = (2 * len(key)) + len(lock)  # 확장시킬 한 변의 길이\n    background = [[0] * length for _ in range(length)]  # 확장시킨 2차원 배열\n    end = len(key) + len(lock)\n    for row in range(len(key)):\n        for col in range(len(key[0])):\n            background[row + start_row][col + start_col] = key[row][col]\n    for row in range(len(key), end):\n        for col in range(len(key), end):\n            background[row][col] += lock[row - len(key)][col - len(key)]",
        "detail": "2cote.make_key_lock",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "2cote.make_key_lock",
        "description": "2cote.make_key_lock",
        "peekOfCode": "def solution(key, lock):\n    end = len(key) + len(lock)\n    for k in range(4):\n        for row in range(end):\n            for col in range(end):\n                start_row = row\n                start_col = col\n                if search(key, lock, start_row, start_col) == True:\n                    return True\n        key = rotated(key)",
        "detail": "2cote.make_key_lock",
        "documentation": {}
    },
    {
        "label": "rotate_a_matrix_by_90_degree",
        "kind": 2,
        "importPath": "2cote.make_key_lock",
        "description": "2cote.make_key_lock",
        "peekOfCode": "def rotate_a_matrix_by_90_degree(a):\n    n = len(a) # 행 길이 계산\n    m = len(a[0]) # 열 길이 계산\n    result = [[0] * n for _ in range(m)] # 결과 리스트\n    for i in range(n):\n        for j in range(m):\n            result[j][n - i - 1] = a[i][j]\n    return result\n# 자물쇠의 중간 부분이 모두 1인지 확인\ndef check(new_lock):",
        "detail": "2cote.make_key_lock",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "2cote.make_key_lock",
        "description": "2cote.make_key_lock",
        "peekOfCode": "def check(new_lock):\n    lock_length = len(new_lock) // 3\n    for i in range(lock_length, lock_length * 2):\n        for j in range(lock_length, lock_length * 2):\n            if new_lock[i][j] != 1:\n                return False\n    return True\ndef solution(key, lock):\n    n = len(lock)\n    m = len(key)",
        "detail": "2cote.make_key_lock",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "2cote.make_key_lock",
        "description": "2cote.make_key_lock",
        "peekOfCode": "def solution(key, lock):\n    n = len(lock)\n    m = len(key)\n    # 자물쇠의 크기를 기존의 3배로 변환\n    new_lock = [[0] * (n * 3) for _ in range(n * 3)]\n    # 새로운 자물쇠의 중앙 부분에 기존의 자물쇠 넣기\n    for i in range(n):\n        for j in range(n):\n            new_lock[i + n][j + n] = lock[i][j]\n    # 4가지 방향에 대해서 확인",
        "detail": "2cote.make_key_lock",
        "documentation": {}
    },
    {
        "label": "rotate",
        "kind": 2,
        "importPath": "2cote.make_key_lock2",
        "description": "2cote.make_key_lock2",
        "peekOfCode": "def rotate(key):\n    row = len(key)  # row\n    col = len(key[0])  # col\n    # result = [[0] * col] * row\n    result = [[0] * row for _ in range(col)]\n    for i in range(row):  # row ,col\n        for j in range(col):\n            result[j][row - j - 1] = key[i][j]  # 여긴걍 외워야할듯?\n    return result\ndef check(answer):  # 아다리 들어 맞는지 확인하기",
        "detail": "2cote.make_key_lock2",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "2cote.make_key_lock2",
        "description": "2cote.make_key_lock2",
        "peekOfCode": "def check(answer):  # 아다리 들어 맞는지 확인하기\n    lockLength = len(answer) // 3\n    for i in range(lockLength, lockLength * 2):\n        for j in range(lockLength, lockLength * 2):\n            if answer[i][j] != 1:\n                return False\n    return True\ndef solution(key, lock):\n    n = len(lock)\n    m = len(key)",
        "detail": "2cote.make_key_lock2",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "2cote.make_key_lock2",
        "description": "2cote.make_key_lock2",
        "peekOfCode": "def solution(key, lock):\n    n = len(lock)\n    m = len(key)\n    # answer = [[0] * (n * 3)] * (n * 3)  # 맵을 *3으로 늘려놓고 돌리자\n    answer = [[0] * (n * 3) for _ in range(n * 3)]\n    for i in range(n):\n        for j in range(n):\n            answer[i + n][j + n] = lock[i][j]\n    for _ in range(4):\n        key = rotate(key)",
        "detail": "2cote.make_key_lock2",
        "documentation": {}
    },
    {
        "label": "lock",
        "kind": 5,
        "importPath": "2cote.make_key_lock2",
        "description": "2cote.make_key_lock2",
        "peekOfCode": "lock = [[0, 0, 1], [0, 0, 2], [0, 0, 3]]\nkey = [[0, 0, 1], [0, 0, 2], [0, 0, 3]]\nprint(rotate(key))",
        "detail": "2cote.make_key_lock2",
        "documentation": {}
    },
    {
        "label": "key",
        "kind": 5,
        "importPath": "2cote.make_key_lock2",
        "description": "2cote.make_key_lock2",
        "peekOfCode": "key = [[0, 0, 1], [0, 0, 2], [0, 0, 3]]\nprint(rotate(key))",
        "detail": "2cote.make_key_lock2",
        "documentation": {}
    },
    {
        "label": "inputt",
        "kind": 5,
        "importPath": "2cote.make_lucky",
        "description": "2cote.make_lucky",
        "peekOfCode": "inputt = sys.stdin.readline\nn = inputt()\nlength = (len(n) - 1) // 2\nn = int(n)\nfront = list(str(n // (10 ** length)))\nback = list(str(n % (10 ** length)))\nsumf = 0\nsumb = 0\nfor i in range(len(front)):\n    sumf += int(front[i])",
        "detail": "2cote.make_lucky",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.make_lucky",
        "description": "2cote.make_lucky",
        "peekOfCode": "n = inputt()\nlength = (len(n) - 1) // 2\nn = int(n)\nfront = list(str(n // (10 ** length)))\nback = list(str(n % (10 ** length)))\nsumf = 0\nsumb = 0\nfor i in range(len(front)):\n    sumf += int(front[i])\n    sumb += int(back[i])",
        "detail": "2cote.make_lucky",
        "documentation": {}
    },
    {
        "label": "length",
        "kind": 5,
        "importPath": "2cote.make_lucky",
        "description": "2cote.make_lucky",
        "peekOfCode": "length = (len(n) - 1) // 2\nn = int(n)\nfront = list(str(n // (10 ** length)))\nback = list(str(n % (10 ** length)))\nsumf = 0\nsumb = 0\nfor i in range(len(front)):\n    sumf += int(front[i])\n    sumb += int(back[i])\nif sumf == sumb:",
        "detail": "2cote.make_lucky",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.make_lucky",
        "description": "2cote.make_lucky",
        "peekOfCode": "n = int(n)\nfront = list(str(n // (10 ** length)))\nback = list(str(n % (10 ** length)))\nsumf = 0\nsumb = 0\nfor i in range(len(front)):\n    sumf += int(front[i])\n    sumb += int(back[i])\nif sumf == sumb:\n    print('LUCKY')",
        "detail": "2cote.make_lucky",
        "documentation": {}
    },
    {
        "label": "front",
        "kind": 5,
        "importPath": "2cote.make_lucky",
        "description": "2cote.make_lucky",
        "peekOfCode": "front = list(str(n // (10 ** length)))\nback = list(str(n % (10 ** length)))\nsumf = 0\nsumb = 0\nfor i in range(len(front)):\n    sumf += int(front[i])\n    sumb += int(back[i])\nif sumf == sumb:\n    print('LUCKY')\nelse:",
        "detail": "2cote.make_lucky",
        "documentation": {}
    },
    {
        "label": "back",
        "kind": 5,
        "importPath": "2cote.make_lucky",
        "description": "2cote.make_lucky",
        "peekOfCode": "back = list(str(n % (10 ** length)))\nsumf = 0\nsumb = 0\nfor i in range(len(front)):\n    sumf += int(front[i])\n    sumb += int(back[i])\nif sumf == sumb:\n    print('LUCKY')\nelse:\n    print('READY')",
        "detail": "2cote.make_lucky",
        "documentation": {}
    },
    {
        "label": "sumf",
        "kind": 5,
        "importPath": "2cote.make_lucky",
        "description": "2cote.make_lucky",
        "peekOfCode": "sumf = 0\nsumb = 0\nfor i in range(len(front)):\n    sumf += int(front[i])\n    sumb += int(back[i])\nif sumf == sumb:\n    print('LUCKY')\nelse:\n    print('READY')",
        "detail": "2cote.make_lucky",
        "documentation": {}
    },
    {
        "label": "sumb",
        "kind": 5,
        "importPath": "2cote.make_lucky",
        "description": "2cote.make_lucky",
        "peekOfCode": "sumb = 0\nfor i in range(len(front)):\n    sumf += int(front[i])\n    sumb += int(back[i])\nif sumf == sumb:\n    print('LUCKY')\nelse:\n    print('READY')",
        "detail": "2cote.make_lucky",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.make_resortStr",
        "description": "2cote.make_resortStr",
        "peekOfCode": "n = input()\nlst = list(n)\nlst2 = list(n)\ntemp = 0\nprint(lst)\nfor i in lst:\n    if 58 >= ord(i) >= 48:\n        temp += int(i)\n        lst2.remove(i)\nlst2.sort()",
        "detail": "2cote.make_resortStr",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "2cote.make_resortStr",
        "description": "2cote.make_resortStr",
        "peekOfCode": "lst = list(n)\nlst2 = list(n)\ntemp = 0\nprint(lst)\nfor i in lst:\n    if 58 >= ord(i) >= 48:\n        temp += int(i)\n        lst2.remove(i)\nlst2.sort()\nresult = ''.join(i for i in lst2)",
        "detail": "2cote.make_resortStr",
        "documentation": {}
    },
    {
        "label": "lst2",
        "kind": 5,
        "importPath": "2cote.make_resortStr",
        "description": "2cote.make_resortStr",
        "peekOfCode": "lst2 = list(n)\ntemp = 0\nprint(lst)\nfor i in lst:\n    if 58 >= ord(i) >= 48:\n        temp += int(i)\n        lst2.remove(i)\nlst2.sort()\nresult = ''.join(i for i in lst2)\nprint(result + str(temp))",
        "detail": "2cote.make_resortStr",
        "documentation": {}
    },
    {
        "label": "temp",
        "kind": 5,
        "importPath": "2cote.make_resortStr",
        "description": "2cote.make_resortStr",
        "peekOfCode": "temp = 0\nprint(lst)\nfor i in lst:\n    if 58 >= ord(i) >= 48:\n        temp += int(i)\n        lst2.remove(i)\nlst2.sort()\nresult = ''.join(i for i in lst2)\nprint(result + str(temp))\n# K1KA5CB7",
        "detail": "2cote.make_resortStr",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "2cote.make_resortStr",
        "description": "2cote.make_resortStr",
        "peekOfCode": "result = ''.join(i for i in lst2)\nprint(result + str(temp))\n# K1KA5CB7\n# AJKDLSI412K4JSJ9D",
        "detail": "2cote.make_resortStr",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "2cote.make_zipstring",
        "description": "2cote.make_zipstring",
        "peekOfCode": "def solution(s):\n    if len(s) == 1:\n        return 1\n    def slicing(q, cnt, temp):\n        if len(q) <= 1:  # 종료조건\n            if cnt > 1:  # 마지막에 연속된 문자가 있을경우 예외처리\n                head = str(cnt)\n                temp += head + q[0]\n            else:\n                temp += q[0]",
        "detail": "2cote.make_zipstring",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "2cote.make_zipstring",
        "description": "2cote.make_zipstring",
        "peekOfCode": "s = 'aabbsdsasd'\nprint(solution(s))\n# from collections import deque\n# import math\n# import sys\n# sys.setrecursionlimit(100000)\n# def solution(s):\n#     def slicing(q, cnt, temp):\n#         if len(q) <= 1:\n#             if cnt>1:",
        "detail": "2cote.make_zipstring",
        "documentation": {}
    },
    {
        "label": "s1",
        "kind": 5,
        "importPath": "2cote.make_zipString2",
        "description": "2cote.make_zipString2",
        "peekOfCode": "s1 = input()\nresult = []\ns = '12312312312312'\ncnt = 1\nfor length in range(1, len(s) // 2):\n    lst = [s[i:i + length] for i in range(0, len(s), length)]\n    print(lst)\n    q = deque(lst)\n    while len(q) > 1:\n        if q[0] == q[1]:",
        "detail": "2cote.make_zipString2",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "2cote.make_zipString2",
        "description": "2cote.make_zipString2",
        "peekOfCode": "result = []\ns = '12312312312312'\ncnt = 1\nfor length in range(1, len(s) // 2):\n    lst = [s[i:i + length] for i in range(0, len(s), length)]\n    print(lst)\n    q = deque(lst)\n    while len(q) > 1:\n        if q[0] == q[1]:\n            cnt += 1",
        "detail": "2cote.make_zipString2",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "2cote.make_zipString2",
        "description": "2cote.make_zipString2",
        "peekOfCode": "s = '12312312312312'\ncnt = 1\nfor length in range(1, len(s) // 2):\n    lst = [s[i:i + length] for i in range(0, len(s), length)]\n    print(lst)\n    q = deque(lst)\n    while len(q) > 1:\n        if q[0] == q[1]:\n            cnt += 1\n            q.popleft()",
        "detail": "2cote.make_zipString2",
        "documentation": {}
    },
    {
        "label": "cnt",
        "kind": 5,
        "importPath": "2cote.make_zipString2",
        "description": "2cote.make_zipString2",
        "peekOfCode": "cnt = 1\nfor length in range(1, len(s) // 2):\n    lst = [s[i:i + length] for i in range(0, len(s), length)]\n    print(lst)\n    q = deque(lst)\n    while len(q) > 1:\n        if q[0] == q[1]:\n            cnt += 1\n            q.popleft()\n        else:",
        "detail": "2cote.make_zipString2",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "2cote.num_card",
        "description": "2cote.num_card",
        "peekOfCode": "arr = []\nsmall_num = []\nfor i in range(n):\n    arr.append(list(map(int, input().split())))\n# 조건2) 뽑고자 하는 행을 설정하기\nfor i in range(n):\n    small_num.append(min(arr[i]))  # >> 행에서 가장 작은 값을 small num list에 넣기\n    print(i, '행의 min값', small_num[i])\nchoice = small_num.index(max(small_num))  # >> small인 값중에 가장 큰값을 구하고 그 index 넘버를 구하기\nprint(choice,'행을 고른다. output= ',max(small_num)) #>># 조건3) 뽑고자 하는 행에서 가장 작은 숫자 뽑기",
        "detail": "2cote.num_card",
        "documentation": {}
    },
    {
        "label": "small_num",
        "kind": 5,
        "importPath": "2cote.num_card",
        "description": "2cote.num_card",
        "peekOfCode": "small_num = []\nfor i in range(n):\n    arr.append(list(map(int, input().split())))\n# 조건2) 뽑고자 하는 행을 설정하기\nfor i in range(n):\n    small_num.append(min(arr[i]))  # >> 행에서 가장 작은 값을 small num list에 넣기\n    print(i, '행의 min값', small_num[i])\nchoice = small_num.index(max(small_num))  # >> small인 값중에 가장 큰값을 구하고 그 index 넘버를 구하기\nprint(choice,'행을 고른다. output= ',max(small_num)) #>># 조건3) 뽑고자 하는 행에서 가장 작은 숫자 뽑기",
        "detail": "2cote.num_card",
        "documentation": {}
    },
    {
        "label": "choice",
        "kind": 5,
        "importPath": "2cote.num_card",
        "description": "2cote.num_card",
        "peekOfCode": "choice = small_num.index(max(small_num))  # >> small인 값중에 가장 큰값을 구하고 그 index 넘버를 구하기\nprint(choice,'행을 고른다. output= ',max(small_num)) #>># 조건3) 뽑고자 하는 행에서 가장 작은 숫자 뽑기",
        "detail": "2cote.num_card",
        "documentation": {}
    },
    {
        "label": "dijk",
        "kind": 2,
        "importPath": "2cote.short_futurecity",
        "description": "2cote.short_futurecity",
        "peekOfCode": "def dijk(graph, start, end):\n    N = len(graph)\n    dist = [INF] * N\n    q = []\n    heapq.heappush(q, (0, start))  # 넣을 위치,( 누적비용 , 시작위치) 팝할때 맨 좌측기준으로 팝된다. 누적비용\n    dist[start] = 0\n    while q:\n        acc, pointer = heapq.heappop(q)  # 누적값, 현재노드 위치\n        if dist[pointer] < acc:  # 나의 노드를 기준으로 최솟값이 갱신이 이미 되었다고 볼 수 있다.\n            continue",
        "detail": "2cote.short_futurecity",
        "documentation": {}
    },
    {
        "label": "INF",
        "kind": 5,
        "importPath": "2cote.short_futurecity",
        "description": "2cote.short_futurecity",
        "peekOfCode": "INF = int(1e9)\nn, m = map(int, input().split())  # n = 노드갯수 // m= 간선갯수\ngraph = [[] for i in range(n + 1)]\n# 간선과의 정보 입력받기\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append([b, 1])\n    graph[b].append([a, 1])\nx, k = map(int, input().split())  # x 최종노드 , k 거쳐갈노드\n# x가 최종 도착지, k는 거쳐야할곳 그렇다면 (1,1)>k로 가는 최단거리와 k>x로 가는 최단거리를 더해주면 되겟슴",
        "detail": "2cote.short_futurecity",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "2cote.short_futurecity",
        "description": "2cote.short_futurecity",
        "peekOfCode": "graph = [[] for i in range(n + 1)]\n# 간선과의 정보 입력받기\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append([b, 1])\n    graph[b].append([a, 1])\nx, k = map(int, input().split())  # x 최종노드 , k 거쳐갈노드\n# x가 최종 도착지, k는 거쳐야할곳 그렇다면 (1,1)>k로 가는 최단거리와 k>x로 가는 최단거리를 더해주면 되겟슴\n# 1과 인접한 노드의 길이를 갱신해주고 누적값을 더해가라. # 만약 inf라면 -1을 출력한다.\ndef dijk(graph, start, end):",
        "detail": "2cote.short_futurecity",
        "documentation": {}
    },
    {
        "label": "r1",
        "kind": 5,
        "importPath": "2cote.short_futurecity",
        "description": "2cote.short_futurecity",
        "peekOfCode": "r1 = dijk(graph, 1, k)\nr2 = dijk(graph, k, x)\nprint(r1 + r2)",
        "detail": "2cote.short_futurecity",
        "documentation": {}
    },
    {
        "label": "r2",
        "kind": 5,
        "importPath": "2cote.short_futurecity",
        "description": "2cote.short_futurecity",
        "peekOfCode": "r2 = dijk(graph, k, x)\nprint(r1 + r2)",
        "detail": "2cote.short_futurecity",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "2cote.sort_cardsort",
        "description": "2cote.sort_cardsort",
        "peekOfCode": "input = sys.stdin.readline\nfrom collections import deque\nn = int(input())\nm = []\nfor i in range(n):\n    m.append(int(input()))\nm.sort()\ntemp = 0\nprint(m)\nq = deque(m)",
        "detail": "2cote.sort_cardsort",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.sort_cardsort",
        "description": "2cote.sort_cardsort",
        "peekOfCode": "n = int(input())\nm = []\nfor i in range(n):\n    m.append(int(input()))\nm.sort()\ntemp = 0\nprint(m)\nq = deque(m)\nwhile q:\n    temp += q[0]+q[1]",
        "detail": "2cote.sort_cardsort",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "2cote.sort_cardsort",
        "description": "2cote.sort_cardsort",
        "peekOfCode": "m = []\nfor i in range(n):\n    m.append(int(input()))\nm.sort()\ntemp = 0\nprint(m)\nq = deque(m)\nwhile q:\n    temp += q[0]+q[1]\n    q.popleft()",
        "detail": "2cote.sort_cardsort",
        "documentation": {}
    },
    {
        "label": "temp",
        "kind": 5,
        "importPath": "2cote.sort_cardsort",
        "description": "2cote.sort_cardsort",
        "peekOfCode": "temp = 0\nprint(m)\nq = deque(m)\nwhile q:\n    temp += q[0]+q[1]\n    q.popleft()\n    if q is None:\n        break\n    q.popleft()\n    if q is None:",
        "detail": "2cote.sort_cardsort",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "2cote.sort_cardsort",
        "description": "2cote.sort_cardsort",
        "peekOfCode": "q = deque(m)\nwhile q:\n    temp += q[0]+q[1]\n    q.popleft()\n    if q is None:\n        break\n    q.popleft()\n    if q is None:\n        break\n    res = temp+q[0]",
        "detail": "2cote.sort_cardsort",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "2cote.sort_fail_percentage",
        "description": "2cote.sort_fail_percentage",
        "peekOfCode": "def solution(N, stages):\n    lst = []\n    for i in range(1,N+1):  # stage 수\n        total_cnt = 0\n        cur_cnt = 0\n        for j in stages:    #user 수 돌고\n            if i <= j:          #1\n                total_cnt += 1  #[2, 1, 2, 6, 2, 4, 3, 3]\n                if i == j:\n                    cur_cnt += 1",
        "detail": "2cote.sort_fail_percentage",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "2cote.sort_fail_percentage",
        "description": "2cote.sort_fail_percentage",
        "peekOfCode": "input = sys.stdin.readline\nn = int(input())\nstages = list(map(int, input().split()))\nprint(stages)\n#######이게더심함\n# from collections import Counter\n#\n#\n# def solution(N, stages):\n#     # for i in stages에서 i보다 큰 수라면 i클리어++",
        "detail": "2cote.sort_fail_percentage",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "2cote.sort_fail_percentage",
        "description": "2cote.sort_fail_percentage",
        "peekOfCode": "n = int(input())\nstages = list(map(int, input().split()))\nprint(stages)\n#######이게더심함\n# from collections import Counter\n#\n#\n# def solution(N, stages):\n#     # for i in stages에서 i보다 큰 수라면 i클리어++\n#     # i와 같다면 i실패자++",
        "detail": "2cote.sort_fail_percentage",
        "documentation": {}
    },
    {
        "label": "stages",
        "kind": 5,
        "importPath": "2cote.sort_fail_percentage",
        "description": "2cote.sort_fail_percentage",
        "peekOfCode": "stages = list(map(int, input().split()))\nprint(stages)\n#######이게더심함\n# from collections import Counter\n#\n#\n# def solution(N, stages):\n#     # for i in stages에서 i보다 큰 수라면 i클리어++\n#     # i와 같다면 i실패자++\n#     # i실패자/i클리어 = 실패율",
        "detail": "2cote.sort_fail_percentage",
        "documentation": {}
    },
    {
        "label": "cnt",
        "kind": 5,
        "importPath": "2cote.until_one",
        "description": "2cote.until_one",
        "peekOfCode": "cnt = 0\nwhile n!=1:\n    if n % k == 0:\n        n = n/k\n        cnt +=1\n    else:\n        n = n-1\n        cnt +=1\nprint(cnt)",
        "detail": "2cote.until_one",
        "documentation": {}
    },
    {
        "label": "bfs",
        "kind": 2,
        "importPath": "2cote.virus_search",
        "description": "2cote.virus_search",
        "peekOfCode": "def bfs(answer):\n    # 큐 생성 후 그래프와 동일한 모양의 그래프 카피\n    q = deque()\n    copy_graph = copy.deepcopy(graph)\n    # 그래프 돌면서 바이러스인 좌표를 큐에 넣는다\n    for i in range(n):\n        for j in range(m):\n            if copy_graph[i][j] == 2:\n                q.append((i, j))\n    # 큐가 차있을 때",
        "detail": "2cote.virus_search",
        "documentation": {}
    },
    {
        "label": "makeWall",
        "kind": 2,
        "importPath": "2cote.virus_search",
        "description": "2cote.virus_search",
        "peekOfCode": "def makeWall(cnt):\n        # 벽이 3개 다 세워졌으면\n        if cnt == 3:\n            # bfs 탐색\n            bfs(answer)\n            return\n        # 그래프 돌면서 (0, 0 ~ n-1, m-1)까지 다 돌아야함 (벽 다 쳐봐서 최대값 구해야되니)\n        for i in range(n):\n            for j in range(m):\n                # 그래프 좌표가 0이면(비었으면)",
        "detail": "2cote.virus_search",
        "documentation": {}
    },
    {
        "label": "answer",
        "kind": 5,
        "importPath": "2cote.virus_search",
        "description": "2cote.virus_search",
        "peekOfCode": "answer = 0\n# bfs 탐색\ndef bfs(answer):\n    # 큐 생성 후 그래프와 동일한 모양의 그래프 카피\n    q = deque()\n    copy_graph = copy.deepcopy(graph)\n    # 그래프 돌면서 바이러스인 좌표를 큐에 넣는다\n    for i in range(n):\n        for j in range(m):\n            if copy_graph[i][j] == 2:",
        "detail": "2cote.virus_search",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "2cote.virus_search",
        "description": "2cote.virus_search",
        "peekOfCode": "graph = []\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\nfor i in range(n):\n    graph.append(list(map(int, input().split())))\nmakeWall(0)\nprint(answer)",
        "detail": "2cote.virus_search",
        "documentation": {}
    },
    {
        "label": "dx",
        "kind": 5,
        "importPath": "2cote.virus_search",
        "description": "2cote.virus_search",
        "peekOfCode": "dx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\nfor i in range(n):\n    graph.append(list(map(int, input().split())))\nmakeWall(0)\nprint(answer)",
        "detail": "2cote.virus_search",
        "documentation": {}
    },
    {
        "label": "dy",
        "kind": 5,
        "importPath": "2cote.virus_search",
        "description": "2cote.virus_search",
        "peekOfCode": "dy = [1, -1, 0, 0]\nfor i in range(n):\n    graph.append(list(map(int, input().split())))\nmakeWall(0)\nprint(answer)",
        "detail": "2cote.virus_search",
        "documentation": {}
    },
    {
        "label": "is_prime",
        "kind": 2,
        "importPath": "3amsung_sw.2070",
        "description": "3amsung_sw.2070",
        "peekOfCode": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef generate_complete_graph(n):\n    graph = {i: [] for i in range(1, n + 1)}\n    for i in range(1, n + 1):",
        "detail": "3amsung_sw.2070",
        "documentation": {}
    },
    {
        "label": "generate_complete_graph",
        "kind": 2,
        "importPath": "3amsung_sw.2070",
        "description": "3amsung_sw.2070",
        "peekOfCode": "def generate_complete_graph(n):\n    graph = {i: [] for i in range(1, n + 1)}\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            graph[i].append(j)\n            graph[j].append(i)\n    return graph\ndef get_total_neighbors(graph):\n    return sum(len(neighbors) for neighbors in graph.values())\ndef remove_edges_to_prime_sum(graph):",
        "detail": "3amsung_sw.2070",
        "documentation": {}
    },
    {
        "label": "get_total_neighbors",
        "kind": 2,
        "importPath": "3amsung_sw.2070",
        "description": "3amsung_sw.2070",
        "peekOfCode": "def get_total_neighbors(graph):\n    return sum(len(neighbors) for neighbors in graph.values())\ndef remove_edges_to_prime_sum(graph):\n    count=0\n    final_graph=[]\n    while count < (n*(n-3))//2:\n        removed = False\n        is_all_prime = all(is_prime(len(neighbors)) for neighbors in graph.values())\n        total_neighbors = get_total_neighbors(graph)//2\n        if is_prime(total_neighbors) and is_all_prime:",
        "detail": "3amsung_sw.2070",
        "documentation": {}
    },
    {
        "label": "remove_edges_to_prime_sum",
        "kind": 2,
        "importPath": "3amsung_sw.2070",
        "description": "3amsung_sw.2070",
        "peekOfCode": "def remove_edges_to_prime_sum(graph):\n    count=0\n    final_graph=[]\n    while count < (n*(n-3))//2:\n        removed = False\n        is_all_prime = all(is_prime(len(neighbors)) for neighbors in graph.values())\n        total_neighbors = get_total_neighbors(graph)//2\n        if is_prime(total_neighbors) and is_all_prime:\n            final_graph = {vertex: neighbors[:] for vertex, neighbors in graph.items()}\n            return final_graph",
        "detail": "3amsung_sw.2070",
        "documentation": {}
    },
    {
        "label": "convert_to_undirected_graph",
        "kind": 2,
        "importPath": "3amsung_sw.2070",
        "description": "3amsung_sw.2070",
        "peekOfCode": "def convert_to_undirected_graph(graph):\n    undirected_graph = {}\n    for vertex, neighbors in graph.items():\n        undirected_graph[vertex] = []\n        for neighbor in neighbors:\n            if neighbor > vertex:\n                undirected_graph[vertex].append(neighbor)\n    return undirected_graph\ninput_data = []\nt = int(input())",
        "detail": "3amsung_sw.2070",
        "documentation": {}
    },
    {
        "label": "input_data",
        "kind": 5,
        "importPath": "3amsung_sw.2070",
        "description": "3amsung_sw.2070",
        "peekOfCode": "input_data = []\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    input_data.append(n)\noutput_data = []\nfor n in input_data:\n    complete_graph = generate_complete_graph(n)\n    a = remove_edges_to_prime_sum(complete_graph)\n    b = convert_to_undirected_graph(a)",
        "detail": "3amsung_sw.2070",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "3amsung_sw.2070",
        "description": "3amsung_sw.2070",
        "peekOfCode": "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    input_data.append(n)\noutput_data = []\nfor n in input_data:\n    complete_graph = generate_complete_graph(n)\n    a = remove_edges_to_prime_sum(complete_graph)\n    b = convert_to_undirected_graph(a)\n    c = get_total_neighbors(b)",
        "detail": "3amsung_sw.2070",
        "documentation": {}
    },
    {
        "label": "output_data",
        "kind": 5,
        "importPath": "3amsung_sw.2070",
        "description": "3amsung_sw.2070",
        "peekOfCode": "output_data = []\nfor n in input_data:\n    complete_graph = generate_complete_graph(n)\n    a = remove_edges_to_prime_sum(complete_graph)\n    b = convert_to_undirected_graph(a)\n    c = get_total_neighbors(b)\n    output_data.append((b, c))\nfor b, c in output_data:\n    print(c)\n    for k,v in b.items():",
        "detail": "3amsung_sw.2070",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "6oj.10026",
        "description": "6oj.10026",
        "peekOfCode": "def dfs(graph,visited,size,row,col):\n    # 종료조건 > visited=1\n    if visited[row][col]==1:\n        return\n    visited[row][col]=1\n    dr=[1,-1,0,0]\n    dc=[0,0,1,-1]\n    for i in range(4):\n        next_row = row+dr[i]\n        next_col = col+dc[i]",
        "detail": "6oj.10026",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "6oj.10026",
        "description": "6oj.10026",
        "peekOfCode": "def solution(graph):\n    visited = [[0 for _ in range(len(row))] for row in graph]\n    size=0\n    for row in range(len(graph)):\n        for col in range(len(graph[0])):\n            if visited[row][col]==0:\n                dfs(graph,visited,size,row,col)\n                size+=1\n    return size\nif __name__ == \"__main__\":",
        "detail": "6oj.10026",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "6oj.1012",
        "description": "6oj.1012",
        "peekOfCode": "def dfs(graph, row, col, visited):\n    dr = [1, -1, 0, 0]\n    dc = [0, 0, 1, -1]\n    # 방문하지 않은 배추인 경우에만 탐색\n    if visited[row][col] == 0 and graph[row][col] == 1:\n        visited[row][col] = 1\n        for i in range(4):\n            next_row = row + dr[i]\n            next_col = col + dc[i]\n            if 0 <= next_row < len(graph) and 0 <= next_col < len(graph[0]):",
        "detail": "6oj.1012",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "6oj.1012",
        "description": "6oj.1012",
        "peekOfCode": "def solution(graph):\n    # 그래프 전체를 탐색하면서 배추 덩어리 찾기\n    # 배추가 있고 방문하지 않은 경우에만 DFS 탐색 수행\n    count = 0\n    visited = [[0] * len(graph[0]) for _ in range(len(graph))]\n    for row in range(len(graph)):\n        for col in range(len(graph[0])):\n            if graph[row][col] == 1 and visited[row][col] == 0:\n                dfs(graph, row, col, visited)\n                count += 1",
        "detail": "6oj.1012",
        "documentation": {}
    },
    {
        "label": "backtracking",
        "kind": 2,
        "importPath": "6oj.15663",
        "description": "6oj.15663",
        "peekOfCode": "def backtracking(k):\n    if k == m:\n        print(*result)\n        return\n    remember = 0\n    for i in range(n):\n        if not visited[i] and remember != nums[i] :\n            visited[i] = True\n            result.append(nums[i])\n            remember = nums[i]",
        "detail": "6oj.15663",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "6oj.15663",
        "description": "6oj.15663",
        "peekOfCode": "def dfs(index,m,numbers,temp):\n    # 종료조건 : 할당 개수를 채웠거나, 남아있는 수의 개수가 추가 해야 할 개수보다 적으면 중지\n    if len(temp)==m or sum(numbers)+len(temp)<m or numbers[index]<1:\n        return\n    # 해야할일 : 지금 위치를 temp에 더하고, 리스트의 끝까지 재귀 탐색시키기\n    numbers[index]-=1\n    print(numbers)\n    temp.append(index)\n    for i in range(len(numbers)):\n        dfs(i,m,numbers[:],temp)",
        "detail": "6oj.15663",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "6oj.15663",
        "description": "6oj.15663",
        "peekOfCode": "def solution(m,lst):\n    numbers=[0]*(max(lst)+1)\n    print(max(lst))\n    answer=[]\n    for i in lst:\n        numbers[i]+=1\n    for i in range(len(numbers)):\n        if numbers[i]!=0:\n            temp=[]\n            dfs(i,m,numbers[:],temp)",
        "detail": "6oj.15663",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "6oj.15663",
        "description": "6oj.15663",
        "peekOfCode": "input = sys.stdin.readline\nn, m = map(int, input().split())\nnums = list(map(int, input().split()))\nvisited = [False] * n\nnums.sort()\nresult = []\ndef backtracking(k):\n    if k == m:\n        print(*result)\n        return",
        "detail": "6oj.15663",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "6oj.15663",
        "description": "6oj.15663",
        "peekOfCode": "nums = list(map(int, input().split()))\nvisited = [False] * n\nnums.sort()\nresult = []\ndef backtracking(k):\n    if k == m:\n        print(*result)\n        return\n    remember = 0\n    for i in range(n):",
        "detail": "6oj.15663",
        "documentation": {}
    },
    {
        "label": "visited",
        "kind": 5,
        "importPath": "6oj.15663",
        "description": "6oj.15663",
        "peekOfCode": "visited = [False] * n\nnums.sort()\nresult = []\ndef backtracking(k):\n    if k == m:\n        print(*result)\n        return\n    remember = 0\n    for i in range(n):\n        if not visited[i] and remember != nums[i] :",
        "detail": "6oj.15663",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "6oj.15663",
        "description": "6oj.15663",
        "peekOfCode": "result = []\ndef backtracking(k):\n    if k == m:\n        print(*result)\n        return\n    remember = 0\n    for i in range(n):\n        if not visited[i] and remember != nums[i] :\n            visited[i] = True\n            result.append(nums[i])",
        "detail": "6oj.15663",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "6oj.15663",
        "description": "6oj.15663",
        "peekOfCode": "numbers = list(map(int, input().split()))\n# N, M=4,2\n# numbers=[9,7,9,1]\nfor perm in sorted(set(permutations(numbers, M))):\n    print(*perm)\n# 초안\nimport sys\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\n# 조합의 길이가 m이 될때까지 탐색한다.",
        "detail": "6oj.15663",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "6oj.15663",
        "description": "6oj.15663",
        "peekOfCode": "input = sys.stdin.readline\n# 조합의 길이가 m이 될때까지 탐색한다.\n# 1~8까지의 리스트를 가지고 리스트 전체를 순회하면서 1개씩 찾는다.\n# 제자리부터 ~ 리스트의 끝까지를 탐색한다.\ndef dfs(index,m,numbers,temp):\n    # 종료조건 : 할당 개수를 채웠거나, 남아있는 수의 개수가 추가 해야 할 개수보다 적으면 중지\n    if len(temp)==m or sum(numbers)+len(temp)<m or numbers[index]<1:\n        return\n    # 해야할일 : 지금 위치를 temp에 더하고, 리스트의 끝까지 재귀 탐색시키기\n    numbers[index]-=1",
        "detail": "6oj.15663",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "6oj.15926",
        "description": "6oj.15926",
        "peekOfCode": "s = input()       # 괄호로만 구성된 문자열\nvalid = [0] * 1000  # 올바른 괄호 문자열 여부를 저장하는 배열\nmax_length = 0   # 최대 길이\nstack = []  # 스택 초기화\n# 올바른 괄호 문자열 여부 계산\nfor i in range(len(s)):\n    if s[i] == '(':\n        stack.append(i)\n    else:\n        if stack:",
        "detail": "6oj.15926",
        "documentation": {}
    },
    {
        "label": "valid",
        "kind": 5,
        "importPath": "6oj.15926",
        "description": "6oj.15926",
        "peekOfCode": "valid = [0] * 1000  # 올바른 괄호 문자열 여부를 저장하는 배열\nmax_length = 0   # 최대 길이\nstack = []  # 스택 초기화\n# 올바른 괄호 문자열 여부 계산\nfor i in range(len(s)):\n    if s[i] == '(':\n        stack.append(i)\n    else:\n        if stack:\n            valid[i] = valid[stack[-1]] = 1",
        "detail": "6oj.15926",
        "documentation": {}
    },
    {
        "label": "max_length",
        "kind": 5,
        "importPath": "6oj.15926",
        "description": "6oj.15926",
        "peekOfCode": "max_length = 0   # 최대 길이\nstack = []  # 스택 초기화\n# 올바른 괄호 문자열 여부 계산\nfor i in range(len(s)):\n    if s[i] == '(':\n        stack.append(i)\n    else:\n        if stack:\n            valid[i] = valid[stack[-1]] = 1\n            stack.pop()",
        "detail": "6oj.15926",
        "documentation": {}
    },
    {
        "label": "stack",
        "kind": 5,
        "importPath": "6oj.15926",
        "description": "6oj.15926",
        "peekOfCode": "stack = []  # 스택 초기화\n# 올바른 괄호 문자열 여부 계산\nfor i in range(len(s)):\n    if s[i] == '(':\n        stack.append(i)\n    else:\n        if stack:\n            valid[i] = valid[stack[-1]] = 1\n            stack.pop()\n# 최대 길이 계산",
        "detail": "6oj.15926",
        "documentation": {}
    },
    {
        "label": "current_length",
        "kind": 5,
        "importPath": "6oj.15926",
        "description": "6oj.15926",
        "peekOfCode": "current_length = 0  # 현재 길이\nfor i in range(len(s)):\n    if valid[i]:\n        current_length += 1\n        max_length = max(max_length, current_length)\n    else:\n        current_length = 0\nprint(max_length)",
        "detail": "6oj.15926",
        "documentation": {}
    },
    {
        "label": "solution2",
        "kind": 2,
        "importPath": "6oj.18406",
        "description": "6oj.18406",
        "peekOfCode": "def solution2(n):\n    # 이진수로 변환 > str으로 변환 > 1의 개수 세기\n    # > n보다 작은 수 1의 개수 > n과 1의 개수가 같은 경우의 수 출력\n    cnt = 0\n    answer = 0\n    ntoBin = format(n, 'b')\n    nToList = list(ntoBin)\n    temp = 0\n    print(ntoBin)\n    for x in ntoBin:",
        "detail": "6oj.18406",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "6oj.18406",
        "description": "6oj.18406",
        "peekOfCode": "def solution(phone_number):\n    # 유형 1의 경우 010으로 시작하며 -4자리-4자리 숫자 존재한다.\n    # 유형 2의 경우 010으로 시작하며 8자리 숫자 존재한다.\n    # 유형 3의 경우 +82-10-4자리-4자리 숫자 존재한다.\n    answer = 1\n    return answer",
        "detail": "6oj.18406",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "6oj.18406",
        "description": "6oj.18406",
        "peekOfCode": "n = 17\ndef solution2(n):\n    # 이진수로 변환 > str으로 변환 > 1의 개수 세기\n    # > n보다 작은 수 1의 개수 > n과 1의 개수가 같은 경우의 수 출력\n    cnt = 0\n    answer = 0\n    ntoBin = format(n, 'b')\n    nToList = list(ntoBin)\n    temp = 0\n    print(ntoBin)",
        "detail": "6oj.18406",
        "documentation": {}
    },
    {
        "label": "phone_number",
        "kind": 5,
        "importPath": "6oj.18406",
        "description": "6oj.18406",
        "peekOfCode": "phone_number = '01012345678'\nphone_number2 = '010-1234-5678'\nphone_number3 = '+82-10-1234-5678'\ndef solution(phone_number):\n    # 유형 1의 경우 010으로 시작하며 -4자리-4자리 숫자 존재한다.\n    # 유형 2의 경우 010으로 시작하며 8자리 숫자 존재한다.\n    # 유형 3의 경우 +82-10-4자리-4자리 숫자 존재한다.\n    answer = 1\n    return answer",
        "detail": "6oj.18406",
        "documentation": {}
    },
    {
        "label": "phone_number2",
        "kind": 5,
        "importPath": "6oj.18406",
        "description": "6oj.18406",
        "peekOfCode": "phone_number2 = '010-1234-5678'\nphone_number3 = '+82-10-1234-5678'\ndef solution(phone_number):\n    # 유형 1의 경우 010으로 시작하며 -4자리-4자리 숫자 존재한다.\n    # 유형 2의 경우 010으로 시작하며 8자리 숫자 존재한다.\n    # 유형 3의 경우 +82-10-4자리-4자리 숫자 존재한다.\n    answer = 1\n    return answer",
        "detail": "6oj.18406",
        "documentation": {}
    },
    {
        "label": "phone_number3",
        "kind": 5,
        "importPath": "6oj.18406",
        "description": "6oj.18406",
        "peekOfCode": "phone_number3 = '+82-10-1234-5678'\ndef solution(phone_number):\n    # 유형 1의 경우 010으로 시작하며 -4자리-4자리 숫자 존재한다.\n    # 유형 2의 경우 010으로 시작하며 8자리 숫자 존재한다.\n    # 유형 3의 경우 +82-10-4자리-4자리 숫자 존재한다.\n    answer = 1\n    return answer",
        "detail": "6oj.18406",
        "documentation": {}
    },
    {
        "label": "bfs",
        "kind": 2,
        "importPath": "6oj.1926",
        "description": "6oj.1926",
        "peekOfCode": "def bfs(row, col, visited, graph):\n    stack = [(row, col)]\n    area = 0\n    while stack:\n        r, c = stack.pop()\n        if visited[r][c] == 1:\n            continue\n        visited[r][c] = 1\n        area += 1\n        dr = [1, -1, 0, 0]",
        "detail": "6oj.1926",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "6oj.1926",
        "description": "6oj.1926",
        "peekOfCode": "def dfs(row,col,visited,graph,area):\n    # 종료조건 > visited 일때?\n    if visited[row][col]==1:\n        return 0\n    # do something\n    visited[row][col]=1\n    area+=1\n    # dfs seacrch\n    dr=[1,-1,0,0]\n    dc=[0,0,1,-1]",
        "detail": "6oj.1926",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "6oj.1926",
        "description": "6oj.1926",
        "peekOfCode": "input = sys.stdin.readline\n## bfs dp 방식\ndef bfs(row, col, visited, graph):\n    stack = [(row, col)]\n    area = 0\n    while stack:\n        r, c = stack.pop()\n        if visited[r][c] == 1:\n            continue\n        visited[r][c] = 1",
        "detail": "6oj.1926",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "6oj.1926",
        "description": "6oj.1926",
        "peekOfCode": "input = sys.stdin.readline\ndef dfs(row,col,visited,graph,area):\n    # 종료조건 > visited 일때?\n    if visited[row][col]==1:\n        return 0\n    # do something\n    visited[row][col]=1\n    area+=1\n    # dfs seacrch\n    dr=[1,-1,0,0]",
        "detail": "6oj.1926",
        "documentation": {}
    },
    {
        "label": "find_max_budget",
        "kind": 2,
        "importPath": "6oj.2512",
        "description": "6oj.2512",
        "peekOfCode": "def find_max_budget(lst, budget):\n    start = 0\n    end = max(lst)\n    result = 0\n    while start <= end:\n        mid = (start + end) // 2\n        total = 0\n        for req in lst:\n            total += min(req, mid)\n        if total <= budget:",
        "detail": "6oj.2512",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "6oj.2512",
        "description": "6oj.2512",
        "peekOfCode": "input = sys.stdin.readline\nn=int(input())\nlst=list(map(int, input().strip().split()))\nburget=int(input())\nlst.sort()\nif burget >= sum(lst):\n    print(max(lst))\nelse:\n    val=burget//len(lst)\n    remain=0",
        "detail": "6oj.2512",
        "documentation": {}
    },
    {
        "label": "permu",
        "kind": 2,
        "importPath": "6oj.backtracking_15649",
        "description": "6oj.backtracking_15649",
        "peekOfCode": "def permu(level):\n    # 종료조건\n    if level >= m:  # level==m이라고 해도 되지만 일반적으로 크게해주는게 좋다.\n        for i in range(len(arr)):\n            arr[i]=str(arr[i])\n        result=' '.join(arr)\n        print(result)\n        return\n    for i in range(n):\n        if visited[i]==1:",
        "detail": "6oj.backtracking_15649",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "6oj.backtracking_15649",
        "description": "6oj.backtracking_15649",
        "peekOfCode": "n = len(num)\nvisited = [0] * n\narr = [0] * m\n# result=[]\ndef permu(level):\n    # 종료조건\n    if level >= m:  # level==m이라고 해도 되지만 일반적으로 크게해주는게 좋다.\n        for i in range(len(arr)):\n            arr[i]=str(arr[i])\n        result=' '.join(arr)",
        "detail": "6oj.backtracking_15649",
        "documentation": {}
    },
    {
        "label": "visited",
        "kind": 5,
        "importPath": "6oj.backtracking_15649",
        "description": "6oj.backtracking_15649",
        "peekOfCode": "visited = [0] * n\narr = [0] * m\n# result=[]\ndef permu(level):\n    # 종료조건\n    if level >= m:  # level==m이라고 해도 되지만 일반적으로 크게해주는게 좋다.\n        for i in range(len(arr)):\n            arr[i]=str(arr[i])\n        result=' '.join(arr)\n        print(result)",
        "detail": "6oj.backtracking_15649",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "6oj.backtracking_15649",
        "description": "6oj.backtracking_15649",
        "peekOfCode": "arr = [0] * m\n# result=[]\ndef permu(level):\n    # 종료조건\n    if level >= m:  # level==m이라고 해도 되지만 일반적으로 크게해주는게 좋다.\n        for i in range(len(arr)):\n            arr[i]=str(arr[i])\n        result=' '.join(arr)\n        print(result)\n        return",
        "detail": "6oj.backtracking_15649",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "6oj.d_bfs_16234_peoplemove",
        "description": "6oj.d_bfs_16234_peoplemove",
        "peekOfCode": "def check(value, input, x, y):  # 인구 이동 조건 확인\n    if (input >= l) and (input <= r):\n        value.append((x, y))\ndef border(i, j):\n    value = []\n    if i - 1 >= 0:\n        top = abs(popularity[i - 1][j] - popularity[i][j])\n        check(value, top, i - 1, j)\n    if i + 1 < n:\n        bottom = abs(popularity[i + 1][j] - popularity[i][j])",
        "detail": "6oj.d_bfs_16234_peoplemove",
        "documentation": {}
    },
    {
        "label": "border",
        "kind": 2,
        "importPath": "6oj.d_bfs_16234_peoplemove",
        "description": "6oj.d_bfs_16234_peoplemove",
        "peekOfCode": "def border(i, j):\n    value = []\n    if i - 1 >= 0:\n        top = abs(popularity[i - 1][j] - popularity[i][j])\n        check(value, top, i - 1, j)\n    if i + 1 < n:\n        bottom = abs(popularity[i + 1][j] - popularity[i][j])\n        check(value, bottom, i + 1, j)\n    if j - 1 >= 0:\n        left = abs(popularity[i][j - 1] - popularity[i][j])",
        "detail": "6oj.d_bfs_16234_peoplemove",
        "documentation": {}
    },
    {
        "label": "bfs",
        "kind": 2,
        "importPath": "6oj.d_bfs_16234_peoplemove",
        "description": "6oj.d_bfs_16234_peoplemove",
        "peekOfCode": "def bfs(start):\n    visit = list()\n    queue = deque()\n    queue.append(start)\n    while queue:\n        enqueue = queue.popleft()\n        if enqueue not in visit:\n            visit.append(enqueue)\n            queue.extend(graph[enqueue])\n    return visit",
        "detail": "6oj.d_bfs_16234_peoplemove",
        "documentation": {}
    },
    {
        "label": "popularity",
        "kind": 5,
        "importPath": "6oj.d_bfs_16234_peoplemove",
        "description": "6oj.d_bfs_16234_peoplemove",
        "peekOfCode": "popularity = [list(map(int, input().split())) for _ in range(n)]\nday = 0\ngraph = dict()\ndef check(value, input, x, y):  # 인구 이동 조건 확인\n    if (input >= l) and (input <= r):\n        value.append((x, y))\ndef border(i, j):\n    value = []\n    if i - 1 >= 0:\n        top = abs(popularity[i - 1][j] - popularity[i][j])",
        "detail": "6oj.d_bfs_16234_peoplemove",
        "documentation": {}
    },
    {
        "label": "day",
        "kind": 5,
        "importPath": "6oj.d_bfs_16234_peoplemove",
        "description": "6oj.d_bfs_16234_peoplemove",
        "peekOfCode": "day = 0\ngraph = dict()\ndef check(value, input, x, y):  # 인구 이동 조건 확인\n    if (input >= l) and (input <= r):\n        value.append((x, y))\ndef border(i, j):\n    value = []\n    if i - 1 >= 0:\n        top = abs(popularity[i - 1][j] - popularity[i][j])\n        check(value, top, i - 1, j)",
        "detail": "6oj.d_bfs_16234_peoplemove",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "6oj.d_bfs_16234_peoplemove",
        "description": "6oj.d_bfs_16234_peoplemove",
        "peekOfCode": "graph = dict()\ndef check(value, input, x, y):  # 인구 이동 조건 확인\n    if (input >= l) and (input <= r):\n        value.append((x, y))\ndef border(i, j):\n    value = []\n    if i - 1 >= 0:\n        top = abs(popularity[i - 1][j] - popularity[i][j])\n        check(value, top, i - 1, j)\n    if i + 1 < n:",
        "detail": "6oj.d_bfs_16234_peoplemove",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "6oj.facto_3964",
        "description": "6oj.facto_3964",
        "peekOfCode": "input = sys.stdin.readline\nt = int(input())\nlst = []\nfor _ in range(t):\n    lst.append(list(map(int, input().split())))\nfor leg in range(len(lst)):\n    temp = 1\n    n_fac = 1\n    for i in range(1, lst[leg][0] + 1):  # n! 구하기  #lst[leg][0] = n , lst[leg][1] = k\n        n_fac *= i",
        "detail": "6oj.facto_3964",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "6oj.facto_3964",
        "description": "6oj.facto_3964",
        "peekOfCode": "t = int(input())\nlst = []\nfor _ in range(t):\n    lst.append(list(map(int, input().split())))\nfor leg in range(len(lst)):\n    temp = 1\n    n_fac = 1\n    for i in range(1, lst[leg][0] + 1):  # n! 구하기  #lst[leg][0] = n , lst[leg][1] = k\n        n_fac *= i\n    for j in range(1, lst[leg][0] + 1):  # j = 1 2 3 4 5",
        "detail": "6oj.facto_3964",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "6oj.facto_3964",
        "description": "6oj.facto_3964",
        "peekOfCode": "lst = []\nfor _ in range(t):\n    lst.append(list(map(int, input().split())))\nfor leg in range(len(lst)):\n    temp = 1\n    n_fac = 1\n    for i in range(1, lst[leg][0] + 1):  # n! 구하기  #lst[leg][0] = n , lst[leg][1] = k\n        n_fac *= i\n    for j in range(1, lst[leg][0] + 1):  # j = 1 2 3 4 5\n        if n_fac % lst[leg][1] != 0:",
        "detail": "6oj.facto_3964",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "6oj.heap_1927",
        "description": "6oj.heap_1927",
        "peekOfCode": "n = int(sys.stdin.readline())\nx = []\nfor i in range(n):\n    s = int(sys.stdin.readline())\n    x.append(s)\nheap=[]\nfor i in x:\n    if i!=0:\n        heapq.heappush(heap,i)\n    else:",
        "detail": "6oj.heap_1927",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "6oj.heap_1927",
        "description": "6oj.heap_1927",
        "peekOfCode": "x = []\nfor i in range(n):\n    s = int(sys.stdin.readline())\n    x.append(s)\nheap=[]\nfor i in x:\n    if i!=0:\n        heapq.heappush(heap,i)\n    else:\n        if len(heap)==0:",
        "detail": "6oj.heap_1927",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "6oj.make_1011_flymetotheAlpha",
        "description": "6oj.make_1011_flymetotheAlpha",
        "peekOfCode": "k = int(input())\nfor i in range(k):\n    x, y = map(int, input().split())\n# 인텔리제이 커밋 테스트\n#     45>46     //      49>50\n#      46>49가 2번?",
        "detail": "6oj.make_1011_flymetotheAlpha",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "n = int(input())\nk = int(input())\napple = []\nfor i in range(k):\n    apple.append(list(map(int, input().split())))\nmove_switch = []\nl = int(input())\nfor i in range(l):\n    move_switch.append(list(input().split()))\nfor i in range(len(move_switch)):",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "k = int(input())\napple = []\nfor i in range(k):\n    apple.append(list(map(int, input().split())))\nmove_switch = []\nl = int(input())\nfor i in range(l):\n    move_switch.append(list(input().split()))\nfor i in range(len(move_switch)):\n    int(move_switch[i][0])",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "apple",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "apple = []\nfor i in range(k):\n    apple.append(list(map(int, input().split())))\nmove_switch = []\nl = int(input())\nfor i in range(l):\n    move_switch.append(list(input().split()))\nfor i in range(len(move_switch)):\n    int(move_switch[i][0])\nmove_switch = deque(move_switch)",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "move_switch",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "move_switch = []\nl = int(input())\nfor i in range(l):\n    move_switch.append(list(input().split()))\nfor i in range(len(move_switch)):\n    int(move_switch[i][0])\nmove_switch = deque(move_switch)\ngraph = [[0] * n for _ in range(n)]\n# 초기 뱀의 길이는 1\n# 뱀은 처음에 (0,0)에서 우측으로 먼저 이동한다.",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "l = int(input())\nfor i in range(l):\n    move_switch.append(list(input().split()))\nfor i in range(len(move_switch)):\n    int(move_switch[i][0])\nmove_switch = deque(move_switch)\ngraph = [[0] * n for _ in range(n)]\n# 초기 뱀의 길이는 1\n# 뱀은 처음에 (0,0)에서 우측으로 먼저 이동한다.\n# 몸길이를 늘리며 이동한후, 사과가 있다면 몸길이 유지 // 사과가 없다면 몸길이 -1 =>꼬리칸을 지워준다.",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "move_switch",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "move_switch = deque(move_switch)\ngraph = [[0] * n for _ in range(n)]\n# 초기 뱀의 길이는 1\n# 뱀은 처음에 (0,0)에서 우측으로 먼저 이동한다.\n# 몸길이를 늘리며 이동한후, 사과가 있다면 몸길이 유지 // 사과가 없다면 몸길이 -1 =>꼬리칸을 지워준다.\n# 이동하면서 몸통과 만난다면 게임종료.\n# snake 에 좌표위치를 어떻게 저장할지.\n# snake=[[0,0],[0,1] >>> 가면서 사과가 없다면 popleft, 있다면 그대로 유지.하고 cnt++ 만약 움직일 좌표가 in snake라면 게임오버.\nsnake = [[0, 0]]\nsnake = deque(snake)",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "graph = [[0] * n for _ in range(n)]\n# 초기 뱀의 길이는 1\n# 뱀은 처음에 (0,0)에서 우측으로 먼저 이동한다.\n# 몸길이를 늘리며 이동한후, 사과가 있다면 몸길이 유지 // 사과가 없다면 몸길이 -1 =>꼬리칸을 지워준다.\n# 이동하면서 몸통과 만난다면 게임종료.\n# snake 에 좌표위치를 어떻게 저장할지.\n# snake=[[0,0],[0,1] >>> 가면서 사과가 없다면 popleft, 있다면 그대로 유지.하고 cnt++ 만약 움직일 좌표가 in snake라면 게임오버.\nsnake = [[0, 0]]\nsnake = deque(snake)\n# move>>우 하 좌 상",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "snake",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "snake = [[0, 0]]\nsnake = deque(snake)\n# move>>우 하 좌 상\n# 움직임을 어떻게 구현할지\nd_row = [0, 1, 0, -1]\nd_col = [1, 0, -1, 0]\ndirection = 0\ncnt = 0\nwhile True:\n    next_point = [snake[-1][0] + d_row[direction], snake[-1][1] + d_col[direction]]",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "snake",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "snake = deque(snake)\n# move>>우 하 좌 상\n# 움직임을 어떻게 구현할지\nd_row = [0, 1, 0, -1]\nd_col = [1, 0, -1, 0]\ndirection = 0\ncnt = 0\nwhile True:\n    next_point = [snake[-1][0] + d_row[direction], snake[-1][1] + d_col[direction]]\n    if next_point in snake or next_point[0] >= n \\",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "d_row",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "d_row = [0, 1, 0, -1]\nd_col = [1, 0, -1, 0]\ndirection = 0\ncnt = 0\nwhile True:\n    next_point = [snake[-1][0] + d_row[direction], snake[-1][1] + d_col[direction]]\n    if next_point in snake or next_point[0] >= n \\\n            or next_point[1] >= n or next_point[0] < 0 or next_point[\n        1] < 0:  # gameover 조건\n        cnt += 1  # 이동을 한 시점에서 죽는거니깐.",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "d_col",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "d_col = [1, 0, -1, 0]\ndirection = 0\ncnt = 0\nwhile True:\n    next_point = [snake[-1][0] + d_row[direction], snake[-1][1] + d_col[direction]]\n    if next_point in snake or next_point[0] >= n \\\n            or next_point[1] >= n or next_point[0] < 0 or next_point[\n        1] < 0:  # gameover 조건\n        cnt += 1  # 이동을 한 시점에서 죽는거니깐.\n        print(cnt)",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "direction",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "direction = 0\ncnt = 0\nwhile True:\n    next_point = [snake[-1][0] + d_row[direction], snake[-1][1] + d_col[direction]]\n    if next_point in snake or next_point[0] >= n \\\n            or next_point[1] >= n or next_point[0] < 0 or next_point[\n        1] < 0:  # gameover 조건\n        cnt += 1  # 이동을 한 시점에서 죽는거니깐.\n        print(cnt)\n        break",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "cnt",
        "kind": 5,
        "importPath": "6oj.make_3190_snake",
        "description": "6oj.make_3190_snake",
        "peekOfCode": "cnt = 0\nwhile True:\n    next_point = [snake[-1][0] + d_row[direction], snake[-1][1] + d_col[direction]]\n    if next_point in snake or next_point[0] >= n \\\n            or next_point[1] >= n or next_point[0] < 0 or next_point[\n        1] < 0:  # gameover 조건\n        cnt += 1  # 이동을 한 시점에서 죽는거니깐.\n        print(cnt)\n        break\n    snake.append(next_point)",
        "detail": "6oj.make_3190_snake",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "6oj.pascal_15489",
        "description": "6oj.pascal_15489",
        "peekOfCode": "input = sys.stdin.readline\nr, c, w = map(int, input().split())\nn = r - 1\nm = c - 1\npascal = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1],\n          [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1]]\nres = 0\nfor width in range(w):\n    for last in range(width+1):\n        res += pascal[n + width][m + last]",
        "detail": "6oj.pascal_15489",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "6oj.pascal_15489",
        "description": "6oj.pascal_15489",
        "peekOfCode": "n = r - 1\nm = c - 1\npascal = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1],\n          [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1]]\nres = 0\nfor width in range(w):\n    for last in range(width+1):\n        res += pascal[n + width][m + last]\nprint('res', res)\n# print('width : ', width)",
        "detail": "6oj.pascal_15489",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "6oj.pascal_15489",
        "description": "6oj.pascal_15489",
        "peekOfCode": "m = c - 1\npascal = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1],\n          [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1]]\nres = 0\nfor width in range(w):\n    for last in range(width+1):\n        res += pascal[n + width][m + last]\nprint('res', res)\n# print('width : ', width)\n# print('last : ', last)",
        "detail": "6oj.pascal_15489",
        "documentation": {}
    },
    {
        "label": "pascal",
        "kind": 5,
        "importPath": "6oj.pascal_15489",
        "description": "6oj.pascal_15489",
        "peekOfCode": "pascal = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1],\n          [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1]]\nres = 0\nfor width in range(w):\n    for last in range(width+1):\n        res += pascal[n + width][m + last]\nprint('res', res)\n# print('width : ', width)\n# print('last : ', last)\n# print('value : ', pascal[n + width -1][m + last])",
        "detail": "6oj.pascal_15489",
        "documentation": {}
    },
    {
        "label": "res",
        "kind": 5,
        "importPath": "6oj.pascal_15489",
        "description": "6oj.pascal_15489",
        "peekOfCode": "res = 0\nfor width in range(w):\n    for last in range(width+1):\n        res += pascal[n + width][m + last]\nprint('res', res)\n# print('width : ', width)\n# print('last : ', last)\n# print('value : ', pascal[n + width -1][m + last])\n# print(\"*******************************\")\n# n m",
        "detail": "6oj.pascal_15489",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "6oj.sort_1181",
        "description": "6oj.sort_1181",
        "peekOfCode": "n = int(sys.stdin.readline())\nlst = []\nfor i in range(n):\n    lst.append(sys.stdin.readline().strip())\n# answer = []\n# for i in lst:\n#     if i not in answer:\n#         answer.append(i)  개느려\nlst=list(set(lst))\nlst.sort(key=lambda x:(len(x),x))",
        "detail": "6oj.sort_1181",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "6oj.sort_1181",
        "description": "6oj.sort_1181",
        "peekOfCode": "lst = []\nfor i in range(n):\n    lst.append(sys.stdin.readline().strip())\n# answer = []\n# for i in lst:\n#     if i not in answer:\n#         answer.append(i)  개느려\nlst=list(set(lst))\nlst.sort(key=lambda x:(len(x),x))\nfor i in lst:",
        "detail": "6oj.sort_1181",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "6oj.sugar_2839",
        "description": "6oj.sugar_2839",
        "peekOfCode": "input = sys.stdin.readline\nn = int(input())\n# 5의 배수인 경우가 가장 최적화임. 다음으로는 5가 최대한 많으면서 3으로 나누어 떨어져야함 그것도 안돼면 3의 배수여야함.\n# 5x+3y = n이 되야함. 여기서 x+y의 최소값을 구해라. 셋중 하나라도 만족 못하면 x+y = -1\n# 그렇다면 x+y 값의 리스트 sumXy를 만들어서 min(sumXy)를 한다면? 만약 리스트가 null이라면 -1을 출력\nsumXy = []\nfor x in range(0, 1001):\n    for y in range(0, 5000 // 3):\n        if 5 * x + 3 * y == n:\n            sumXy.append(x + y)",
        "detail": "6oj.sugar_2839",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "6oj.sugar_2839",
        "description": "6oj.sugar_2839",
        "peekOfCode": "n = int(input())\n# 5의 배수인 경우가 가장 최적화임. 다음으로는 5가 최대한 많으면서 3으로 나누어 떨어져야함 그것도 안돼면 3의 배수여야함.\n# 5x+3y = n이 되야함. 여기서 x+y의 최소값을 구해라. 셋중 하나라도 만족 못하면 x+y = -1\n# 그렇다면 x+y 값의 리스트 sumXy를 만들어서 min(sumXy)를 한다면? 만약 리스트가 null이라면 -1을 출력\nsumXy = []\nfor x in range(0, 1001):\n    for y in range(0, 5000 // 3):\n        if 5 * x + 3 * y == n:\n            sumXy.append(x + y)\nif len(sumXy) == 0:",
        "detail": "6oj.sugar_2839",
        "documentation": {}
    },
    {
        "label": "sumXy",
        "kind": 5,
        "importPath": "6oj.sugar_2839",
        "description": "6oj.sugar_2839",
        "peekOfCode": "sumXy = []\nfor x in range(0, 1001):\n    for y in range(0, 5000 // 3):\n        if 5 * x + 3 * y == n:\n            sumXy.append(x + y)\nif len(sumXy) == 0:\n    print(-1)\nelse:\n    res = min(sumXy)\n    print(res)",
        "detail": "6oj.sugar_2839",
        "documentation": {}
    },
    {
        "label": "nodes",
        "kind": 5,
        "importPath": "6oj.tree_11725_reference",
        "description": "6oj.tree_11725_reference",
        "peekOfCode": "nodes = 7\n#\n# edges = collections.defaultdict(list) # 입력받은 인접 노드들의 관계를 그래프처럼 저장하기 위해\n#                                       # defaultdict를 이용합니다.\n#                                       # 기본 dictionary를 이용하되, if문을 통해 if (key) in edges와 else로 나누어 처리해주어도\n#                                       # in을 통한 탐색의 경우 key를 대상으로 하기 때문에 문제가 발생하지 않습니다.\nedges = {\n    1: [6, 4],\n    6: [1, 3],\n    3: [6, 5], 5: [3],",
        "detail": "6oj.tree_11725_reference",
        "documentation": {}
    },
    {
        "label": "edges",
        "kind": 5,
        "importPath": "6oj.tree_11725_reference",
        "description": "6oj.tree_11725_reference",
        "peekOfCode": "edges = {\n    1: [6, 4],\n    6: [1, 3],\n    3: [6, 5], 5: [3],\n    4: [1, 2, 7],\n    2: [4],\n    7: [4]\n}\nparents = [-1] * 2 + [0] * (nodes - 1)  # NODE의 번호가 0이 아니라 1부터 시작되므로, 편하게 계산하기 위해서 NODES + 1개로 합니다.\nprint('parents: ', parents)  # 단, 루트 node가 1번이므로 0번과 1번 index는 0이 아닌 -1로 두어 허수를 제거합니다.",
        "detail": "6oj.tree_11725_reference",
        "documentation": {}
    },
    {
        "label": "parents",
        "kind": 5,
        "importPath": "6oj.tree_11725_reference",
        "description": "6oj.tree_11725_reference",
        "peekOfCode": "parents = [-1] * 2 + [0] * (nodes - 1)  # NODE의 번호가 0이 아니라 1부터 시작되므로, 편하게 계산하기 위해서 NODES + 1개로 합니다.\nprint('parents: ', parents)  # 단, 루트 node가 1번이므로 0번과 1번 index는 0이 아닌 -1로 두어 허수를 제거합니다.\nqueue = collections.deque()  # queue를 이용한 방식으로 구현하여 collections package의 deque를 이용합니다.\nqueue.append(1)  # 최초 실행을 위해 루트 node인 1번 node를 queue에 추가합니다.\n# for _ in range(nodes-1):\n#     edge = tuple(map(int, sys.stdin.readline().split()))\n#     edges[edge[0]].append(edge[1])\n#     edges[edge[1]].append(edge[0])\n#     print('edge[0] , edge[1]: ', edge[0],edge[1])\nedge = tuple([[1, 6], [3, 6], [3, 5], [1, 4], [2, 4], [4, 7]])",
        "detail": "6oj.tree_11725_reference",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 5,
        "importPath": "6oj.tree_11725_reference",
        "description": "6oj.tree_11725_reference",
        "peekOfCode": "queue = collections.deque()  # queue를 이용한 방식으로 구현하여 collections package의 deque를 이용합니다.\nqueue.append(1)  # 최초 실행을 위해 루트 node인 1번 node를 queue에 추가합니다.\n# for _ in range(nodes-1):\n#     edge = tuple(map(int, sys.stdin.readline().split()))\n#     edges[edge[0]].append(edge[1])\n#     edges[edge[1]].append(edge[0])\n#     print('edge[0] , edge[1]: ', edge[0],edge[1])\nedge = tuple([[1, 6], [3, 6], [3, 5], [1, 4], [2, 4], [4, 7]])\nprint('edges: ', edges)\nwhile queue:  # BFS와 유사한 방식으로 진행하여 queue를 이용합니다.",
        "detail": "6oj.tree_11725_reference",
        "documentation": {}
    },
    {
        "label": "edge",
        "kind": 5,
        "importPath": "6oj.tree_11725_reference",
        "description": "6oj.tree_11725_reference",
        "peekOfCode": "edge = tuple([[1, 6], [3, 6], [3, 5], [1, 4], [2, 4], [4, 7]])\nprint('edges: ', edges)\nwhile queue:  # BFS와 유사한 방식으로 진행하여 queue를 이용합니다.\n    now = queue.popleft()  # 현재 내가 찾고자 하는 자식노드들의 부모를 입력받습니다.\n    for kid in edges[now]:  # edges[now]는 해당 부모노드의 예비 자식노드들입니다.\n        if parents[kid] == 0:  # 이 if문을 통해 now node의 자식 node에 대해서만 연산을 진행할 수 있습니다.\n            # 연결관계만으로 가져온 정보이기 때문에\n            # 예비 자식노드에는 부모노드가 포함되어 있을 수 있습니다.\n            # 그러나, 한 층 한 층 내려가는 구조로 코드가 짜여 있어서\n            # 해당 노드가 부모노드일 경우, 이미 그 부모노드의 부모노드가",
        "detail": "6oj.tree_11725_reference",
        "documentation": {}
    },
    {
        "label": "nodes",
        "kind": 5,
        "importPath": "6oj.tree_11725_reference",
        "description": "6oj.tree_11725_reference",
        "peekOfCode": "nodes = int(sys.stdin.readline())\nedges = collections.defaultdict(list)\nparents = [-1] * 2 + [0] * (nodes - 1)\nqueue = collections.deque()\nqueue.append(1)\nfor _ in range(nodes - 1):\n    edge = tuple(map(int, sys.stdin.readline().split()))\n    edges[edge[0]].append(edge[1])\n    edges[edge[1]].append(edge[0])\nwhile queue:",
        "detail": "6oj.tree_11725_reference",
        "documentation": {}
    },
    {
        "label": "edges",
        "kind": 5,
        "importPath": "6oj.tree_11725_reference",
        "description": "6oj.tree_11725_reference",
        "peekOfCode": "edges = collections.defaultdict(list)\nparents = [-1] * 2 + [0] * (nodes - 1)\nqueue = collections.deque()\nqueue.append(1)\nfor _ in range(nodes - 1):\n    edge = tuple(map(int, sys.stdin.readline().split()))\n    edges[edge[0]].append(edge[1])\n    edges[edge[1]].append(edge[0])\nwhile queue:\n    now = queue.popleft()",
        "detail": "6oj.tree_11725_reference",
        "documentation": {}
    },
    {
        "label": "parents",
        "kind": 5,
        "importPath": "6oj.tree_11725_reference",
        "description": "6oj.tree_11725_reference",
        "peekOfCode": "parents = [-1] * 2 + [0] * (nodes - 1)\nqueue = collections.deque()\nqueue.append(1)\nfor _ in range(nodes - 1):\n    edge = tuple(map(int, sys.stdin.readline().split()))\n    edges[edge[0]].append(edge[1])\n    edges[edge[1]].append(edge[0])\nwhile queue:\n    now = queue.popleft()\n    for kid in edges[now]:",
        "detail": "6oj.tree_11725_reference",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 5,
        "importPath": "6oj.tree_11725_reference",
        "description": "6oj.tree_11725_reference",
        "peekOfCode": "queue = collections.deque()\nqueue.append(1)\nfor _ in range(nodes - 1):\n    edge = tuple(map(int, sys.stdin.readline().split()))\n    edges[edge[0]].append(edge[1])\n    edges[edge[1]].append(edge[0])\nwhile queue:\n    now = queue.popleft()\n    for kid in edges[now]:\n        if parents[kid] == 0:",
        "detail": "6oj.tree_11725_reference",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "6oj.zerozun_4948",
        "description": "6oj.zerozun_4948",
        "peekOfCode": "input = sys.stdin.readline\nlst = []\nwhile 1:\n    t = int(input())\n    lst.append(t)\n    if t == 0:\n        break\n# 1을 제외하고 1/2까지 나눠지는 수가 없다면 소수이다.\nlst2 = []\nfor i in range(len(lst) - 1):",
        "detail": "6oj.zerozun_4948",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "6oj.zerozun_4948",
        "description": "6oj.zerozun_4948",
        "peekOfCode": "lst = []\nwhile 1:\n    t = int(input())\n    lst.append(t)\n    if t == 0:\n        break\n# 1을 제외하고 1/2까지 나눠지는 수가 없다면 소수이다.\nlst2 = []\nfor i in range(len(lst) - 1):\n    cnt = 0  # lst[i] 바뀔때 마다 cnt 초기화",
        "detail": "6oj.zerozun_4948",
        "documentation": {}
    },
    {
        "label": "lst2",
        "kind": 5,
        "importPath": "6oj.zerozun_4948",
        "description": "6oj.zerozun_4948",
        "peekOfCode": "lst2 = []\nfor i in range(len(lst) - 1):\n    cnt = 0  # lst[i] 바뀔때 마다 cnt 초기화\n    for j in range(lst[i] + 1, (2 * lst[i]) + 1):  # j는 n부터 2n까지\n        if lst[i] == 1:\n            lst2.append(1)\n            break\n        for k in range(2, (j // 2) + 1):\n            # j는 판별할 수. k는 나눠줄수, 절반까지 가기전에 나머지가 0, 나눠진다면 필요없어\n            if j % k == 0:",
        "detail": "6oj.zerozun_4948",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.greedy",
        "description": "9rogramers.high_kit.greedy",
        "peekOfCode": "def solution(n, lost, reserve):\n    # stack처럼 꺼내는데, 우측먼저 보는 식으로 하면 가장 효율적일듯\n    # 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다> 빌려줄 수 없다.\n    # 해서 n-len(losted) 를 return\n    lost.sort()\n    reserve.sort()\n    losted=[]\n    intersection = list(set(lost) & set(reserve))\n    for item in intersection:\n        lost.remove(item)",
        "detail": "9rogramers.high_kit.greedy",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.greedy",
        "description": "9rogramers.high_kit.greedy",
        "peekOfCode": "def solution(name):\n    # A-Z 까지 아스키코드로 변환해서 숫자의 차이가 적은쪽으로 이동시킴\n    # 맨처음 커서는 가장왼쪽, 디폴트는 A로 잡혀있음.\n    # 각 칸수별로 몇번 옮겨야 하는지 세기\n    # A인 구간을 피해서 이동하는데 A-A의 길이가 가장 긴만큼 빼면 될듯?\n    # A=65, Z=90, offset 65로 두고 0~25까지 0~12 0~12 13개 // 13~25 13~1\n    if set(name)=={'A'}:\n        return 0\n    ascii=[i for i in range(13)]+[12-i for i in range(-1,12)]\n    target=[]",
        "detail": "9rogramers.high_kit.greedy",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.hash",
        "description": "9rogramers.high_kit.hash",
        "peekOfCode": "def solution(nums): #폰켓몬\n    dic={}\n    for i in nums:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    length=len(nums)//2\n    return min(length,len(dic.keys()))\ndef solution(participant, completion): #완주하지 못한 선수",
        "detail": "9rogramers.high_kit.hash",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.hash",
        "description": "9rogramers.high_kit.hash",
        "peekOfCode": "def solution(participant, completion): #완주하지 못한 선수\n    dic={}\n    for i in participant:\n        if i in dic:\n            dic[i]+=1\n        else:\n            dic[i]=1\n    for c in completion:\n        dic[c] -= 1\n    for i,v in dic.items():",
        "detail": "9rogramers.high_kit.hash",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.hash",
        "description": "9rogramers.high_kit.hash",
        "peekOfCode": "def solution(phone_book): #전화번호 목록\n    dic={}\n    # 정렬하고, phone_book을 순회하면서\n    # 현재 보고있는 애가 다른 번호의 접두어에 해당하는지\n    phone_book.sort()\n    for p in phone_book:\n        for i in range(1,len(p)):\n            pre=p[:i]\n            if pre in dic:\n                return False",
        "detail": "9rogramers.high_kit.hash",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.hash",
        "description": "9rogramers.high_kit.hash",
        "peekOfCode": "def solution(clothes): #의상\n    dic={}\n    for c in clothes:\n        if c[1] in dic:\n            dic[c[1]].append(c[0])\n        else:\n            dic[c[1]]=[c[0]]\n    count=1\n    for k,v in dic.items():\n        count*=(len(v)+1)",
        "detail": "9rogramers.high_kit.hash",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.hash",
        "description": "9rogramers.high_kit.hash",
        "peekOfCode": "def solution(genres, plays): # 베스트앨범\n    answer = []\n    # 전체합이 높으면 우선순위가 높음\n    # 각 장르당 2개씩만 넣을 수 있음, 모든 장르는 2개 골라야함(1개라면 1개만)\n    # 인덱스에 대한 정보도 필요함\n    # 이중딕셔너리로?\n    dic1 = {}\n    dic2 = {}\n    for i, (g, p) in enumerate(zip(genres, plays)):\n        if g not in dic1:",
        "detail": "9rogramers.high_kit.hash",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.heap",
        "description": "9rogramers.high_kit.heap",
        "peekOfCode": "def solution(scoville, K):\n    answer = 0\n    scoville.sort()\n    if scoville[0]>=K:\n        return 0\n    while len(scoville) >= 2:\n        temp = heapq.heappop(scoville)\n        temp2 = heapq.heappop(scoville)\n        heapq.heappush(scoville,temp+temp2*2)\n        answer+=1",
        "detail": "9rogramers.high_kit.heap",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.heap",
        "description": "9rogramers.high_kit.heap",
        "peekOfCode": "def solution(jobs):\n    answer, now, i = 0, 0, 0\n    start = -1\n    heap = []\n    # [[0, 3], [1, 9], [2, 6]]\n    while i < len(jobs):  # 현재 시점에서 처리할 수 있는 작업을 heap에 저장\n        for j in jobs:\n            if start < j[0] <= now:\n                heapq.heappush(heap, [j[1], j[0]])\n        if len(heap) > 0:  # 처리할 작업이 있는 경우",
        "detail": "9rogramers.high_kit.heap",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.heap",
        "description": "9rogramers.high_kit.heap",
        "peekOfCode": "def solution(operations):\n    # 최대힙과 최소힙 두개를 구해서 각각의 0번 인덱스를 answer로 return\n    # python은 기본적으로 최소힙을 지원하므로 max_heap에는 -부호로 넣어주고 꺼내서 -1을 마지막에 곱해준다.\n    # heap pop을할시에 최소힙에서는 최소값, 최대힙에서는 최대값이 나온다.\n    min_heap=[]\n    max_heap=[]\n    for oper in operations:\n        command, num = oper.split()\n        num = int(num)\n        if command == \"I\":",
        "detail": "9rogramers.high_kit.heap",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.sort",
        "description": "9rogramers.high_kit.sort",
        "peekOfCode": "def solution(array, commands):\n    answer=[]\n    for start,end,order in commands:\n        answer.append(sorted(array[start-1:end])[order-1])\n    return answer\n# https://school.programmers.co.kr/learn/courses/30/lessons/42746 가장 큰 수\ndef solution(numbers):\n    # 원소의 길이는 최대 4자리 자리수는 최소1개\n    answer=''\n    numbers.sort(key = lambda x: int((str(x)*4)[:4]),reverse=True)",
        "detail": "9rogramers.high_kit.sort",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.sort",
        "description": "9rogramers.high_kit.sort",
        "peekOfCode": "def solution(numbers):\n    # 원소의 길이는 최대 4자리 자리수는 최소1개\n    answer=''\n    numbers.sort(key = lambda x: int((str(x)*4)[:4]),reverse=True)\n    if numbers[0]==0:\n        return '0'\n    for num in numbers:\n        answer+=str(num)\n    return answer\n# https://school.programmers.co.kr/learn/courses/30/lessons/42747 h-index",
        "detail": "9rogramers.high_kit.sort",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.sort",
        "description": "9rogramers.high_kit.sort",
        "peekOfCode": "def solution(citations):\n    n = len(citations)\n    citations.sort()  # 오름차순으로 정렬\n    h_index = 0\n    for i in range(n):\n        if citations[i] >= n - i:  # 논문의 수에서 현재 논문의 순서를 뺀 값보다 인용 횟수가 크거나 같으면 H-Index의 후보\n            h_index = n - i\n            break  # H-Index 후보를 찾으면 반복 종료\n    return h_index",
        "detail": "9rogramers.high_kit.sort",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.stack_queue",
        "description": "9rogramers.high_kit.stack_queue",
        "peekOfCode": "def solution(arr):\n    # arr를 거꾸로 순회하여 stack을 확인하면서 넣어준다.\n    # 마지막에 stack을 거꾸로 뒤집어서 반환한다.\n    stack=[]\n    while arr:\n        if not stack or stack[-1] != arr[-1]:\n            stack.append(arr.pop())\n        else:\n            arr.pop()\n    return stack[::-1]",
        "detail": "9rogramers.high_kit.stack_queue",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.stack_queue",
        "description": "9rogramers.high_kit.stack_queue",
        "peekOfCode": "def solution(progresses, speeds):\n    answer = []\n    days = deque()\n    # 각 기능이 배포되기까지 걸리는 일수 계산하여 days 큐에 저장\n    # 첫 번째 기능부터 순서대로 확인하며 배포 처리\n    # 기능들 중 배포 가능한 것 확인\n    for i in range(len(progresses)):\n        remain = math.ceil((100 - progresses[i]) / speeds[i])\n        days.append(remain)\n    while days:",
        "detail": "9rogramers.high_kit.stack_queue",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.stack_queue",
        "description": "9rogramers.high_kit.stack_queue",
        "peekOfCode": "def solution(s):\n    if s[0] != '(' or s[-1] != ')':\n        return False\n    # 스택에 넣으면서 쌍을 이룰 수 있는지 확인\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:",
        "detail": "9rogramers.high_kit.stack_queue",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.stack_queue",
        "description": "9rogramers.high_kit.stack_queue",
        "peekOfCode": "def solution(priorities, location):\n    # A B C D E F\n    # 1 1 9 1 1 1\n    #  C D E F A B\n    #  9 1 1 1 1 1\n    # queue => fifo, 꺼내면서 최대값이 나올때까지 꺼내면서 다시 오른쪽으로 붙인다.\n    # index가 필요\n    # 최대값이 나오면 꺼내고 stack에 붙인다.\n    sorted_pri = sorted(priorities)\n    queue=deque()",
        "detail": "9rogramers.high_kit.stack_queue",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.stack_queue",
        "description": "9rogramers.high_kit.stack_queue",
        "peekOfCode": "def solution(bridge_length, weight, truck_weights):\n    # 다리의 길이 = 건너는데 소요되는 시간 = bridge_length\n    # 다리의 가용 무게 = weight\n    # 택시의 무게 = truck_weights[n]\n    # 다리로 들어갈 경우 => 다리가 비었거나, 다리에 있는 무게의합+다음트럭의 무게 <= 가용무게일때\n    # 다리에서 빠질경우 => 시간이 트럭이 다리에 들어간 시점으로부터 길이만큼이 지났을 때\n    finished=[]\n    trucks=len(truck_weights)\n    truck_weights = deque(truck_weights)\n    report=deque()",
        "detail": "9rogramers.high_kit.stack_queue",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.high_kit.stack_queue",
        "description": "9rogramers.high_kit.stack_queue",
        "peekOfCode": "def solution(prices):\n    answer = [0] * len(prices)\n    stack = []\n    # 감소했을때, 몇초나 걸렸는지를 우선 저장\n    # 감소하지 않은 친구들에 대해서 보상해줌\n    for i, price in enumerate(prices):\n        while stack and price < prices[stack[-1]]:\n            j = stack.pop()\n            answer[j] = i - j\n        stack.append(i)",
        "detail": "9rogramers.high_kit.stack_queue",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.118667",
        "description": "9rogramers.118667",
        "peekOfCode": "def solution(queue1, queue2):\n    answer = 0\n    target_sum = (sum(queue1) + sum(queue2)) // 2\n    queue1_sum = sum(queue1)\n    queue1,queue2 = deque(queue1), deque(queue2)\n    while queue1 and queue2:\n        if queue1_sum < target_sum:\n            tmp = queue2.popleft()\n            queue1_sum += tmp\n            queue1.append(tmp)",
        "detail": "9rogramers.118667",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "9rogramers.12899",
        "description": "9rogramers.12899",
        "peekOfCode": "def convert(n,base):\n    s=''\n    while n>0:\n        quo,remain=divmod(n,base)\n        if remain==0:\n            quo-=1\n            remain=3\n        s=str(remain)+s\n        n=quo\n    return s",
        "detail": "9rogramers.12899",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.12899",
        "description": "9rogramers.12899",
        "peekOfCode": "def solution(n):\n    # 진법변환시에\n    # 나누어 떨어지면 몫에 -1을 하고 나머지에+3을 해준다.\n    # 3은 4로 표기한다.\n    answer=''\n    string = convert(n,3)\n    for s in string:\n        if s=='3':\n            s='4'\n        answer += s",
        "detail": "9rogramers.12899",
        "documentation": {}
    },
    {
        "label": "get_max_two",
        "kind": 2,
        "importPath": "9rogramers.12913",
        "description": "9rogramers.12913",
        "peekOfCode": "def get_max_two(lst):\n    max1,max2,max1_index,max2_index=0,0,0,0\n    for i,v in enumerate(lst):\n        if max1 < v:\n            max2 = max1\n            max2_index = max1_index\n            max1 = v\n            max1_index = i\n        elif max2 < v:\n            max2 = v",
        "detail": "9rogramers.12913",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.12913",
        "description": "9rogramers.12913",
        "peekOfCode": "def solution(land):\n    # 현재 열의 정보를 내려주고 \n    # 현재행의 최대값2개를 가지고 다음행에 전부 더해서 최대값을 갱신한다.\n    # n행까지 진행후에, 마지막행의 max값을 return\n    answer = 0\n    values=[0,0,0,0]\n    while land:\n        options = get_max_two(values)\n        for i,_ in enumerate(land[-1]):\n            if i!=options[0][0]:",
        "detail": "9rogramers.12913",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.131704",
        "description": "9rogramers.131704",
        "peekOfCode": "def solution(order):\n    assistance = []\n    answer = 0\n    for box in range(1, len(order) + 1):\n        if order[answer] != box:\n            assistance.append(box)\n        else:\n            answer += 1\n            while assistance and order[answer] == assistance[-1]:\n                assistance.pop()",
        "detail": "9rogramers.131704",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.132265",
        "description": "9rogramers.132265",
        "peekOfCode": "def solution(topping):\n    answer = 0\n    a = defaultdict(int)\n    b = defaultdict(int)\n    for top in topping:\n        b[top] += 1  # 두 번째 조각에서의 각 토핑의 등장 횟수 계산\n    for top in topping:\n        b[top] -= 1\n        a[top] += 1\n        if b[top] == 0:",
        "detail": "9rogramers.132265",
        "documentation": {}
    },
    {
        "label": "get_common_list",
        "kind": 2,
        "importPath": "9rogramers.135807",
        "description": "9rogramers.135807",
        "peekOfCode": "def get_common_list(arrayN):\n    arrayN.sort()\n    n_common = arrayN[0]\n    n_list=[]\n    for i in range(1,n_common//2+1):\n        if n_common % i == 0:\n            n_list.append(i)\n    n_list.append(n_common)\n    result=[]\n    for c in n_list:",
        "detail": "9rogramers.135807",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.135807",
        "description": "9rogramers.135807",
        "peekOfCode": "def solution(arrayA, arrayB):\n    # 정렬된 a리스트의 0번 요소에 대한 약수를 모두 구한다.\n    # 약수들을 돌리면서 모든 원소의 공통약수인 리스트를 구한다.\n    # 정렬된 b리스트의 0번 요소에 대한 약수를 모두 구한다.\n    # 약수들을 돌리면서 모든 원소의 공통약수인 리스트를 구한다.\n    # 두 리스트를 비교하며 같지않은 수중에 가장 큰 값을 구한다.\n    # 반대편의 모든수가 나누어 지지 않는 수중에 가장 큰 수\n    # 14 = [1,2,7,14] => 7\n    # 18 = [1,2,3,6,9,18] => 2,3,6\n    # 10 => 1,2,5,10",
        "detail": "9rogramers.135807",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.148653",
        "description": "9rogramers.148653",
        "peekOfCode": "def solution(storey):\n    # 1의 자리부터 생각\n    # 5이상은 전부 올리고 자리수 +1,다음자리가 4이하인경우는 빼기(자리수올림x)\n    # 마지막인 경우에는 다음자리를 보지않고 끝남\n    storey_list=list(map(int,str(storey)))\n    count=0\n    while storey_list:\n        temp = storey_list.pop()\n        # 1. temp가 6~9일때 >> count += 10-temp, 앞자리가 존재한다면 앞자리의수 1증가\n        # 2. temp가 0~4일때 >> count += temp",
        "detail": "9rogramers.148653",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.154539",
        "description": "9rogramers.154539",
        "peekOfCode": "def solution(numbers):\n    result = [-1] * len(numbers)\n    stack = []  # 현재 숫자보다 큰 수의 인덱스를 저장할 스택\n    for i in range(len(numbers)):\n        # 스택이 존재하고 스택의 인덱스에 있는 numbers의 숫자가 현재 숫자보다 작으면 stack에서 뽑아내고 그 인덱스를 가지는 number의 수를 저장\n        while stack and numbers[stack[-1]] < numbers[i]:\n            idx = stack.pop()\n            result[idx] = numbers[i]\n        # 스택에 현재 인덱스를 저장\n        stack.append(i)",
        "detail": "9rogramers.154539",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "9rogramers.154540",
        "description": "9rogramers.154540",
        "peekOfCode": "def dfs(size,graph,visited,row,col):\n    # 종료조건 : 지금 가려는 곳이 0이면종료\n    # 상하좌우로 이동가능\n    # visited가 1일때만 갈수있는곳, 0은 아예갈수없고 2면 이미 갔다온곳\n    if row < 0 or row >= len(graph) or col < 0 or col >=len(graph[0]) or visited[row][col] != 1: ## 이 부분 때문에 범위에러가 자꾸 걸렸었음\n        return size,visited\n    drow=[-1,1,0,0]\n    dcol=[0,0,-1,1]\n    size += graph[row][col]\n    visited[row][col] = 2",
        "detail": "9rogramers.154540",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.154540",
        "description": "9rogramers.154540",
        "peekOfCode": "def solution(maps):\n    answer = []\n    # visited, dfs로 방문\n    graph = []\n    visited = []\n    temp_sum = 0\n    for m in maps:\n        temp = []\n        temp_visited = []\n        for char in m:",
        "detail": "9rogramers.154540",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.155651",
        "description": "9rogramers.155651",
        "peekOfCode": "def solution(book_time):\n    # 겹치는 시간이 최대 몇개인지를 판단해야함\n    # 시간을 정량화한다? 10분씩은 다 추가해야함.\n    # book_time length만큼 방을 만들어놓고 각 list의 start time에 겹치는 요소가 몇개인지 체크한다.\n    answer = 0\n    booked=deque()\n    for start,end in book_time:\n        hh1,mm1=start.split(':')\n        hh2,mm2=end.split(':')\n        booked.append([int(hh1)*60+int(mm1),int(hh2)*60+int(mm2)+9])",
        "detail": "9rogramers.155651",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.155651",
        "description": "9rogramers.155651",
        "peekOfCode": "def solution(book_time):\n    \"\"\"\n    예약된 각 회의에 대해 최대 몇 개의 회의실이 필요한지 계산하는 함수\n    :param book_time: 예약된 각 회의의 시작 및 종료 시간을 포함하는 리스트\n    :return: 최대 회의실 수\n    \"\"\"\n    imos = [0] * (24 * 60 + 10)  # 각 시간대별로 예약된 회의의 상태를 추적하기 위한 배열\n    # 예약된 각 회의에 대해 imos 배열을 업데이트\n    for start_time, end_time in book_time:\n        start_minutes, end_minutes = time2minutes(start_time), time2minutes(end_time)",
        "detail": "9rogramers.155651",
        "documentation": {}
    },
    {
        "label": "time2minutes",
        "kind": 2,
        "importPath": "9rogramers.155651",
        "description": "9rogramers.155651",
        "peekOfCode": "def time2minutes(time):\n    \"\"\"\n    시간을 분으로 변환하는 함수\n    :param time: 시간을 나타내는 문자열 (예: \"15:30\")\n    :return: 분 단위로 변환된 시간\n    \"\"\"\n    HH, MM = map(int, time.split(\":\"))\n    return HH * 60 + MM\n# 테스트용 예약된 회의 시간\nbook_time = [[\"15:00\", \"17:00\"], [\"16:40\", \"18:20\"], [\"14:20\", \"15:20\"], [\"14:10\", \"19:20\"], [\"18:20\", \"21:20\"]]",
        "detail": "9rogramers.155651",
        "documentation": {}
    },
    {
        "label": "CLEAR_TIME_DELTA",
        "kind": 5,
        "importPath": "9rogramers.155651",
        "description": "9rogramers.155651",
        "peekOfCode": "CLEAR_TIME_DELTA = 10  # 예약된 회의가 끝난 후 몇 분 후에 회의실이 비워지는지를 나타내는 변수\ndef solution(book_time):\n    \"\"\"\n    예약된 각 회의에 대해 최대 몇 개의 회의실이 필요한지 계산하는 함수\n    :param book_time: 예약된 각 회의의 시작 및 종료 시간을 포함하는 리스트\n    :return: 최대 회의실 수\n    \"\"\"\n    imos = [0] * (24 * 60 + 10)  # 각 시간대별로 예약된 회의의 상태를 추적하기 위한 배열\n    # 예약된 각 회의에 대해 imos 배열을 업데이트\n    for start_time, end_time in book_time:",
        "detail": "9rogramers.155651",
        "documentation": {}
    },
    {
        "label": "book_time",
        "kind": 5,
        "importPath": "9rogramers.155651",
        "description": "9rogramers.155651",
        "peekOfCode": "book_time = [[\"15:00\", \"17:00\"], [\"16:40\", \"18:20\"], [\"14:20\", \"15:20\"], [\"14:10\", \"19:20\"], [\"18:20\", \"21:20\"]]\n# solution 함수 호출 및 결과 출력\nprint(solution(book_time))  # 출력: 3",
        "detail": "9rogramers.155651",
        "documentation": {}
    },
    {
        "label": "cut_and_append",
        "kind": 2,
        "importPath": "9rogramers.17677",
        "description": "9rogramers.17677",
        "peekOfCode": "def cut_and_append(text):\n    lst = []\n    for i in range(0, len(text)):\n        substr = text[i:i+2]\n        if re.match(\"^[a-zA-Z]+$\", substr) and len(substr)>1:\n            lst.append(substr.lower())\n    return lst\ndef solution(str1, str2):\n    intersection_count=0\n    str1_dic,str2_dic=Counter(cut_and_append(str1)),Counter(cut_and_append(str2))",
        "detail": "9rogramers.17677",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.17677",
        "description": "9rogramers.17677",
        "peekOfCode": "def solution(str1, str2):\n    intersection_count=0\n    str1_dic,str2_dic=Counter(cut_and_append(str1)),Counter(cut_and_append(str2))\n    if not str1_dic and not str2_dic:\n        return 65536\n    for k,v in str1_dic.items():\n        if k in str2_dic:\n            intersection_count+=min(v,str2_dic[k])\n    union_count=sum(str1_dic.values())+sum(str2_dic.values())-intersection_count\n    answer=int((intersection_count/union_count)*65536)",
        "detail": "9rogramers.17677",
        "documentation": {}
    },
    {
        "label": "alphabet",
        "kind": 5,
        "importPath": "9rogramers.17684",
        "description": "9rogramers.17684",
        "peekOfCode": "alphabet = list(string.ascii_uppercase)\n# 딕셔너리 생성\nmsg_dict = {}\nfor i in range(len(alphabet)):\n    msg_dict[alphabet[i]] = i + 1\nmsg='TOBEORNOTTOBEORTOBEORNOT'\n# msg='KAKAO'\nanswer=[]\ni=1\nval=26",
        "detail": "9rogramers.17684",
        "documentation": {}
    },
    {
        "label": "msg_dict",
        "kind": 5,
        "importPath": "9rogramers.17684",
        "description": "9rogramers.17684",
        "peekOfCode": "msg_dict = {}\nfor i in range(len(alphabet)):\n    msg_dict[alphabet[i]] = i + 1\nmsg='TOBEORNOTTOBEORTOBEORNOT'\n# msg='KAKAO'\nanswer=[]\ni=1\nval=26\n# 첫글자가 있으면 두번째글자까지 확인, ..., n번째 글자까지 확인해서 없으면 단어 추가하고 추가한 곳 전까지 1. answer에 value를 넣는다. 2.단어를 자른다\n# 다음 글자가 없으면 그대로 출력하고 끝낸다.",
        "detail": "9rogramers.17684",
        "documentation": {}
    },
    {
        "label": "convert_to_base_n",
        "kind": 2,
        "importPath": "9rogramers.17687",
        "description": "9rogramers.17687",
        "peekOfCode": "def convert_to_base_n(number, base):\n    if number == 0:\n        return '0'\n    result = ''\n    while number > 0:\n        number, remainder = divmod(number, base)\n        if remainder < 10:\n            result = str(remainder) + result\n        else:\n            result = chr(remainder - 10 + ord('A')) + result",
        "detail": "9rogramers.17687",
        "documentation": {}
    },
    {
        "label": "find_min_element",
        "kind": 2,
        "importPath": "9rogramers.178870",
        "description": "9rogramers.178870",
        "peekOfCode": "def find_min_element(answer):\n    min_diff = float('inf')\n    min_element = None\n    for x, y in answer:\n        diff = abs(y - x)\n        if diff < min_diff or (diff == min_diff and x < min_element[0]):\n            min_diff = diff\n            min_element = [x, y]\n    return min_element\ndef solution(sequence, k):",
        "detail": "9rogramers.178870",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.178870",
        "description": "9rogramers.178870",
        "peekOfCode": "def solution(sequence, k):\n    # sequence는 비정렬된 리스트\n    # 가장 길이가 짧은\n    # 완전탐색\n    # 누적합이 작으면 이중 탐색, 같거나 크면 다음루프로\n    # answer를 길이순서, 길이가같다면 인덱스의 첫번째가 작은순서로 정렬\n    answer = []\n    total = 0\n    start = 0\n    for end in range(len(sequence)):",
        "detail": "9rogramers.178870",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "9rogramers.1844",
        "description": "9rogramers.1844",
        "peekOfCode": "def dfs(maps,visited,answer_list,moving_times,cursor):\n      print(cursor)\n      if cursor==[4,4]:\n            answer_list.append(moving_times)\n            return answer_list\n      for i in range(4):\n            next_row = cursor[0]+drow[i]\n            next_col = cursor[1]+dcol[i]\n            if 0<=next_row<len(maps) and 0<=next_col<len(maps[0]) and visited[next_row][next_col]==1:\n                  visited[next_row][next_col]=2",
        "detail": "9rogramers.1844",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.1844",
        "description": "9rogramers.1844",
        "peekOfCode": "def solution(maps):\n      visited=copy.deepcopy(maps)\n      answer_list=dfs(maps,visited,[],0,[0,0])\n      print(answer_list)\n      return min(answer_list)\n# 최단거리문제는 dfs로 풀면 안됨\nfrom collections import deque\ndef solution(maps):\n    n = len(maps)\n    m = len(maps[0])",
        "detail": "9rogramers.1844",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.1844",
        "description": "9rogramers.1844",
        "peekOfCode": "def solution(maps):\n    n = len(maps)\n    m = len(maps[0])\n    visited = [[False] * m for _ in range(n)]\n    drow = [-1, 1, 0, 0]\n    dcol = [0, 0, -1, 1]\n    queue = deque([(0, 0, 1)])\n    visited[0][0] = True\n    while queue:\n        row, col, distance = queue.popleft()",
        "detail": "9rogramers.1844",
        "documentation": {}
    },
    {
        "label": "maps",
        "kind": 5,
        "importPath": "9rogramers.1844",
        "description": "9rogramers.1844",
        "peekOfCode": "maps = [\n    [1, 0, 1, 1, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 1],\n    [0, 0, 0, 0, 1]\n]\nprint(solution(maps))",
        "detail": "9rogramers.1844",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.242258",
        "description": "9rogramers.242258",
        "peekOfCode": "def solution(bandage, health, attacks):\n    # attack 전까지 회복시간을 가지는데, 회복시간이 시전시간 이상이라면 추가회복량을 가진다.\n    # 최대체력이상 받을수없다.\n    # bandage는 [시전 시간, 초당 회복량, 추가 회복량]\n    temp_time=0\n    max_health=health\n    for attack in attacks:\n        heal_time = attack[0] - temp_time - 1\n        heal_point = heal_time*bandage[1]\n        if heal_time >= bandage[0]:",
        "detail": "9rogramers.242258",
        "documentation": {}
    },
    {
        "label": "answer",
        "kind": 5,
        "importPath": "9rogramers.42584",
        "description": "9rogramers.42584",
        "peekOfCode": "answer = [0]*len(prices)\nfor i,price in enumerate(prices):\n    while stack and ((price < prices[stack[-1]]) or i==len(prices)-1): \n        idx = stack.pop()\n        answer[idx]=i-idx\n    stack.append(i)\nprint(answer)",
        "detail": "9rogramers.42584",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.42587",
        "description": "9rogramers.42587",
        "peekOfCode": "def solution(priorities, location):\n    # 최대값을 빼야할 값으로 지정\n    # 왼쪽부터 꺼내면서 최대값인지 확인\n    # 최대값이라면 순서값(location) 과 몇번째로 나왔는지(count)를 확인하여 location과 같다면 count를 리턴\n    # 최대값이 아니라면 locations와 priorities의 오른편에 다시 삽입\n    # 다 나올때까지 반복\n    locations=deque([i for i in range(len(priorities))])\n    priorities=deque(priorities)\n    count=0\n    while priorities:",
        "detail": "9rogramers.42587",
        "documentation": {}
    },
    {
        "label": "is_prime",
        "kind": 2,
        "importPath": "9rogramers.42839",
        "description": "9rogramers.42839",
        "peekOfCode": "def is_prime(number): # 소수판별\n    if number == 2:\n        return True\n    if number <= 1:\n        return False\n    if number%2 ==0:\n        return False\n    for i in range(3, int(number ** 0.5) + 1, 2):\n        if number % i == 0:\n            return False",
        "detail": "9rogramers.42839",
        "documentation": {}
    },
    {
        "label": "generate_permutations",
        "kind": 2,
        "importPath": "9rogramers.42839",
        "description": "9rogramers.42839",
        "peekOfCode": "def generate_permutations(s, length):\n    return [int(''.join(permutation)) for permutation in permutations(s, length)]\ndef solution(numbers):\n    n = len(numbers)\n    all_permutations = []\n    answer=0\n    for length in range(1, n + 1):\n        all_permutations.extend(generate_permutations(numbers, length))\n    for i in set(all_permutations):\n        if is_prime(i):",
        "detail": "9rogramers.42839",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.42839",
        "description": "9rogramers.42839",
        "peekOfCode": "def solution(numbers):\n    n = len(numbers)\n    all_permutations = []\n    answer=0\n    for length in range(1, n + 1):\n        all_permutations.extend(generate_permutations(numbers, length))\n    for i in set(all_permutations):\n        if is_prime(i):\n            answer+=1\n    return answer",
        "detail": "9rogramers.42839",
        "documentation": {}
    },
    {
        "label": "find",
        "kind": 2,
        "importPath": "9rogramers.42861",
        "description": "9rogramers.42861",
        "peekOfCode": "def find(parent, node):\n    if parent[node] != node:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\ndef union(parent, rank, x, y):\n    x_root = find(parent, x)\n    y_root = find(parent, y)\n    if rank[x_root] < rank[y_root]:\n        parent[x_root] = y_root\n    elif rank[x_root] > rank[y_root]:",
        "detail": "9rogramers.42861",
        "documentation": {}
    },
    {
        "label": "union",
        "kind": 2,
        "importPath": "9rogramers.42861",
        "description": "9rogramers.42861",
        "peekOfCode": "def union(parent, rank, x, y):\n    x_root = find(parent, x)\n    y_root = find(parent, y)\n    if rank[x_root] < rank[y_root]:\n        parent[x_root] = y_root\n    elif rank[x_root] > rank[y_root]:\n        parent[y_root] = x_root\n    else:\n        parent[y_root] = x_root\n        rank[x_root] += 1",
        "detail": "9rogramers.42861",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.42861",
        "description": "9rogramers.42861",
        "peekOfCode": "def solution(n, costs):\n    # 크루스칼 알고리즘 (MST 최소 신장 트리)\n    # 사이클이 생기지 않도록 간선의 비중치를 고려하여 생성하는 형태\n    # 비용으로 간선 정렬\n    costs.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    rank = [0] * n\n    total_cost = 0\n    for cost in costs:\n        start, end, c = cost",
        "detail": "9rogramers.42861",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "9rogramers.42861",
        "description": "9rogramers.42861",
        "peekOfCode": "def dfs(key,answer,node_graph,keys,visited,temp_cost):\n    if len(key) > 1 and key in visited:\n        return\n    if set(visited) == keys:\n        return min(answer,temp_cost)\n    for k in node_graph[key].keys():\n        temp_cost += node_graph[key][k]\n        visited.append(k)\n        dfs(k,answer,node_graph,keys,visited,temp_cost)\n        visited.remove(k)",
        "detail": "9rogramers.42861",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.42861",
        "description": "9rogramers.42861",
        "peekOfCode": "def solution(n, costs):\n    # 1. 다리를 통해 모든 섬이 이어지게만 하면 된다. > 깊이 탐색으로 들어가서 모든 노드가 원소가 될 때까지\n    # 이중 딕셔너리 형태로 >> node = {0 : {1 : 3,2 : 4},...,}\n    # 2. 섬을 이으면서 cost를 기록한다.\n    # 종료조건 = 방문한 노드의 set이 기존 모든 노드를 가지고 있을경우. 하면서 min값을 계속해서 저장시킨다.\n    # dfs에서 할일 : temp_cost를 늘리면서 현재 key에서 다음 key로 넘어간다.\n    node_graph = defaultdict(dict)\n    for cost in costs:\n        node_graph[cost[0]][cost[1]] = cost[2]\n        node_graph[cost[1]][cost[0]] = cost[2]",
        "detail": "9rogramers.42861",
        "documentation": {}
    },
    {
        "label": "dfs_get_sum",
        "kind": 2,
        "importPath": "9rogramers.43165",
        "description": "9rogramers.43165",
        "peekOfCode": "def dfs_get_sum(numbers, count, target, cursor=0, temp_sum=0):\n    if cursor == len(numbers):\n        return count+1 if temp_sum==target else count\n    positive=dfs_get_sum(numbers, count, target, cursor+1, temp_sum+numbers[cursor])\n    negative=dfs_get_sum(numbers, count, target, cursor+1, temp_sum-numbers[cursor])\n    return positive+negative\ndef solution(numbers, target):\n    # 종료조건 numbers를 다 돌았을때\n    # count는 덧셈이 끝났을경우에 target과 같다면 증가하여 리턴\n    # 현재 수가 양수일 경우를 가정하여 계산한다.",
        "detail": "9rogramers.43165",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.43165",
        "description": "9rogramers.43165",
        "peekOfCode": "def solution(numbers, target):\n    # 종료조건 numbers를 다 돌았을때\n    # count는 덧셈이 끝났을경우에 target과 같다면 증가하여 리턴\n    # 현재 수가 양수일 경우를 가정하여 계산한다.\n    # 현재 수가 음수일 경우를 가정하여 계산한다.\n    count = 0\n    count = dfs_get_sum(numbers,count,target)\n    return count",
        "detail": "9rogramers.43165",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.49189",
        "description": "9rogramers.49189",
        "peekOfCode": "def solution(n, vertex):\n    # 그래프를 딕셔너리로 선언\n    graph = {node: [] for node in range(1, n + 1)}\n    distances = {}\n    for v in vertex:\n        a, b = v\n        graph[a].append(b)\n        graph[b].append(a)\n    for node in range(1, n + 1):\n        distances[node] = -1",
        "detail": "9rogramers.49189",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "9rogramers.49189",
        "description": "9rogramers.49189",
        "peekOfCode": "n = 6\nvertex = [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]\nprint(solution(n, vertex))",
        "detail": "9rogramers.49189",
        "documentation": {}
    },
    {
        "label": "vertex",
        "kind": 5,
        "importPath": "9rogramers.49189",
        "description": "9rogramers.49189",
        "peekOfCode": "vertex = [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]\nprint(solution(n, vertex))",
        "detail": "9rogramers.49189",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.49993",
        "description": "9rogramers.49993",
        "peekOfCode": "def solution(skill, skill_trees):\n    # skill = cbd 일때 %c%b%d 인지 확인. cbd는 필요충분 조건이 아님\n    # c전에 b,d가 나오면 안됨 c-b-d를 stack에서 삭제\n    answer = 0\n    stack=[]\n    for s in skill[::-1]:\n        stack.append(s)\n    for tree in skill_trees:\n        temp_stack=stack[:]\n        flag=1",
        "detail": "9rogramers.49993",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.68645",
        "description": "9rogramers.68645",
        "peekOfCode": "def solution(n):\n    direction = [(1,0),(0,1),(-1,-1)]\n    answer = []\n    n_list=[[0]*i for i in range(1,n+1)]\n    row, col, count=-1,0,0\n    # 아래>오른>위 순으로 움직이며, 방향전환의 한계는 n번까지 행해짐\n    # 각 방향전환당 움직이는 횟수는 n으로부터 회전할때마다 1씩 줄어든다.\n    for i in range(n):\n        drow,dcol=direction[i%3]\n        for j in range(i,n):",
        "detail": "9rogramers.68645",
        "documentation": {}
    },
    {
        "label": "is_zipped",
        "kind": 2,
        "importPath": "9rogramers.68936",
        "description": "9rogramers.68936",
        "peekOfCode": "def is_zipped(d2_lst,first_val):\n    for i in d2_lst:\n        for j in i:\n            if first_val!=j:\n                return False\n    return True\ndef dfs(arr,dic):\n    if len(arr)==1:\n        return dic\n    length=len(arr)//2",
        "detail": "9rogramers.68936",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "9rogramers.68936",
        "description": "9rogramers.68936",
        "peekOfCode": "def dfs(arr,dic):\n    if len(arr)==1:\n        return dic\n    length=len(arr)//2\n    left_top=[]\n    right_top=[]\n    left_bottom=[]\n    right_bottom=[]\n    for i in arr[:length]:\n        left_top.append(i[:length])",
        "detail": "9rogramers.68936",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.68936",
        "description": "9rogramers.68936",
        "peekOfCode": "def solution(arr):\n    # 2^n 형태의 정사각형을 4등분,4등분,4등분 ,.., 1칸이 될때까지 등분\n    # 등분을 했을때 모두 같다면 숫자 하나로 압축.\n    # dfs로 구현가능\n    # 종료조건 칸에 들어간 숫자가 1개일때\n    # 칸에 들어가 있는 모든수가 같다면 0또는 1 하나로 압축\n    # 기존 1의개수와 0의개수를 업데이트 하는식으로. 4등분을 한 리스트의 크기-1 만큼 각 수의 개수가 줄어듬\n    dic={0:0,1:0}\n    for i in arr:\n        for j in i:",
        "detail": "9rogramers.68936",
        "documentation": {}
    },
    {
        "label": "convert_to_base_n",
        "kind": 2,
        "importPath": "9rogramers.77885",
        "description": "9rogramers.77885",
        "peekOfCode": "def convert_to_base_n(number, base):\n    if number == 0:\n        return '0'\n    result = ''\n    while number > 0:\n        number, remainder = divmod(number, base)\n        if remainder < 10:\n            result = str(remainder) + result\n        else:\n            result = chr(remainder - 10 + ord('A')) + result",
        "detail": "9rogramers.77885",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.77885",
        "description": "9rogramers.77885",
        "peekOfCode": "def solution(numbers):\n    answer = []\n    for num in numbers:\n        if num % 2 == 0:\n            answer.append(num + 1)\n        else:\n            binary_num = list('0'+convert_to_base_n(num, 2))\n            for idx, val in enumerate(binary_num[::-1]):\n                if val == '0':\n                    binary_num[-idx-1] = '1'",
        "detail": "9rogramers.77885",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.84512",
        "description": "9rogramers.84512",
        "peekOfCode": "def solution(word):\n    vowels = [\"A\", \"E\", \"I\", \"O\", \"U\"]\n    words = []\n    for i in range(1, 6):\n        print(words)\n        for j in product(vowels, repeat=i):\n            words.append(\"\".join(j))\n    words.sort()\n    return words.index(word) + 1",
        "detail": "9rogramers.84512",
        "documentation": {}
    },
    {
        "label": "is_possible",
        "kind": 2,
        "importPath": "9rogramers.86053",
        "description": "9rogramers.86053",
        "peekOfCode": "def is_possible(time, a, b, g, s, w, t):\n    n = len(g)\n    total = 0\n    total_g = 0\n    total_s = 0\n    for i in range(n):\n        cnt = time // (2 * t[i])\n        if time % (2 * t[i]) >= t[i]:\n            cnt += 1\n        tmp = min(cnt * w[i], g[i] + s[i])",
        "detail": "9rogramers.86053",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.86053",
        "description": "9rogramers.86053",
        "peekOfCode": "def solution(a, b, g, s, w, t):\n    # 맞는 시간을 구하는건 아주 까다롭기 때문에 시간을 그냥 때려 맞추는 편이 나음\n    # 2분탐색으로 아주 큰 수와 0을 시작 mid = lo+hi // 2\n    # for문을 순회하며 총시간이 mid일때의 시간,금,은 운송량이 모두 기준치를 초과하는지에 대해 return\n    # 운송량이 초과하면 hi=mid,부족하면 lo=mid로 보정을함\n    # lo+1<hi 인 순간에 종료\n    # 총 걸린 시간//왕복하는데 걸리는 시간 => 이동횟수\n    # 딱코일경우 > 총 걸린시간을 왕복하는 시간으로 나눈 나머지가 1회 시간 이상이라면 1회 편도 추가\n    # i번 회차에 운송한 양 = min(cnt*w[i],g[i]+s[i]) \n    # >> i번째 도시의 트럭이 옮길수 있는 최대무게 vs i번째 도시의 금+은의 무게중 작은값",
        "detail": "9rogramers.86053",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "9rogramers.87694",
        "description": "9rogramers.87694",
        "peekOfCode": "graph = [[0 for _ in range(12)] for _ in range(12)]\nrectangles = [[1,1,7,4],[3,2,5,5],[4,3,6,9],[2,6,8,8]]\nfor rec in rectangles:\n    left_x,left_y,right_x,right_y=rec\n    for i in range(left_y, right_y + 1):\n        for j in range(left_x, right_x + 1):\n            graph[i][j] = 1\nprint(graph)\n# 상하좌우가 모두 1이면 가지말고, 모두1이 아닐때 가야함.\n# 출발좌표 characterX,characterY / 도착좌표 itemX,itemY",
        "detail": "9rogramers.87694",
        "documentation": {}
    },
    {
        "label": "rectangles",
        "kind": 5,
        "importPath": "9rogramers.87694",
        "description": "9rogramers.87694",
        "peekOfCode": "rectangles = [[1,1,7,4],[3,2,5,5],[4,3,6,9],[2,6,8,8]]\nfor rec in rectangles:\n    left_x,left_y,right_x,right_y=rec\n    for i in range(left_y, right_y + 1):\n        for j in range(left_x, right_x + 1):\n            graph[i][j] = 1\nprint(graph)\n# 상하좌우가 모두 1이면 가지말고, 모두1이 아닐때 가야함.\n# 출발좌표 characterX,characterY / 도착좌표 itemX,itemY\ncharacterX,characterY=1,3",
        "detail": "9rogramers.87694",
        "documentation": {}
    },
    {
        "label": "decimal_to_n",
        "kind": 2,
        "importPath": "9rogramers.92335",
        "description": "9rogramers.92335",
        "peekOfCode": "def decimal_to_n(decimal_num,n):\n    if decimal_num=='0':\n        return '0'\n    convert_str=''\n    while decimal_num:\n        convert_str+=str(decimal_num%n)\n        decimal_num//=n\n    return convert_str[::-1]\ndef is_prime(number):\n    if number == 2:",
        "detail": "9rogramers.92335",
        "documentation": {}
    },
    {
        "label": "is_prime",
        "kind": 2,
        "importPath": "9rogramers.92335",
        "description": "9rogramers.92335",
        "peekOfCode": "def is_prime(number):\n    if number == 2:\n        return True\n    if number <= 1:\n        return False\n    if number%2 ==0:\n        return False\n    for i in range(3, int(number ** 0.5) + 1, 2):\n        if number % i == 0:\n            return False",
        "detail": "9rogramers.92335",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.92341",
        "description": "9rogramers.92341",
        "peekOfCode": "def solution(fees, records):\n    # 출차내역이 없다면 23:59를 기준으로 출차\n    # fee 기본시간/기본요금 /단위시간/단위요금\n    # records[i][:2] 시간 [3:5] 분 [6:10] 번호판 [11:] in,out\n    # 시간을 계산해서 in에 입차시간 out에 출차시간 딕셔너리 만들기\n    # 교집합이 없다면 입차시간 out을 23 59로 치환해서 넣어주기\n    # 단위시간으로 나누어떨어지지않으면 올림\n    # 차량번호가 작은순으로 정렬\n    time_dict=defaultdict(int)\n    in_out_check_dict = defaultdict(bool)",
        "detail": "9rogramers.92341",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.any",
        "description": "9rogramers.any",
        "peekOfCode": "def solution(dirs):\n    q = deque(dirs)\n    x, y = 5, 5\n    start = [x, y]  # 시작점(현재위치한 좌표)\n    visited = []  # 이동한 좌표\n    dx = [0, 0, -1, 1] #col\n    dy = [-1, 1, 0, 0] #row\n    move_types = [\"L\", \"R\", \"U\", \"D\"]\n    while q:  # dirs의 길이만큼 반복\n        print('HI im while')",
        "detail": "9rogramers.any",
        "documentation": {}
    },
    {
        "label": "dirs",
        "kind": 5,
        "importPath": "9rogramers.any",
        "description": "9rogramers.any",
        "peekOfCode": "dirs = list('UUUUU')\nfrom collections import deque\ndef solution(dirs):\n    q = deque(dirs)\n    x, y = 5, 5\n    start = [x, y]  # 시작점(현재위치한 좌표)\n    visited = []  # 이동한 좌표\n    dx = [0, 0, -1, 1] #col\n    dy = [-1, 1, 0, 0] #row\n    move_types = [\"L\", \"R\", \"U\", \"D\"]",
        "detail": "9rogramers.any",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.arr_slice",
        "description": "9rogramers.arr_slice",
        "peekOfCode": "def solution(n, left, right): # 메모리초과\n    answer = []\n    count=1\n    # count는 매라운드 증가하고 증가할때 i가 count보다 작거나 같으면 count로 채우기\n    while count<=n:\n        for i in range(1,n+1):\n            if i <= count:\n                temp=count\n            else:\n                temp=i",
        "detail": "9rogramers.arr_slice",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.arr_slice",
        "description": "9rogramers.arr_slice",
        "peekOfCode": "def solution(n, left, right):\n    answer = []\n    for i in range(left, right+1):\n        row = i // n\n        col = i % n\n        answer.append(max(row, col) + 1)\n    return answer",
        "detail": "9rogramers.arr_slice",
        "documentation": {}
    },
    {
        "label": "find",
        "kind": 2,
        "importPath": "9rogramers.bi_search",
        "description": "9rogramers.bi_search",
        "peekOfCode": "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\ndef union(parent, rank, x, y):\n    root_x = find(parent, x)\n    root_y = find(parent, y)\n    if root_x == root_y:\n        return\n    if rank[root_x] < rank[root_y]:",
        "detail": "9rogramers.bi_search",
        "documentation": {}
    },
    {
        "label": "union",
        "kind": 2,
        "importPath": "9rogramers.bi_search",
        "description": "9rogramers.bi_search",
        "peekOfCode": "def union(parent, rank, x, y):\n    root_x = find(parent, x)\n    root_y = find(parent, y)\n    if root_x == root_y:\n        return\n    if rank[root_x] < rank[root_y]:\n        parent[root_x] = root_y\n    elif rank[root_x] > rank[root_y]:\n        parent[root_y] = root_x\n    else:",
        "detail": "9rogramers.bi_search",
        "documentation": {}
    },
    {
        "label": "count_nodes",
        "kind": 2,
        "importPath": "9rogramers.bi_search",
        "description": "9rogramers.bi_search",
        "peekOfCode": "def count_nodes(parent, n):\n    counts = {}\n    for i in range(n):\n        root = find(parent, i)\n        counts[root] = counts.get(root, 0) + 1\n    return counts\ndef solution(n, wires):\n    min_diff = float('inf')\n    for i in range(len(wires)):\n        parent = list(range(n))",
        "detail": "9rogramers.bi_search",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.bi_search",
        "description": "9rogramers.bi_search",
        "peekOfCode": "def solution(n, wires):\n    min_diff = float('inf')\n    for i in range(len(wires)):\n        parent = list(range(n))\n        rank = [0] * n\n        for j, (a, b) in enumerate(wires):\n            if j != i:\n                union(parent, rank, a - 1, b - 1)\n        counts = count_nodes(parent, n)\n        values = list(counts.values())",
        "detail": "9rogramers.bi_search",
        "documentation": {}
    },
    {
        "label": "bridge_length",
        "kind": 5,
        "importPath": "9rogramers.bridge_pass",
        "description": "9rogramers.bridge_pass",
        "peekOfCode": "bridge_length = 2\nweight = 10\ntruck_weights = [7, 4, 5, 6]\n############################################################################\ntruck_weights = deque(truck_weights) #deque\nbridge = deque([0 for _ in range(bridge_length)]) #bridge 에 트럭이 없다면 길에 0을 넣는 생각\ntime = 0\nbridge_weight = 0\nwhile len(bridge) != 0:\n    out = bridge.popleft()         #popleft후에 빠진 무게를 bridge_weight에 갱신",
        "detail": "9rogramers.bridge_pass",
        "documentation": {}
    },
    {
        "label": "weight",
        "kind": 5,
        "importPath": "9rogramers.bridge_pass",
        "description": "9rogramers.bridge_pass",
        "peekOfCode": "weight = 10\ntruck_weights = [7, 4, 5, 6]\n############################################################################\ntruck_weights = deque(truck_weights) #deque\nbridge = deque([0 for _ in range(bridge_length)]) #bridge 에 트럭이 없다면 길에 0을 넣는 생각\ntime = 0\nbridge_weight = 0\nwhile len(bridge) != 0:\n    out = bridge.popleft()         #popleft후에 빠진 무게를 bridge_weight에 갱신\n    bridge_weight -= out",
        "detail": "9rogramers.bridge_pass",
        "documentation": {}
    },
    {
        "label": "truck_weights",
        "kind": 5,
        "importPath": "9rogramers.bridge_pass",
        "description": "9rogramers.bridge_pass",
        "peekOfCode": "truck_weights = [7, 4, 5, 6]\n############################################################################\ntruck_weights = deque(truck_weights) #deque\nbridge = deque([0 for _ in range(bridge_length)]) #bridge 에 트럭이 없다면 길에 0을 넣는 생각\ntime = 0\nbridge_weight = 0\nwhile len(bridge) != 0:\n    out = bridge.popleft()         #popleft후에 빠진 무게를 bridge_weight에 갱신\n    bridge_weight -= out\n    time += 1",
        "detail": "9rogramers.bridge_pass",
        "documentation": {}
    },
    {
        "label": "truck_weights",
        "kind": 5,
        "importPath": "9rogramers.bridge_pass",
        "description": "9rogramers.bridge_pass",
        "peekOfCode": "truck_weights = deque(truck_weights) #deque\nbridge = deque([0 for _ in range(bridge_length)]) #bridge 에 트럭이 없다면 길에 0을 넣는 생각\ntime = 0\nbridge_weight = 0\nwhile len(bridge) != 0:\n    out = bridge.popleft()         #popleft후에 빠진 무게를 bridge_weight에 갱신\n    bridge_weight -= out\n    time += 1\n    if truck_weights:              # **is not None list**\n        if bridge_weight + truck_weights[0] <= weight:  #대기열 첫째 무게와 현재 다리의 무게를 더해서 가능한 무게 이하인경우",
        "detail": "9rogramers.bridge_pass",
        "documentation": {}
    },
    {
        "label": "bridge",
        "kind": 5,
        "importPath": "9rogramers.bridge_pass",
        "description": "9rogramers.bridge_pass",
        "peekOfCode": "bridge = deque([0 for _ in range(bridge_length)]) #bridge 에 트럭이 없다면 길에 0을 넣는 생각\ntime = 0\nbridge_weight = 0\nwhile len(bridge) != 0:\n    out = bridge.popleft()         #popleft후에 빠진 무게를 bridge_weight에 갱신\n    bridge_weight -= out\n    time += 1\n    if truck_weights:              # **is not None list**\n        if bridge_weight + truck_weights[0] <= weight:  #대기열 첫째 무게와 현재 다리의 무게를 더해서 가능한 무게 이하인경우\n            left = truck_weights.popleft()              #대기열 첫번째 index를 bridge로 append, 무게 갱신한다.",
        "detail": "9rogramers.bridge_pass",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 5,
        "importPath": "9rogramers.bridge_pass",
        "description": "9rogramers.bridge_pass",
        "peekOfCode": "time = 0\nbridge_weight = 0\nwhile len(bridge) != 0:\n    out = bridge.popleft()         #popleft후에 빠진 무게를 bridge_weight에 갱신\n    bridge_weight -= out\n    time += 1\n    if truck_weights:              # **is not None list**\n        if bridge_weight + truck_weights[0] <= weight:  #대기열 첫째 무게와 현재 다리의 무게를 더해서 가능한 무게 이하인경우\n            left = truck_weights.popleft()              #대기열 첫번째 index를 bridge로 append, 무게 갱신한다.\n            bridge_weight += left",
        "detail": "9rogramers.bridge_pass",
        "documentation": {}
    },
    {
        "label": "bridge_weight",
        "kind": 5,
        "importPath": "9rogramers.bridge_pass",
        "description": "9rogramers.bridge_pass",
        "peekOfCode": "bridge_weight = 0\nwhile len(bridge) != 0:\n    out = bridge.popleft()         #popleft후에 빠진 무게를 bridge_weight에 갱신\n    bridge_weight -= out\n    time += 1\n    if truck_weights:              # **is not None list**\n        if bridge_weight + truck_weights[0] <= weight:  #대기열 첫째 무게와 현재 다리의 무게를 더해서 가능한 무게 이하인경우\n            left = truck_weights.popleft()              #대기열 첫번째 index를 bridge로 append, 무게 갱신한다.\n            bridge_weight += left\n            bridge.append(left)",
        "detail": "9rogramers.bridge_pass",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.carpet",
        "description": "9rogramers.carpet",
        "peekOfCode": "def solution(brown, yellow):\n    total = brown + yellow\n    for i in range(1, int(total**0.5) + 1):\n        if total % i == 0:\n            width = total // i\n            height = i\n            if (width - 2) * (height - 2) == yellow:\n                return [width, height]",
        "detail": "9rogramers.carpet",
        "documentation": {}
    },
    {
        "label": "lottos",
        "kind": 5,
        "importPath": "9rogramers.dev1",
        "description": "9rogramers.dev1",
        "peekOfCode": "lottos = [44, 1, 0, 0, 31, 25]\nwin_nums = [31, 10, 45, 1, 6, 19]\ncnt = 0  # 당첨된 번호의 갯수\nmolru = lottos.count(0)\nfor i in range(len(lottos)):\n    if lottos[i] in win_nums:\n        cnt += 1\n# 0의 갯수 만큼 더 당첨될 수 있다.\n# 그 중에 최고 겹치는수와 최고 안겹치는 수를 골라라.\nlucky, unlucky = 0, 0",
        "detail": "9rogramers.dev1",
        "documentation": {}
    },
    {
        "label": "win_nums",
        "kind": 5,
        "importPath": "9rogramers.dev1",
        "description": "9rogramers.dev1",
        "peekOfCode": "win_nums = [31, 10, 45, 1, 6, 19]\ncnt = 0  # 당첨된 번호의 갯수\nmolru = lottos.count(0)\nfor i in range(len(lottos)):\n    if lottos[i] in win_nums:\n        cnt += 1\n# 0의 갯수 만큼 더 당첨될 수 있다.\n# 그 중에 최고 겹치는수와 최고 안겹치는 수를 골라라.\nlucky, unlucky = 0, 0\nif cnt <= 1:",
        "detail": "9rogramers.dev1",
        "documentation": {}
    },
    {
        "label": "cnt",
        "kind": 5,
        "importPath": "9rogramers.dev1",
        "description": "9rogramers.dev1",
        "peekOfCode": "cnt = 0  # 당첨된 번호의 갯수\nmolru = lottos.count(0)\nfor i in range(len(lottos)):\n    if lottos[i] in win_nums:\n        cnt += 1\n# 0의 갯수 만큼 더 당첨될 수 있다.\n# 그 중에 최고 겹치는수와 최고 안겹치는 수를 골라라.\nlucky, unlucky = 0, 0\nif cnt <= 1:\n    unlucky = 6",
        "detail": "9rogramers.dev1",
        "documentation": {}
    },
    {
        "label": "molru",
        "kind": 5,
        "importPath": "9rogramers.dev1",
        "description": "9rogramers.dev1",
        "peekOfCode": "molru = lottos.count(0)\nfor i in range(len(lottos)):\n    if lottos[i] in win_nums:\n        cnt += 1\n# 0의 갯수 만큼 더 당첨될 수 있다.\n# 그 중에 최고 겹치는수와 최고 안겹치는 수를 골라라.\nlucky, unlucky = 0, 0\nif cnt <= 1:\n    unlucky = 6\nelif cnt == 2:",
        "detail": "9rogramers.dev1",
        "documentation": {}
    },
    {
        "label": "answer",
        "kind": 5,
        "importPath": "9rogramers.dev1",
        "description": "9rogramers.dev1",
        "peekOfCode": "answer = [lucky, unlucky]",
        "detail": "9rogramers.dev1",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "9rogramers.dfs_travelroute",
        "description": "9rogramers.dfs_travelroute",
        "peekOfCode": "def dfs(s):\n    while graph[s]:\n        a=graph[s].pop(0)\n        print('while graph[s] pop(0)',a)\n        print('graph',graph)\n        dfs(a)\n    answer.append(s)\n    print('if not graph : ',s)\n    return\ndef solution(tickets):",
        "detail": "9rogramers.dfs_travelroute",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.dfs_travelroute",
        "description": "9rogramers.dfs_travelroute",
        "peekOfCode": "def solution(tickets):\n    for a,b in tickets:\n        graph[a].append(b)\n        print('graph for first : ',graph)\n    for a, b in graph.items():  #딕셔너리를 튜플형태\n        graph[a].sort()\n        print('graph: for items ',graph)\n    dfs(\"ICN\")\n    return answer[::-1]\ntickets = [[\"ICN\", \"SFO\"], [\"ICN\", \"ATL\"], [\"SFO\", \"ATL\"], [\"ATL\",\"SFO\"],[\"ATL\", \"ICN\"]]",
        "detail": "9rogramers.dfs_travelroute",
        "documentation": {}
    },
    {
        "label": "answer",
        "kind": 5,
        "importPath": "9rogramers.dfs_travelroute",
        "description": "9rogramers.dfs_travelroute",
        "peekOfCode": "answer = []\ngraph = collections.defaultdict(list)\ndef dfs(s):\n    while graph[s]:\n        a=graph[s].pop(0)\n        print('while graph[s] pop(0)',a)\n        print('graph',graph)\n        dfs(a)\n    answer.append(s)\n    print('if not graph : ',s)",
        "detail": "9rogramers.dfs_travelroute",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "9rogramers.dfs_travelroute",
        "description": "9rogramers.dfs_travelroute",
        "peekOfCode": "graph = collections.defaultdict(list)\ndef dfs(s):\n    while graph[s]:\n        a=graph[s].pop(0)\n        print('while graph[s] pop(0)',a)\n        print('graph',graph)\n        dfs(a)\n    answer.append(s)\n    print('if not graph : ',s)\n    return",
        "detail": "9rogramers.dfs_travelroute",
        "documentation": {}
    },
    {
        "label": "tickets",
        "kind": 5,
        "importPath": "9rogramers.dfs_travelroute",
        "description": "9rogramers.dfs_travelroute",
        "peekOfCode": "tickets = [[\"ICN\", \"SFO\"], [\"ICN\", \"ATL\"], [\"SFO\", \"ATL\"], [\"ATL\",\"SFO\"],[\"ATL\", \"ICN\"]]\nprint(solution(tickets))",
        "detail": "9rogramers.dfs_travelroute",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.dfs_virus",
        "description": "9rogramers.dfs_virus",
        "peekOfCode": "def solution(rows, columns, max_virus, queries):\n    # result = [[0 for _ in range(columns)] for _ in range(rows)]\n    result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    # 상 하 좌 우\n    drow = [-1, 1, 0, 0]\n    dcol = [0, 0, -1, 1]\n    def dfs(row, col):\n        for j in range(4):  # 찍은 좌표가 맥스와 같거나 더 큰경우\n            targetRow = row + drow[j]\n            targetCol = col + dcol[j]",
        "detail": "9rogramers.dfs_virus",
        "documentation": {}
    },
    {
        "label": "rows",
        "kind": 5,
        "importPath": "9rogramers.dfs_virus",
        "description": "9rogramers.dfs_virus",
        "peekOfCode": "rows = 3\ncolumns = 4\nmax_virus = 2\nqueries = [[3, 2], [3, 2], [2, 2], [3, 2], [1, 4], [3, 2], [2, 3], [3, 1]]\nsolution(rows, columns, max_virus, queries)",
        "detail": "9rogramers.dfs_virus",
        "documentation": {}
    },
    {
        "label": "columns",
        "kind": 5,
        "importPath": "9rogramers.dfs_virus",
        "description": "9rogramers.dfs_virus",
        "peekOfCode": "columns = 4\nmax_virus = 2\nqueries = [[3, 2], [3, 2], [2, 2], [3, 2], [1, 4], [3, 2], [2, 3], [3, 1]]\nsolution(rows, columns, max_virus, queries)",
        "detail": "9rogramers.dfs_virus",
        "documentation": {}
    },
    {
        "label": "max_virus",
        "kind": 5,
        "importPath": "9rogramers.dfs_virus",
        "description": "9rogramers.dfs_virus",
        "peekOfCode": "max_virus = 2\nqueries = [[3, 2], [3, 2], [2, 2], [3, 2], [1, 4], [3, 2], [2, 3], [3, 1]]\nsolution(rows, columns, max_virus, queries)",
        "detail": "9rogramers.dfs_virus",
        "documentation": {}
    },
    {
        "label": "queries",
        "kind": 5,
        "importPath": "9rogramers.dfs_virus",
        "description": "9rogramers.dfs_virus",
        "peekOfCode": "queries = [[3, 2], [3, 2], [2, 2], [3, 2], [1, 4], [3, 2], [2, 3], [3, 1]]\nsolution(rows, columns, max_virus, queries)",
        "detail": "9rogramers.dfs_virus",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.discount",
        "description": "9rogramers.discount",
        "peekOfCode": "def solution(want, number, discount):\n    want_dic=dict(zip(want, number))\n    answer=0\n    #원소의갯수-9번\n    for i in range(len(discount)-9):\n        ten_days_dic = Counter(discount[i:10+i])\n        if ten_days_dic == want_dic:\n            answer+=1\n    return answer\nwant=[\"banana\", \"apple\", \"rice\", \"pork\", \"pot\"]",
        "detail": "9rogramers.discount",
        "documentation": {}
    },
    {
        "label": "count_divisors_num",
        "kind": 2,
        "importPath": "9rogramers.divisors",
        "description": "9rogramers.divisors",
        "peekOfCode": "def count_divisors_num(num):\n    divisors=[]\n    for i in range(1,num//2+1):\n        if num%i==0:\n            divisors.append(i)\n    return len(divisors)+1\nleft =13\nright =17\nanswer=0\nfor i in range(left,right+1):",
        "detail": "9rogramers.divisors",
        "documentation": {}
    },
    {
        "label": "fibo",
        "kind": 2,
        "importPath": "9rogramers.fibo",
        "description": "9rogramers.fibo",
        "peekOfCode": "def fibo(n):\n    fib = [0,1]\n    for i in range(2,n+1):\n        fib.append(fib[i-1]+fib[i-2])\n    return fib[n]\nn=5\nprint(fibo(n)%1234567)",
        "detail": "9rogramers.fibo",
        "documentation": {}
    },
    {
        "label": "count_ways_to_make_n",
        "kind": 2,
        "importPath": "9rogramers.frog_jump",
        "description": "9rogramers.frog_jump",
        "peekOfCode": "def count_ways_to_make_n(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    ways = [0] * (n + 1)\n    ways[0] = 1 \n    ways[1] = 1 \n    for i in range(2, n + 1):\n        ways[i] = ways[i - 1] + ways[i - 2]",
        "detail": "9rogramers.frog_jump",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "9rogramers.frog_jump",
        "description": "9rogramers.frog_jump",
        "peekOfCode": "n = 4\nprint(count_ways_to_make_n(n))",
        "detail": "9rogramers.frog_jump",
        "documentation": {}
    },
    {
        "label": "separate_patterns",
        "kind": 2,
        "importPath": "9rogramers.game_star",
        "description": "9rogramers.game_star",
        "peekOfCode": "def separate_patterns(pattern):\n    pattern_regex = r'(\\d+[a-zA-Z]+|[*#])'\n    separated = re.findall(pattern_regex, pattern)\n    return separated\n# 예시 문자열\ns = \"1D2S#10S\"\nscores = separate_patterns(s)\nspecial = ['#','*']\nbonus_dict={\n    'S':1,",
        "detail": "9rogramers.game_star",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "9rogramers.game_star",
        "description": "9rogramers.game_star",
        "peekOfCode": "s = \"1D2S#10S\"\nscores = separate_patterns(s)\nspecial = ['#','*']\nbonus_dict={\n    'S':1,\n    'D':2,\n    'T':3,\n}\npoints=[]\nfor score in scores:",
        "detail": "9rogramers.game_star",
        "documentation": {}
    },
    {
        "label": "scores",
        "kind": 5,
        "importPath": "9rogramers.game_star",
        "description": "9rogramers.game_star",
        "peekOfCode": "scores = separate_patterns(s)\nspecial = ['#','*']\nbonus_dict={\n    'S':1,\n    'D':2,\n    'T':3,\n}\npoints=[]\nfor score in scores:\n    if score in special:",
        "detail": "9rogramers.game_star",
        "documentation": {}
    },
    {
        "label": "special",
        "kind": 5,
        "importPath": "9rogramers.game_star",
        "description": "9rogramers.game_star",
        "peekOfCode": "special = ['#','*']\nbonus_dict={\n    'S':1,\n    'D':2,\n    'T':3,\n}\npoints=[]\nfor score in scores:\n    if score in special:\n        if score=='#':",
        "detail": "9rogramers.game_star",
        "documentation": {}
    },
    {
        "label": "hanoi",
        "kind": 2,
        "importPath": "9rogramers.hanoi",
        "description": "9rogramers.hanoi",
        "peekOfCode": "def hanoi(n, start, end):\n    answer = []\n    hanoi_sub(n, start, end, 2, answer)\n    return answer\ndef hanoi_sub(n, start, end, other, answer):\n    if n == 1:\n        answer.append((start, end))\n    else:\n        hanoi_sub(n - 1, start, other, end, answer)\n        answer.append((start, end))",
        "detail": "9rogramers.hanoi",
        "documentation": {}
    },
    {
        "label": "hanoi_sub",
        "kind": 2,
        "importPath": "9rogramers.hanoi",
        "description": "9rogramers.hanoi",
        "peekOfCode": "def hanoi_sub(n, start, end, other, answer):\n    if n == 1:\n        answer.append((start, end))\n    else:\n        hanoi_sub(n - 1, start, other, end, answer)\n        answer.append((start, end))\n        hanoi_sub(n - 1, other, end, start, answer)\nn = 3\nprint(hanoi(n, 1, 3))\n# def hanoi(num_discs, source, target, auxiliary):",
        "detail": "9rogramers.hanoi",
        "documentation": {}
    },
    {
        "label": "hanoi",
        "kind": 2,
        "importPath": "9rogramers.hanoi",
        "description": "9rogramers.hanoi",
        "peekOfCode": "def hanoi(n,start,end):\n    answer=[]\n    hanoi_dfs(n,start,end,2,answer)\n    return answer\ndef hanoi_dfs(n,start,end,sub,answer):\n    if n==1:\n        answer.append([start,end])\n    else:\n        hanoi_dfs(n-1,start,sub,end,answer)\n        answer.append([start,end])",
        "detail": "9rogramers.hanoi",
        "documentation": {}
    },
    {
        "label": "hanoi_dfs",
        "kind": 2,
        "importPath": "9rogramers.hanoi",
        "description": "9rogramers.hanoi",
        "peekOfCode": "def hanoi_dfs(n,start,end,sub,answer):\n    if n==1:\n        answer.append([start,end])\n    else:\n        hanoi_dfs(n-1,start,sub,end,answer)\n        answer.append([start,end])\n        hanoi_dfs(n-1,sub,end,start,answer)\ndef solution(n):\n    return hanoi(n,1,3)\nprint(solution(3))",
        "detail": "9rogramers.hanoi",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.hanoi",
        "description": "9rogramers.hanoi",
        "peekOfCode": "def solution(n):\n    return hanoi(n,1,3)\nprint(solution(3))",
        "detail": "9rogramers.hanoi",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "9rogramers.hanoi",
        "description": "9rogramers.hanoi",
        "peekOfCode": "n = 3\nprint(hanoi(n, 1, 3))\n# def hanoi(num_discs, source, target, auxiliary):\n#     stack = [(num_discs, source, target, auxiliary)]\n#     moves = []\n#     while stack:\n#         print(stack[0][1],stack[0][2])\n#         discs, src, dest, aux = stack.pop()\n#         if discs == 1:\n#             moves.append((src, dest))",
        "detail": "9rogramers.hanoi",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.hash",
        "description": "9rogramers.hash",
        "peekOfCode": "def solution(participant, completion):\n    d={}\n    for x in participant:\n        d[x] = d.get(x,0)+1\n    for x in completion:\n        d[x] -= 1\n    answer = ''\n    for key,val in d.items():\n        if val > 0:\n            answer=key",
        "detail": "9rogramers.hash",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "9rogramers.hash2",
        "description": "9rogramers.hash2",
        "peekOfCode": "nums = [3,3,3,2,2,4]\nnums = [3,1,2,3]\nquantity = int(len(nums)/2)\nif len(nums)==1:\n    answer=1\nelif quantity <= len(set(nums)):\n    answer=quantity\nelse:\n    answer=len(set(nums))\nprint(answer)",
        "detail": "9rogramers.hash2",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "9rogramers.hash2",
        "description": "9rogramers.hash2",
        "peekOfCode": "nums = [3,1,2,3]\nquantity = int(len(nums)/2)\nif len(nums)==1:\n    answer=1\nelif quantity <= len(set(nums)):\n    answer=quantity\nelse:\n    answer=len(set(nums))\nprint(answer)",
        "detail": "9rogramers.hash2",
        "documentation": {}
    },
    {
        "label": "quantity",
        "kind": 5,
        "importPath": "9rogramers.hash2",
        "description": "9rogramers.hash2",
        "peekOfCode": "quantity = int(len(nums)/2)\nif len(nums)==1:\n    answer=1\nelif quantity <= len(set(nums)):\n    answer=quantity\nelse:\n    answer=len(set(nums))\nprint(answer)",
        "detail": "9rogramers.hash2",
        "documentation": {}
    },
    {
        "label": "participant",
        "kind": 5,
        "importPath": "9rogramers.hash3",
        "description": "9rogramers.hash3",
        "peekOfCode": "participant = [\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"]\ncompletion = [\"josipa\", \"filipa\", \"marina\", \"nikola\"]\np_dict={}\nfor p in participant:\n    if p in p_dict:\n        p_dict[p] += 1\n    else:\n        p_dict[p] = 1\nfor c in completion:\n    p_dict[c] -=1",
        "detail": "9rogramers.hash3",
        "documentation": {}
    },
    {
        "label": "completion",
        "kind": 5,
        "importPath": "9rogramers.hash3",
        "description": "9rogramers.hash3",
        "peekOfCode": "completion = [\"josipa\", \"filipa\", \"marina\", \"nikola\"]\np_dict={}\nfor p in participant:\n    if p in p_dict:\n        p_dict[p] += 1\n    else:\n        p_dict[p] = 1\nfor c in completion:\n    p_dict[c] -=1\nfor k,v in p_dict.items():",
        "detail": "9rogramers.hash3",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.hash4",
        "description": "9rogramers.hash4",
        "peekOfCode": "def solution(phone_book):\n    p_dict = {}\n    phone_book.sort()\n    for phone in phone_book:\n        for i in range(1, len(phone)):\n            prefix = phone[:i]\n            if prefix in p_dict:\n                return False\n        p_dict[phone] = 1\n    return True",
        "detail": "9rogramers.hash4",
        "documentation": {}
    },
    {
        "label": "phone_book",
        "kind": 5,
        "importPath": "9rogramers.hash4",
        "description": "9rogramers.hash4",
        "peekOfCode": "phone_book = [\"119\", \"97674223\", \"1195524421\"]\np_dict={}\nanswer=0\nfor p in phone_book:\n    p_dict[p]=0\nfor phone in phone_book:\n    for k,v in p_dict.items():\n        print('phone',phone)\n        print('k[:len(phone)]',k[:len(phone)])\n        if k != phone and k[:len(phone)] == phone:",
        "detail": "9rogramers.hash4",
        "documentation": {}
    },
    {
        "label": "clothes",
        "kind": 5,
        "importPath": "9rogramers.hash5",
        "description": "9rogramers.hash5",
        "peekOfCode": "clothes = [[\"yellow_hat\", \"headgear\"], [\"blue_sunglasses\", \"eyewear\"], [\"green_turban\", \"headgear\"]]\nclothes_dict={}\nanswer=1\nfor cloth in clothes:\n    if cloth[1] not in clothes_dict:\n        clothes_dict[cloth[1]]=[cloth[0]]\n    else:\n        clothes_dict[cloth[1]].append(cloth[0])\n# none이있다고 생각하면\nfor k,v in clothes_dict.items():",
        "detail": "9rogramers.hash5",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.heap_disk",
        "description": "9rogramers.heap_disk",
        "peekOfCode": "def solution(jobs):\n    answer, now, i = 0, 0, 0\n    start = -1\n    heap = []\n    # [[0, 3], [1, 9], [2, 6]]\n    while i < len(jobs):  # 현재 시점에서 처리할 수 있는 작업을 heap에 저장\n        for j in jobs:\n            if start < j[0] <= now:\n                heapq.heappush(heap, [j[1], j[0]])\n        if len(heap) > 0:  # 처리할 작업이 있는 경우",
        "detail": "9rogramers.heap_disk",
        "documentation": {}
    },
    {
        "label": "jobs",
        "kind": 5,
        "importPath": "9rogramers.heap_disk",
        "description": "9rogramers.heap_disk",
        "peekOfCode": "jobs = [[0, 3], [1, 9], [2, 6]]\nsolution(jobs)\n# from collections import deque\n#\n# jobs = [[0, 3], [1, 9], [2, 6]]\n# # [input_time, runtime]\n# queue = deque(jobs)\n# # 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.\n# wait=0\n# time = queue[0][1]",
        "detail": "9rogramers.heap_disk",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.heap_morespicy",
        "description": "9rogramers.heap_morespicy",
        "peekOfCode": "def solution(scoville, K):\n    answer = 0\n    heapq.heapify(scoville)\n    for _ in range(len(scoville) - 1):\n        a = heapq.heappop(scoville)\n        b = heapq.heappop(scoville)\n        c = a + 2 * b\n        heapq.heappush(scoville, c)\n        answer += 1\n        if scoville[0] >= K:",
        "detail": "9rogramers.heap_morespicy",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.h_index",
        "description": "9rogramers.h_index",
        "peekOfCode": "def solution(citations):\n    # h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용된 h중에 최대값\n    # list = [0, 1, 3, 5, 6]\n    # 0번이상 인용된 논문 5, 나머지0 조건충족 temp=0\n    # 1번이상 인용된 논문 4, 나머지1 조건충족 temp=1\n    # 2번이상 인용된 논문 3, 나머지2 조건충족 temp=2\n    # 3번이상 인용된 논문 3, 나머지2 조건충족 temp=3\n    # 4번이상 인용된 논문 2, 나머지3 조건불충족\n    citations.sort()\n    temp=0",
        "detail": "9rogramers.h_index",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.jaden_case",
        "description": "9rogramers.jaden_case",
        "peekOfCode": "def solution(s):\n    s_list = s.split(' ')\n    pattern = r'^[0-9]'\n    answer = ''\n    for word in s_list:\n        if word and re.match(pattern, word[0]):\n            if len(word) > 1:\n                answer += word[0] + word[1:].lower() + ' '\n            else:\n                answer += word + ' '",
        "detail": "9rogramers.jaden_case",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "9rogramers.jaden_case",
        "description": "9rogramers.jaden_case",
        "peekOfCode": "s = \"3people unFollowed me\"\ndef solution(s):\n    s_list = s.split(' ')\n    pattern = r'^[0-9]'\n    answer = ''\n    for word in s_list:\n        if word and re.match(pattern, word[0]):\n            if len(word) > 1:\n                answer += word[0] + word[1:].lower() + ' '\n            else:",
        "detail": "9rogramers.jaden_case",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.jump_tp",
        "description": "9rogramers.jump_tp",
        "peekOfCode": "def solution(n):\n    count=1\n    while n!=1:\n        if n%2 == 0:\n            n/=2\n        else:\n            n-=1\n            count+=1\n    return count",
        "detail": "9rogramers.jump_tp",
        "documentation": {}
    },
    {
        "label": "calculate_counts",
        "kind": 2,
        "importPath": "9rogramers.kakao_winter",
        "description": "9rogramers.kakao_winter",
        "peekOfCode": "def calculate_counts(table,gifts):\n    for gift in gifts:\n        gift = gift.split(\" \")\n        giver = friends.index(gift[0])\n        getter = friends.index(gift[1])\n        table[giver][getter] += 1\n    return table\ndef calculate_gift_points(table):\n    gift_points=[]\n    for i in range(len(table)):",
        "detail": "9rogramers.kakao_winter",
        "documentation": {}
    },
    {
        "label": "calculate_gift_points",
        "kind": 2,
        "importPath": "9rogramers.kakao_winter",
        "description": "9rogramers.kakao_winter",
        "peekOfCode": "def calculate_gift_points(table):\n    gift_points=[]\n    for i in range(len(table)):\n        gift_points.append(sum(table[i]))\n    for j in range(len(table)):\n        for k in range(len(table)):\n            if j!=k:\n                gift_points[j] -= table[k][j]\n    return gift_points\ndef solution(friends,gifts):",
        "detail": "9rogramers.kakao_winter",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.kakao_winter",
        "description": "9rogramers.kakao_winter",
        "peekOfCode": "def solution(friends,gifts):\n    # create table\n    table = []\n    for i in range(len(friends)):\n        table.append([0] * len(friends))\n    # calculate gifts\n    table = calculate_counts(table,gifts)\n    # calculate_gift_points\n    gift_points = calculate_gift_points(table)\n    next_month=[0]*len(table)",
        "detail": "9rogramers.kakao_winter",
        "documentation": {}
    },
    {
        "label": "friends",
        "kind": 5,
        "importPath": "9rogramers.kakao_winter",
        "description": "9rogramers.kakao_winter",
        "peekOfCode": "friends = [\"muzi\", \"ryan\", \"frodo\", \"neo\"]\ngifts = [\"muzi frodo\", \"muzi frodo\", \"ryan muzi\", \"ryan muzi\", \"ryan muzi\", \"frodo muzi\", \"frodo ryan\", \"neo muzi\"]\ndef calculate_counts(table,gifts):\n    for gift in gifts:\n        gift = gift.split(\" \")\n        giver = friends.index(gift[0])\n        getter = friends.index(gift[1])\n        table[giver][getter] += 1\n    return table\ndef calculate_gift_points(table):",
        "detail": "9rogramers.kakao_winter",
        "documentation": {}
    },
    {
        "label": "gifts",
        "kind": 5,
        "importPath": "9rogramers.kakao_winter",
        "description": "9rogramers.kakao_winter",
        "peekOfCode": "gifts = [\"muzi frodo\", \"muzi frodo\", \"ryan muzi\", \"ryan muzi\", \"ryan muzi\", \"frodo muzi\", \"frodo ryan\", \"neo muzi\"]\ndef calculate_counts(table,gifts):\n    for gift in gifts:\n        gift = gift.split(\" \")\n        giver = friends.index(gift[0])\n        getter = friends.index(gift[1])\n        table[giver][getter] += 1\n    return table\ndef calculate_gift_points(table):\n    gift_points=[]",
        "detail": "9rogramers.kakao_winter",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": "9rogramers.make_min",
        "description": "9rogramers.make_min",
        "peekOfCode": "A = [1, 4, 2]\nB = [5, 4, 4]\nA.sort()\nB.sort(reverse=True)\ntemp=0\nfor i in range(len(A)):\n    temp += A[i]*B[i]\nprint(temp)",
        "detail": "9rogramers.make_min",
        "documentation": {}
    },
    {
        "label": "B",
        "kind": 5,
        "importPath": "9rogramers.make_min",
        "description": "9rogramers.make_min",
        "peekOfCode": "B = [5, 4, 4]\nA.sort()\nB.sort(reverse=True)\ntemp=0\nfor i in range(len(A)):\n    temp += A[i]*B[i]\nprint(temp)",
        "detail": "9rogramers.make_min",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.matrix_multiple",
        "description": "9rogramers.matrix_multiple",
        "peekOfCode": "def solution(arr1, arr2):\n    answer = []\n    # 행렬곱 => 1번째 arr의 n번째 행의 원소의 갯수만큼 덧셈이 이루어짐\n    # 1번째 arr의 [n행] x 2번째 arr2의 [n열]의 합 = answer 의 (n,n) 의 값이 된다.\n    # sum of arr1[x,i]*arr2[i,y]\n    # 행렬곱은 [i*j] * [j*k] 의 형태로만 일어날 수 있다.\n    # j만큼 덧셈이 일어나고, i만큼 행의 갯수,k만큼 열의 갯수가 된다.\n    rows=len(arr1)\n    cols=len(arr2[0])\n    cal_count=len(arr1[0])",
        "detail": "9rogramers.matrix_multiple",
        "documentation": {}
    },
    {
        "label": "arr1",
        "kind": 5,
        "importPath": "9rogramers.matrix_multiple",
        "description": "9rogramers.matrix_multiple",
        "peekOfCode": "arr1 = np.array([[1, 4], [3, 2], [4, 1]])\narr2 = np.array([[3, 3], [3, 3]])\nresult = np.dot(arr1, arr2)\nprint(result)",
        "detail": "9rogramers.matrix_multiple",
        "documentation": {}
    },
    {
        "label": "arr2",
        "kind": 5,
        "importPath": "9rogramers.matrix_multiple",
        "description": "9rogramers.matrix_multiple",
        "peekOfCode": "arr2 = np.array([[3, 3], [3, 3]])\nresult = np.dot(arr1, arr2)\nprint(result)",
        "detail": "9rogramers.matrix_multiple",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "9rogramers.matrix_multiple",
        "description": "9rogramers.matrix_multiple",
        "peekOfCode": "result = np.dot(arr1, arr2)\nprint(result)",
        "detail": "9rogramers.matrix_multiple",
        "documentation": {}
    },
    {
        "label": "gcd",
        "kind": 2,
        "importPath": "9rogramers.min_common_multiple",
        "description": "9rogramers.min_common_multiple",
        "peekOfCode": "def gcd(a, b):\n    \"\"\"두 수의 최대공약수를 구하는 함수\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\ndef lcm(a, b):\n    \"\"\"두 수의 최소공배수를 구하는 함수\"\"\"\n    return a * b // gcd(a, b)\narr=[2,6,8,14]\na_before=arr[0]",
        "detail": "9rogramers.min_common_multiple",
        "documentation": {}
    },
    {
        "label": "lcm",
        "kind": 2,
        "importPath": "9rogramers.min_common_multiple",
        "description": "9rogramers.min_common_multiple",
        "peekOfCode": "def lcm(a, b):\n    \"\"\"두 수의 최소공배수를 구하는 함수\"\"\"\n    return a * b // gcd(a, b)\narr=[2,6,8,14]\na_before=arr[0]\nfor a in arr[1:]:\n    a_after=a\n    a_before = lcm(a_before,a_after)",
        "detail": "9rogramers.min_common_multiple",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "9rogramers.min_max",
        "description": "9rogramers.min_max",
        "peekOfCode": "s = \"-1 -2 -3 -4\"\ns_list = s.split(' ')\nfor i in range(len(s_list)):\n    s_list[i]=int(s_list[i])\ns_list.sort()\nanswer = str(s_list[0]) + ' ' + str(s_list[-1])",
        "detail": "9rogramers.min_max",
        "documentation": {}
    },
    {
        "label": "s_list",
        "kind": 5,
        "importPath": "9rogramers.min_max",
        "description": "9rogramers.min_max",
        "peekOfCode": "s_list = s.split(' ')\nfor i in range(len(s_list)):\n    s_list[i]=int(s_list[i])\ns_list.sort()\nanswer = str(s_list[0]) + ' ' + str(s_list[-1])",
        "detail": "9rogramers.min_max",
        "documentation": {}
    },
    {
        "label": "answer",
        "kind": 5,
        "importPath": "9rogramers.min_max",
        "description": "9rogramers.min_max",
        "peekOfCode": "answer = str(s_list[0]) + ' ' + str(s_list[-1])",
        "detail": "9rogramers.min_max",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.move_length",
        "description": "9rogramers.move_length",
        "peekOfCode": "def solution(dirs):\n    mypos = [5, 5]\n    cnt = 0\n    # 로직2) route값을 저장해야함.\n    # route=[None]*len(dirs)*2\n    route = []\n    # x>nx로 간 정보를 리스트로 저장해서 리스트안에 없다면 cnt++\n    # 로직3) dirs[i]에 대한 딕셔너리 생성 U:(1,0) ... 이런식으로\n    move = {  # row col\n        'U': [-1, 0], 'D': [1, 0], 'R': [0, 1], 'L': [0, -1]",
        "detail": "9rogramers.move_length",
        "documentation": {}
    },
    {
        "label": "dirs",
        "kind": 5,
        "importPath": "9rogramers.move_length",
        "description": "9rogramers.move_length",
        "peekOfCode": "dirs = 'UUUUUUUU'\nsolution(dirs)\n##################################################################################\n#\n# from collections import defaultdict\n#\n#\n# def solution(dirs):\n#     mypos = [5, 5]\n#     cnt = 0",
        "detail": "9rogramers.move_length",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "9rogramers.next_large",
        "description": "9rogramers.next_large",
        "peekOfCode": "n = 78\nb_n = list(bin(n)[2:])\nwhile True:\n    n+=1\n    next_b_n=list(bin(n)[2:])\n    if b_n.count('1') == next_b_n.count('1'):\n        break\nprint(n)",
        "detail": "9rogramers.next_large",
        "documentation": {}
    },
    {
        "label": "b_n",
        "kind": 5,
        "importPath": "9rogramers.next_large",
        "description": "9rogramers.next_large",
        "peekOfCode": "b_n = list(bin(n)[2:])\nwhile True:\n    n+=1\n    next_b_n=list(bin(n)[2:])\n    if b_n.count('1') == next_b_n.count('1'):\n        break\nprint(n)",
        "detail": "9rogramers.next_large",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.openchat",
        "description": "9rogramers.openchat",
        "peekOfCode": "def solution(record):\n    temp=[]\n    answer = []\n    dic={}\n    for i in range(len(record)):\n        temp.append(record[i].split())\n        if len(temp[i])==3:\n            dic[temp[i][1]]=temp[i][2]\n    # print(temp)\n    for i in temp:",
        "detail": "9rogramers.openchat",
        "documentation": {}
    },
    {
        "label": "bandage",
        "kind": 5,
        "importPath": "9rogramers.pccp",
        "description": "9rogramers.pccp",
        "peekOfCode": "bandage = [5,1,5] # 시전시간 초당회복량 추가회복량 t x y\nattacks =[[2, 10], [9, 15], [10, 5], [11, 5]] # 공격시간,피해량\nhealth = 30 #체력 /최대체력이상불가능\nmax_health = health\npass_count = 0\ntime = attacks[-1][0]\n# 시간은 흘러간다.\n# 공격이 있는 시간이 아니라면 pass_count와 health상승한다. health는 최대체력이상 불가능, 공격 데미지가 현재 체력을 넘으면 return -1\nnext_attack = attacks.pop(0)\nfor i in range(1,time+1):",
        "detail": "9rogramers.pccp",
        "documentation": {}
    },
    {
        "label": "health",
        "kind": 5,
        "importPath": "9rogramers.pccp",
        "description": "9rogramers.pccp",
        "peekOfCode": "health = 30 #체력 /최대체력이상불가능\nmax_health = health\npass_count = 0\ntime = attacks[-1][0]\n# 시간은 흘러간다.\n# 공격이 있는 시간이 아니라면 pass_count와 health상승한다. health는 최대체력이상 불가능, 공격 데미지가 현재 체력을 넘으면 return -1\nnext_attack = attacks.pop(0)\nfor i in range(1,time+1):\n    print(\"*\"*20)\n    if next_attack[0] > i: # 공격이 없을 때",
        "detail": "9rogramers.pccp",
        "documentation": {}
    },
    {
        "label": "max_health",
        "kind": 5,
        "importPath": "9rogramers.pccp",
        "description": "9rogramers.pccp",
        "peekOfCode": "max_health = health\npass_count = 0\ntime = attacks[-1][0]\n# 시간은 흘러간다.\n# 공격이 있는 시간이 아니라면 pass_count와 health상승한다. health는 최대체력이상 불가능, 공격 데미지가 현재 체력을 넘으면 return -1\nnext_attack = attacks.pop(0)\nfor i in range(1,time+1):\n    print(\"*\"*20)\n    if next_attack[0] > i: # 공격이 없을 때\n        pass_count += 1",
        "detail": "9rogramers.pccp",
        "documentation": {}
    },
    {
        "label": "pass_count",
        "kind": 5,
        "importPath": "9rogramers.pccp",
        "description": "9rogramers.pccp",
        "peekOfCode": "pass_count = 0\ntime = attacks[-1][0]\n# 시간은 흘러간다.\n# 공격이 있는 시간이 아니라면 pass_count와 health상승한다. health는 최대체력이상 불가능, 공격 데미지가 현재 체력을 넘으면 return -1\nnext_attack = attacks.pop(0)\nfor i in range(1,time+1):\n    print(\"*\"*20)\n    if next_attack[0] > i: # 공격이 없을 때\n        pass_count += 1\n        health += bandage[1]",
        "detail": "9rogramers.pccp",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 5,
        "importPath": "9rogramers.pccp",
        "description": "9rogramers.pccp",
        "peekOfCode": "time = attacks[-1][0]\n# 시간은 흘러간다.\n# 공격이 있는 시간이 아니라면 pass_count와 health상승한다. health는 최대체력이상 불가능, 공격 데미지가 현재 체력을 넘으면 return -1\nnext_attack = attacks.pop(0)\nfor i in range(1,time+1):\n    print(\"*\"*20)\n    if next_attack[0] > i: # 공격이 없을 때\n        pass_count += 1\n        health += bandage[1]\n        if pass_count >= bandage[0]:",
        "detail": "9rogramers.pccp",
        "documentation": {}
    },
    {
        "label": "next_attack",
        "kind": 5,
        "importPath": "9rogramers.pccp",
        "description": "9rogramers.pccp",
        "peekOfCode": "next_attack = attacks.pop(0)\nfor i in range(1,time+1):\n    print(\"*\"*20)\n    if next_attack[0] > i: # 공격이 없을 때\n        pass_count += 1\n        health += bandage[1]\n        if pass_count >= bandage[0]:\n            health += bandage[2]\n        if health >= max_health:\n            health = max_health",
        "detail": "9rogramers.pccp",
        "documentation": {}
    },
    {
        "label": "target_color",
        "kind": 5,
        "importPath": "9rogramers.pccp2",
        "description": "9rogramers.pccp2",
        "peekOfCode": "target_color = board[h][w]\nmoving_axis = [[-1,0],[1,0],[0,-1],[0,1]] #상 하 좌 우\ncount =0 \nfor i in range(4):\n    if h+moving_axis[i][0] < 0 or w+moving_axis[i][1] < 0 or h+moving_axis[i][0] >= len(board) or w+moving_axis[i][1] >= len(board):\n        pass\n    else:\n        if target_color == board[h+moving_axis[i][0]][w+moving_axis[i][1]]:\n            count += 1\nprint('count',count)",
        "detail": "9rogramers.pccp2",
        "documentation": {}
    },
    {
        "label": "moving_axis",
        "kind": 5,
        "importPath": "9rogramers.pccp2",
        "description": "9rogramers.pccp2",
        "peekOfCode": "moving_axis = [[-1,0],[1,0],[0,-1],[0,1]] #상 하 좌 우\ncount =0 \nfor i in range(4):\n    if h+moving_axis[i][0] < 0 or w+moving_axis[i][1] < 0 or h+moving_axis[i][0] >= len(board) or w+moving_axis[i][1] >= len(board):\n        pass\n    else:\n        if target_color == board[h+moving_axis[i][0]][w+moving_axis[i][1]]:\n            count += 1\nprint('count',count)",
        "detail": "9rogramers.pccp2",
        "documentation": {}
    },
    {
        "label": "filter_func",
        "kind": 2,
        "importPath": "9rogramers.pccp3",
        "description": "9rogramers.pccp3",
        "peekOfCode": "def filter_func(item, ext, val_ext):\n    if ext == 'date':\n        return item[1] <= val_ext\n    elif ext == 'code':\n        return item[0] <= val_ext\n    elif ext == 'maximum':\n        return item[2] <= val_ext\n    elif ext == 'remain':\n        return item[3] <= val_ext\n    else:",
        "detail": "9rogramers.pccp3",
        "documentation": {}
    },
    {
        "label": "sort_func",
        "kind": 2,
        "importPath": "9rogramers.pccp3",
        "description": "9rogramers.pccp3",
        "peekOfCode": "def sort_func(item, ext):\n    if ext == 'date':\n        return item[1]\n    elif ext == 'code':\n        return item[0]\n    elif ext == 'maximum':\n        return item[2]\n    elif ext == 'remain':\n        return item[3]\n    else:",
        "detail": "9rogramers.pccp3",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.pccp3",
        "description": "9rogramers.pccp3",
        "peekOfCode": "def solution(data, ext, val_ext, sort_by):\n    filtered_data = list(filter(lambda x: filter_func(x, ext, val_ext), data))\n    sorted_data = sorted(filtered_data, key=lambda x: sort_func(x, sort_by))\n    return sorted_data",
        "detail": "9rogramers.pccp3",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "9rogramers.pccp3",
        "description": "9rogramers.pccp3",
        "peekOfCode": "data = [[1, 20300104, 100, 80], [2, 20300804, 847, 37], [3, 20300401, 10, 8]]\next = \"date\"\nval_ext = 20300501\nsort_by = 'remain'\ndef filter_func(item, ext, val_ext):\n    if ext == 'date':\n        return item[1] <= val_ext\n    elif ext == 'code':\n        return item[0] <= val_ext\n    elif ext == 'maximum':",
        "detail": "9rogramers.pccp3",
        "documentation": {}
    },
    {
        "label": "ext",
        "kind": 5,
        "importPath": "9rogramers.pccp3",
        "description": "9rogramers.pccp3",
        "peekOfCode": "ext = \"date\"\nval_ext = 20300501\nsort_by = 'remain'\ndef filter_func(item, ext, val_ext):\n    if ext == 'date':\n        return item[1] <= val_ext\n    elif ext == 'code':\n        return item[0] <= val_ext\n    elif ext == 'maximum':\n        return item[2] <= val_ext",
        "detail": "9rogramers.pccp3",
        "documentation": {}
    },
    {
        "label": "val_ext",
        "kind": 5,
        "importPath": "9rogramers.pccp3",
        "description": "9rogramers.pccp3",
        "peekOfCode": "val_ext = 20300501\nsort_by = 'remain'\ndef filter_func(item, ext, val_ext):\n    if ext == 'date':\n        return item[1] <= val_ext\n    elif ext == 'code':\n        return item[0] <= val_ext\n    elif ext == 'maximum':\n        return item[2] <= val_ext\n    elif ext == 'remain':",
        "detail": "9rogramers.pccp3",
        "documentation": {}
    },
    {
        "label": "sort_by",
        "kind": 5,
        "importPath": "9rogramers.pccp3",
        "description": "9rogramers.pccp3",
        "peekOfCode": "sort_by = 'remain'\ndef filter_func(item, ext, val_ext):\n    if ext == 'date':\n        return item[1] <= val_ext\n    elif ext == 'code':\n        return item[0] <= val_ext\n    elif ext == 'maximum':\n        return item[2] <= val_ext\n    elif ext == 'remain':\n        return item[3] <= val_ext",
        "detail": "9rogramers.pccp3",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "9rogramers.pccp4",
        "description": "9rogramers.pccp4",
        "peekOfCode": "def dfs(land, visited, row, col, cnt):\n    if row < 0 or row >= len(land) or col < 0 or col >= len(land[0]) or land[row][col] == 0 or visited[row][col]:\n        return 0\n    visited[row][col] = cnt\n    size = 1\n    size += dfs(land, visited, row + 1, col,cnt)\n    size += dfs(land, visited, row - 1, col,cnt)\n    size += dfs(land, visited, row, col + 1,cnt)\n    size += dfs(land, visited, row, col - 1,cnt)\n    return size",
        "detail": "9rogramers.pccp4",
        "documentation": {}
    },
    {
        "label": "count_connected_components",
        "kind": 2,
        "importPath": "9rogramers.pccp4",
        "description": "9rogramers.pccp4",
        "peekOfCode": "def count_connected_components(land):\n    rows, cols = len(land), len(land[0])\n    visited = [[0 for _ in range(cols)] for _ in range(rows)]\n    cnt = -1\n    target_list = []\n    for i in range(rows):\n        for j in range(cols):\n            if land[i][j] == 1 and not visited[i][j]:\n                component_size = dfs(land, visited, i, j, cnt)\n                target_list.append([cnt,component_size])",
        "detail": "9rogramers.pccp4",
        "documentation": {}
    },
    {
        "label": "land",
        "kind": 5,
        "importPath": "9rogramers.pccp4",
        "description": "9rogramers.pccp4",
        "peekOfCode": "land = [[1, 0, 1, 0, 1, 1], \n        [1, 0, 1, 0, 0, 0], \n        [1, 0, 1, 0, 0, 1], \n        [1, 0, 0, 1, 0, 0], \n        [1, 0, 0, 1, 0, 1],\n        [1, 0, 0, 0, 0, 0], \n        [1, 1, 1, 1, 1, 1]]\ntarget_list, visited = count_connected_components(land)\ntransposed_visited = [list(row) for row in zip(*visited)]\npartial_set_list = []",
        "detail": "9rogramers.pccp4",
        "documentation": {}
    },
    {
        "label": "transposed_visited",
        "kind": 5,
        "importPath": "9rogramers.pccp4",
        "description": "9rogramers.pccp4",
        "peekOfCode": "transposed_visited = [list(row) for row in zip(*visited)]\npartial_set_list = []\nfor i in transposed_visited:\n    partial_set_list.append(set(i))\ntarget_dict = dict(target_list)\ntemp_list=[]\nfor i in range(len(partial_set_list)):\n    temp=0\n    for j in partial_set_list[i]:\n        if j != 0:",
        "detail": "9rogramers.pccp4",
        "documentation": {}
    },
    {
        "label": "partial_set_list",
        "kind": 5,
        "importPath": "9rogramers.pccp4",
        "description": "9rogramers.pccp4",
        "peekOfCode": "partial_set_list = []\nfor i in transposed_visited:\n    partial_set_list.append(set(i))\ntarget_dict = dict(target_list)\ntemp_list=[]\nfor i in range(len(partial_set_list)):\n    temp=0\n    for j in partial_set_list[i]:\n        if j != 0:\n            temp+=target_dict[j]",
        "detail": "9rogramers.pccp4",
        "documentation": {}
    },
    {
        "label": "target_dict",
        "kind": 5,
        "importPath": "9rogramers.pccp4",
        "description": "9rogramers.pccp4",
        "peekOfCode": "target_dict = dict(target_list)\ntemp_list=[]\nfor i in range(len(partial_set_list)):\n    temp=0\n    for j in partial_set_list[i]:\n        if j != 0:\n            temp+=target_dict[j]\n    temp_list.append(temp)\nprint(max(temp_list))",
        "detail": "9rogramers.pccp4",
        "documentation": {}
    },
    {
        "label": "calculate_pin_position",
        "kind": 2,
        "importPath": "9rogramers.pccp5",
        "description": "9rogramers.pccp5",
        "peekOfCode": "def calculate_pin_position(seconds):\n    second_angle = (seconds % 60) * 6\n    minute_angle = (seconds % 3600) / 10\n    hour_angle = (seconds % 43200) / 120\n    return hour_angle, minute_angle, second_angle\ndef count_pin_over(seconds,count):\n    prev_h_pin, prev_m_pin, prev_s_pin = calculate_pin_position(seconds)\n    next_h_pin, next_m_pin, next_s_pin = calculate_pin_position(seconds+1)\n    if prev_s_pin < prev_h_pin: \n        if next_s_pin >= next_h_pin:",
        "detail": "9rogramers.pccp5",
        "documentation": {}
    },
    {
        "label": "count_pin_over",
        "kind": 2,
        "importPath": "9rogramers.pccp5",
        "description": "9rogramers.pccp5",
        "peekOfCode": "def count_pin_over(seconds,count):\n    prev_h_pin, prev_m_pin, prev_s_pin = calculate_pin_position(seconds)\n    next_h_pin, next_m_pin, next_s_pin = calculate_pin_position(seconds+1)\n    if prev_s_pin < prev_h_pin: \n        if next_s_pin >= next_h_pin:\n            count+=1\n    if prev_s_pin < prev_m_pin:\n        if next_s_pin >= next_m_pin:\n            count+=1\n    return count",
        "detail": "9rogramers.pccp5",
        "documentation": {}
    },
    {
        "label": "get_cnt_from_midnight",
        "kind": 2,
        "importPath": "9rogramers.pccp5",
        "description": "9rogramers.pccp5",
        "peekOfCode": "def get_cnt_from_midnight(h, m, s):\n    h_degree = (h * 30 + m * 0.5 + s * 0.5 / 60) % 360\n    m_degree = (m * 6 + s * 0.1) % 360\n    s_degree = s * 6\n    ret = -1\n    if s_degree >= m_degree:\n        ret += 1\n    if s_degree >= h_degree:\n        ret += 1\n    ret += (h * 60 + m) * 2 ",
        "detail": "9rogramers.pccp5",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.pccp5",
        "description": "9rogramers.pccp5",
        "peekOfCode": "def solution(h1, m1, s1, h2, m2, s2):\n    ret = get_cnt_from_midnight(h2, m2, s2) - get_cnt_from_midnight(h1, m1, s1)\n    if (h1 == 0 or h1 == 12) and m1 == 0 and s1 == 0:\n        ret += 1\n    return ret",
        "detail": "9rogramers.pccp5",
        "documentation": {}
    },
    {
        "label": "start_seconds",
        "kind": 5,
        "importPath": "9rogramers.pccp5",
        "description": "9rogramers.pccp5",
        "peekOfCode": "start_seconds = h1*3600 + m1*60 + s1\nend_seconds = h2*3600 + m2*60 + s2\ndef calculate_pin_position(seconds):\n    second_angle = (seconds % 60) * 6\n    minute_angle = (seconds % 3600) / 10\n    hour_angle = (seconds % 43200) / 120\n    return hour_angle, minute_angle, second_angle\ndef count_pin_over(seconds,count):\n    prev_h_pin, prev_m_pin, prev_s_pin = calculate_pin_position(seconds)\n    next_h_pin, next_m_pin, next_s_pin = calculate_pin_position(seconds+1)",
        "detail": "9rogramers.pccp5",
        "documentation": {}
    },
    {
        "label": "end_seconds",
        "kind": 5,
        "importPath": "9rogramers.pccp5",
        "description": "9rogramers.pccp5",
        "peekOfCode": "end_seconds = h2*3600 + m2*60 + s2\ndef calculate_pin_position(seconds):\n    second_angle = (seconds % 60) * 6\n    minute_angle = (seconds % 3600) / 10\n    hour_angle = (seconds % 43200) / 120\n    return hour_angle, minute_angle, second_angle\ndef count_pin_over(seconds,count):\n    prev_h_pin, prev_m_pin, prev_s_pin = calculate_pin_position(seconds)\n    next_h_pin, next_m_pin, next_s_pin = calculate_pin_position(seconds+1)\n    if prev_s_pin < prev_h_pin: ",
        "detail": "9rogramers.pccp5",
        "documentation": {}
    },
    {
        "label": "progresses",
        "kind": 5,
        "importPath": "9rogramers.progress",
        "description": "9rogramers.progress",
        "peekOfCode": "progresses = [95, 90, 99, 99, 80, 99]\nspeeds = [1, 1, 1, 1, 1, 1]\n# 조건1. 가장 왼쪽의 진행도가 100이 되면 pop한다.\n#       >>만약 오른쪽의 진행도가 100이라면 계속해서 같이 pop한다.\n# 조건2. pop한 index의 갯수를 세서 answer list에 넣어준다.\n#       >>만약 answer index의 합과 len이 같아지면 결과값을 리턴한다.\ni = 0\nanswer = []\nday = 1\nwhile sum(answer) != len(progresses):",
        "detail": "9rogramers.progress",
        "documentation": {}
    },
    {
        "label": "speeds",
        "kind": 5,
        "importPath": "9rogramers.progress",
        "description": "9rogramers.progress",
        "peekOfCode": "speeds = [1, 1, 1, 1, 1, 1]\n# 조건1. 가장 왼쪽의 진행도가 100이 되면 pop한다.\n#       >>만약 오른쪽의 진행도가 100이라면 계속해서 같이 pop한다.\n# 조건2. pop한 index의 갯수를 세서 answer list에 넣어준다.\n#       >>만약 answer index의 합과 len이 같아지면 결과값을 리턴한다.\ni = 0\nanswer = []\nday = 1\nwhile sum(answer) != len(progresses):\n    len_cnt = 0",
        "detail": "9rogramers.progress",
        "documentation": {}
    },
    {
        "label": "i",
        "kind": 5,
        "importPath": "9rogramers.progress",
        "description": "9rogramers.progress",
        "peekOfCode": "i = 0\nanswer = []\nday = 1\nwhile sum(answer) != len(progresses):\n    len_cnt = 0\n    # total = progresses[i] + day * speeds[i]\n    if progresses[i] + day * speeds[i] >= 100:  # 100이 넘어 pop해야 할 경우\n        len_cnt += 1\n        # 다음원소 같이 빼낼지 판단\n        for j in range(i + 1, len(progresses)):  # 포인터 원소가 100이상일 경우, 같이 pop해줄수 있는원소가 몇개 있는지 찾는다.",
        "detail": "9rogramers.progress",
        "documentation": {}
    },
    {
        "label": "answer",
        "kind": 5,
        "importPath": "9rogramers.progress",
        "description": "9rogramers.progress",
        "peekOfCode": "answer = []\nday = 1\nwhile sum(answer) != len(progresses):\n    len_cnt = 0\n    # total = progresses[i] + day * speeds[i]\n    if progresses[i] + day * speeds[i] >= 100:  # 100이 넘어 pop해야 할 경우\n        len_cnt += 1\n        # 다음원소 같이 빼낼지 판단\n        for j in range(i + 1, len(progresses)):  # 포인터 원소가 100이상일 경우, 같이 pop해줄수 있는원소가 몇개 있는지 찾는다.\n            # total_r = progresses[j] + day * speeds[j]",
        "detail": "9rogramers.progress",
        "documentation": {}
    },
    {
        "label": "day",
        "kind": 5,
        "importPath": "9rogramers.progress",
        "description": "9rogramers.progress",
        "peekOfCode": "day = 1\nwhile sum(answer) != len(progresses):\n    len_cnt = 0\n    # total = progresses[i] + day * speeds[i]\n    if progresses[i] + day * speeds[i] >= 100:  # 100이 넘어 pop해야 할 경우\n        len_cnt += 1\n        # 다음원소 같이 빼낼지 판단\n        for j in range(i + 1, len(progresses)):  # 포인터 원소가 100이상일 경우, 같이 pop해줄수 있는원소가 몇개 있는지 찾는다.\n            # total_r = progresses[j] + day * speeds[j]\n            next_pointer = j",
        "detail": "9rogramers.progress",
        "documentation": {}
    },
    {
        "label": "players",
        "kind": 5,
        "importPath": "9rogramers.race",
        "description": "9rogramers.race",
        "peekOfCode": "players = [\"mumu\", \"soe\", \"poe\", \"kai\", \"mine\"]\ncallings=[\"kai\", \"kai\", \"mine\", \"mine\"]\nplayer_dict = {}\nfor i,p in enumerate(players):\n    player_dict[p] = i\nfor call in callings:\n    before_idx = player_dict[call]\n    after_idx = player_dict[call]-1\n    players[before_idx],players[after_idx] = players[after_idx],players[before_idx]\n    player_dict[players[before_idx]],player_dict[players[after_idx]] = player_dict[players[after_idx]] ,player_dict[players[before_idx]]",
        "detail": "9rogramers.race",
        "documentation": {}
    },
    {
        "label": "player_dict",
        "kind": 5,
        "importPath": "9rogramers.race",
        "description": "9rogramers.race",
        "peekOfCode": "player_dict = {}\nfor i,p in enumerate(players):\n    player_dict[p] = i\nfor call in callings:\n    before_idx = player_dict[call]\n    after_idx = player_dict[call]-1\n    players[before_idx],players[after_idx] = players[after_idx],players[before_idx]\n    player_dict[players[before_idx]],player_dict[players[after_idx]] = player_dict[players[after_idx]] ,player_dict[players[before_idx]]",
        "detail": "9rogramers.race",
        "documentation": {}
    },
    {
        "label": "is_valid",
        "kind": 2,
        "importPath": "9rogramers.rotated_s",
        "description": "9rogramers.rotated_s",
        "peekOfCode": "def is_valid(s):\n    stack = []\n    brackets = {'(': ')', '[': ']', '{': '}'}\n    for char in s:\n        if char in brackets.keys():\n            stack.append(char)\n        elif char in brackets.values():\n            if not stack or brackets[stack.pop()] != char:\n                return False\n    return len(stack) == 0",
        "detail": "9rogramers.rotated_s",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.rotated_s",
        "description": "9rogramers.rotated_s",
        "peekOfCode": "def solution(s):\n    count = 0\n    length = len(s)\n    for i in range(length):\n        rotated = s[i:] + s[:i]\n        if is_valid(rotated):\n            count += 1\n    return count\ns=\"[](){}\"\nprint(solution(s))",
        "detail": "9rogramers.rotated_s",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.safty_boat",
        "description": "9rogramers.safty_boat",
        "peekOfCode": "def solution(people, limit):\n    answer = 0\n    people.sort(reverse=True)\n    start, end = 0,len(people)-1\n    while True:\n        p1=people[start]\n        p2=people[end]\n        if p1+p2 <= limit:\n            end-=1\n        start+=1",
        "detail": "9rogramers.safty_boat",
        "documentation": {}
    },
    {
        "label": "weights",
        "kind": 5,
        "importPath": "9rogramers.siso",
        "description": "9rogramers.siso",
        "peekOfCode": "weights = [100,180,360,100,270]\ntoc = [2,3,4]\nanswer = 0\ninfo = defaultdict(int)\nfor w in weights:\n    print('*'*10)\n    answer += info[w] + info[w*2] + info[w/2] + info[(w*2)/3] + info[(w*3)/2] + info[(w*4)/3] + info[(w*3)/4]\n    info[w] += 1\n    print(info)\nprint(answer)",
        "detail": "9rogramers.siso",
        "documentation": {}
    },
    {
        "label": "toc",
        "kind": 5,
        "importPath": "9rogramers.siso",
        "description": "9rogramers.siso",
        "peekOfCode": "toc = [2,3,4]\nanswer = 0\ninfo = defaultdict(int)\nfor w in weights:\n    print('*'*10)\n    answer += info[w] + info[w*2] + info[w/2] + info[(w*2)/3] + info[(w*3)/2] + info[(w*4)/3] + info[(w*3)/4]\n    info[w] += 1\n    print(info)\nprint(answer)",
        "detail": "9rogramers.siso",
        "documentation": {}
    },
    {
        "label": "answer",
        "kind": 5,
        "importPath": "9rogramers.siso",
        "description": "9rogramers.siso",
        "peekOfCode": "answer = 0\ninfo = defaultdict(int)\nfor w in weights:\n    print('*'*10)\n    answer += info[w] + info[w*2] + info[w/2] + info[(w*2)/3] + info[(w*3)/2] + info[(w*4)/3] + info[(w*3)/4]\n    info[w] += 1\n    print(info)\nprint(answer)",
        "detail": "9rogramers.siso",
        "documentation": {}
    },
    {
        "label": "info",
        "kind": 5,
        "importPath": "9rogramers.siso",
        "description": "9rogramers.siso",
        "peekOfCode": "info = defaultdict(int)\nfor w in weights:\n    print('*'*10)\n    answer += info[w] + info[w*2] + info[w/2] + info[(w*2)/3] + info[(w*3)/2] + info[(w*4)/3] + info[(w*3)/4]\n    info[w] += 1\n    print(info)\nprint(answer)",
        "detail": "9rogramers.siso",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.sort_filename",
        "description": "9rogramers.sort_filename",
        "peekOfCode": "def solution(files):\n    temp = []\n    answer = []\n    for i in files:\n        split_str = re.split(r\"([0-9]+)\", i)  # +는 기준으로나오는거 전부다 엮기\n        temp.append(split_str)\n    print('머리가슴배: ', temp)\n    temp.sort(key=lambda x: (x[0].lower(), int(x[1])))  # 대소문자 관계없음,\n                                    # int로 안해주면 숫자를 문자열로봐서 정렬 이상하게 나옴\n    print('정렬후', temp)",
        "detail": "9rogramers.sort_filename",
        "documentation": {}
    },
    {
        "label": "files",
        "kind": 5,
        "importPath": "9rogramers.sort_filename",
        "description": "9rogramers.sort_filename",
        "peekOfCode": "files = [\"img12.png\", \"img10.png\", \"img02.png\",\n         \"img1.png\", \"IMG01.GIF\", \"img2.JPG\"]\nimport re\n# 정규표현식인가 그걸로 리스트 구간 나눠줘서 리스트 3등분한걸 리스트의 원소로 받고\n# 람다로 0,1,2 기준으로 정렬하고 join하면 될듯?\ndef solution(files):\n    temp = []\n    answer = []\n    for i in files:\n        split_str = re.split(r\"([0-9]+)\", i)  # +는 기준으로나오는거 전부다 엮기",
        "detail": "9rogramers.sort_filename",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "9rogramers.string_sort",
        "description": "9rogramers.string_sort",
        "peekOfCode": "s = \"Zbcdefg\"\nsorted_s=sorted(s,reverse=True)\nanswer = ''.join(sorted_s)",
        "detail": "9rogramers.string_sort",
        "documentation": {}
    },
    {
        "label": "answer",
        "kind": 5,
        "importPath": "9rogramers.string_sort",
        "description": "9rogramers.string_sort",
        "peekOfCode": "answer = ''.join(sorted_s)",
        "detail": "9rogramers.string_sort",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "9rogramers.summer_winter",
        "description": "9rogramers.summer_winter",
        "peekOfCode": "n = 3\nwords = [\"tank\", \"kick\", \"know\", \"wheel\", \"land\", \"dream\", \"mother\", \"robot\", \"tank\"]\ngame=[words.pop(0)]\norder=2\ncycle=1\nfor word in words:\n    if word not in game and game[-1][-1] == word[0]: # 정상적으로 게임이 진행될 때\n        game.append(word)\n        order+=1\n        if order > n:",
        "detail": "9rogramers.summer_winter",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "9rogramers.summer_winter",
        "description": "9rogramers.summer_winter",
        "peekOfCode": "words = [\"tank\", \"kick\", \"know\", \"wheel\", \"land\", \"dream\", \"mother\", \"robot\", \"tank\"]\ngame=[words.pop(0)]\norder=2\ncycle=1\nfor word in words:\n    if word not in game and game[-1][-1] == word[0]: # 정상적으로 게임이 진행될 때\n        game.append(word)\n        order+=1\n        if order > n:\n            cycle+=1",
        "detail": "9rogramers.summer_winter",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.tangerine",
        "description": "9rogramers.tangerine",
        "peekOfCode": "def solution(k, tangerine):\n    dic = Counter(tangerine)\n    values = sorted(list(dic.values()),reverse=True)\n    temp=0\n    answer=0\n    for i in range(k):\n        temp+=values[i]\n        if temp>=k:\n            answer=i+1\n            break",
        "detail": "9rogramers.tangerine",
        "documentation": {}
    },
    {
        "label": "booked",
        "kind": 5,
        "importPath": "9rogramers.test",
        "description": "9rogramers.test",
        "peekOfCode": "booked = [[\"09:10\", \"lee\"]]\nunbooked = [[\"09:00\", \"kim\"], [\"09:05\", \"bae\"]]\nfor i in range(len(booked)):\n    print(booked[i][0])\n    booked[i][0]=booked[i][0].replace(':', '')\n    print(booked[i][0])",
        "detail": "9rogramers.test",
        "documentation": {}
    },
    {
        "label": "unbooked",
        "kind": 5,
        "importPath": "9rogramers.test",
        "description": "9rogramers.test",
        "peekOfCode": "unbooked = [[\"09:00\", \"kim\"], [\"09:05\", \"bae\"]]\nfor i in range(len(booked)):\n    print(booked[i][0])\n    booked[i][0]=booked[i][0].replace(':', '')\n    print(booked[i][0])",
        "detail": "9rogramers.test",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.tournament_table",
        "description": "9rogramers.tournament_table",
        "peekOfCode": "def solution(n, a, b):\n    answer = 0\n    while a != b:\n        answer += 1\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n    return answer",
        "detail": "9rogramers.tournament_table",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "9rogramers.trainging",
        "description": "9rogramers.trainging",
        "peekOfCode": "def solution(n, lost, reserve):\n    real_reserve = set(reserve) - set(lost)\n    real_lost = set(lost) - set(reserve)\n    print('real_reserve: ',real_reserve)\n    print('real_lost: ',real_lost)\n    lonely = []\n    # for r in real_reserve:\n    #     print('r-1 in real_reserve: ',r-1)\n    #     print('r+1 in real_reserve: ',r+1)\n    #     print('real_lost: ',real_lost)",
        "detail": "9rogramers.trainging",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "9rogramers.trainging",
        "description": "9rogramers.trainging",
        "peekOfCode": "n = 8\nlost = [7, 2, 5, 6]\nreserve = [1, 8, 4, 3]\nprint(solution(n, lost, reserve))",
        "detail": "9rogramers.trainging",
        "documentation": {}
    },
    {
        "label": "lost",
        "kind": 5,
        "importPath": "9rogramers.trainging",
        "description": "9rogramers.trainging",
        "peekOfCode": "lost = [7, 2, 5, 6]\nreserve = [1, 8, 4, 3]\nprint(solution(n, lost, reserve))",
        "detail": "9rogramers.trainging",
        "documentation": {}
    },
    {
        "label": "reserve",
        "kind": 5,
        "importPath": "9rogramers.trainging",
        "description": "9rogramers.trainging",
        "peekOfCode": "reserve = [1, 8, 4, 3]\nprint(solution(n, lost, reserve))",
        "detail": "9rogramers.trainging",
        "documentation": {}
    },
    {
        "label": "eliminate_zero",
        "kind": 2,
        "importPath": "9rogramers.trans_binary",
        "description": "9rogramers.trans_binary",
        "peekOfCode": "def eliminate_zero(s):\n    transed = []\n    eliminated = 0\n    for i in s:\n        if i=='0':\n            eliminated+=1\n        else:\n            transed.append(i)\n    return transed,eliminated\ns=\"110010101001\"",
        "detail": "9rogramers.trans_binary",
        "documentation": {}
    },
    {
        "label": "count_trans",
        "kind": 5,
        "importPath": "9rogramers.trans_binary",
        "description": "9rogramers.trans_binary",
        "peekOfCode": "count_trans = 0\neliminated_zero = 0\nwhile True:\n    if len(s)==1:\n        break\n    transed,eliminated = eliminate_zero(s)\n    s=bin(len(''.join(transed)))[2:]\n    eliminated_zero += eliminated\n    count_trans+=1\nprint(count_trans)",
        "detail": "9rogramers.trans_binary",
        "documentation": {}
    },
    {
        "label": "eliminated_zero",
        "kind": 5,
        "importPath": "9rogramers.trans_binary",
        "description": "9rogramers.trans_binary",
        "peekOfCode": "eliminated_zero = 0\nwhile True:\n    if len(s)==1:\n        break\n    transed,eliminated = eliminate_zero(s)\n    s=bin(len(''.join(transed)))[2:]\n    eliminated_zero += eliminated\n    count_trans+=1\nprint(count_trans)\nprint(eliminated_zero)",
        "detail": "9rogramers.trans_binary",
        "documentation": {}
    },
    {
        "label": "dp",
        "kind": 5,
        "importPath": "9rogramers.triangle",
        "description": "9rogramers.triangle",
        "peekOfCode": "dp = [triangle[0][0]]\n# 삼각형의 각 줄을 순회하면서 최대값을 구함\nfor i in range(1, len(triangle)):\n    row = triangle[i]\n    temp = [0] * len(row)\n    for j in range(len(row)):\n        left_up = dp[j - 1] if j - 1 >= 0 else -1\n        right_up = dp[j] if j < len(dp) else -1\n        # 두 경우 중 더 큰 값을 현재 위치의 값과 더함\n        temp[j] = max(left_up, right_up) + row[j]",
        "detail": "9rogramers.triangle",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "9rogramers.triangle",
        "description": "9rogramers.triangle",
        "peekOfCode": "result = max(dp)\nprint(result)",
        "detail": "9rogramers.triangle",
        "documentation": {}
    },
    {
        "label": "matches",
        "kind": 5,
        "importPath": "9rogramers.tuple",
        "description": "9rogramers.tuple",
        "peekOfCode": "matches = re.findall(r'{([^}]*)}', s)\nmatches[0]=matches[0][1:]\nset_list=[]\nfor m in matches:\n    sub_set=list(map(int,m.split(',')))\n    set_list.append(sub_set)\nset_list.sort(key=len)\nanswer=[]\nfor sub in set_list:\n    for j in sub:",
        "detail": "9rogramers.tuple",
        "documentation": {}
    },
    {
        "label": "test_hashtable",
        "kind": 2,
        "importPath": "ch11_hashtable.hashtable",
        "description": "ch11_hashtable.hashtable",
        "peekOfCode": "def test_hashtable():\n    ht = MyHashTable()\n    ht.put(1, 1)\n    ht.put(2, 2)\n    assert ht.get(1) == 1\n    assert ht.get(3) == -1\n    ht.put(2, 1)\n    assert ht.get(2) == 1\n    ht.remove(2)\n    assert ht.get(2) == -1",
        "detail": "ch11_hashtable.hashtable",
        "documentation": {}
    },
    {
        "label": "test_birthday_problem",
        "kind": 2,
        "importPath": "ch11_hashtable.hashtable",
        "description": "ch11_hashtable.hashtable",
        "peekOfCode": "def test_birthday_problem():\n    import random\n    TRIALS = 100000\n    same_birthdays = 0\n    for _ in range(TRIALS):\n        birthdays = []\n        for i in range(23):\n            birthday = random.randint(1, 365)\n            if birthday in birthdays:\n                same_birthdays += 1",
        "detail": "ch11_hashtable.hashtable",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "ch11_hashtable.longest_notrepeat",
        "description": "ch11_hashtable.longest_notrepeat",
        "peekOfCode": "s = 'abcabcbc'\nresult_length = []\n# 시작  #비교시작\n# a    b       cabcbb\n# 조건1)\nfor i in range(len(s) - 1):  # start pointer\n    for j in range(i + 1, len(s)):  # end pointer\n        print('   Start value:', s[i], '[ index', i, '] || end value:', s[j], '[ index', j, ']')\n        if s[j] in s[i:j]:  #sol1)\n            result_length.append(len(s[i:j]))  # sol2,3)",
        "detail": "ch11_hashtable.longest_notrepeat",
        "documentation": {}
    },
    {
        "label": "result_length",
        "kind": 5,
        "importPath": "ch11_hashtable.longest_notrepeat",
        "description": "ch11_hashtable.longest_notrepeat",
        "peekOfCode": "result_length = []\n# 시작  #비교시작\n# a    b       cabcbb\n# 조건1)\nfor i in range(len(s) - 1):  # start pointer\n    for j in range(i + 1, len(s)):  # end pointer\n        print('   Start value:', s[i], '[ index', i, '] || end value:', s[j], '[ index', j, ']')\n        if s[j] in s[i:j]:  #sol1)\n            result_length.append(len(s[i:j]))  # sol2,3)\n            print('*  result_length list', result_length)",
        "detail": "ch11_hashtable.longest_notrepeat",
        "documentation": {}
    },
    {
        "label": "nqueen",
        "kind": 2,
        "importPath": "ch12_graph.backtracking",
        "description": "ch12_graph.backtracking",
        "peekOfCode": "def nqueen(n):\n    \"\"\"\n    visited 의 인덱스는 행, 값은 열을 나타낸다.\n    (1, 3)에 놓은 경우, visited[1] = 3 으로 표현하겠다는 것.\n    예시) n=4 이고 visited = [1, 3, 0, 2] 인 경우,\n    체스판을 그려보면 아래와 같다. (1이 퀸)\n    0 1 0 0\n    0 0 0 1\n    1 0 0 0\n    0 0 1 0",
        "detail": "ch12_graph.backtracking",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "ch12_graph.comb_sum",
        "description": "ch12_graph.comb_sum",
        "peekOfCode": "class Solution:\n    candidates=[2,3,6,7]\n    target=7\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        result = []\n        def dfs(csum,index,path):\n            # dfs(5,0,[2])\n            if csum<0:\n                return\n            if csum==0:",
        "detail": "ch12_graph.comb_sum",
        "documentation": {}
    },
    {
        "label": "combinationSum",
        "kind": 2,
        "importPath": "ch12_graph.comb_sum",
        "description": "ch12_graph.comb_sum",
        "peekOfCode": "def combinationSum(candidates, target):\n    results = []\n    # at each iteration we will update the list of targets\n    targets = [[target]]\n    while targets:\n        next_targets = []\n        for cur_sequence in targets:\n            cur_target = cur_sequence[0]\n            for candidate in candidates:\n                # to avoid duplicates we only add the candidate sequences in ascending order",
        "detail": "ch12_graph.comb_sum",
        "documentation": {}
    },
    {
        "label": "bfs_queue",
        "kind": 2,
        "importPath": "ch12_graph.graph_bfs",
        "description": "ch12_graph.graph_bfs",
        "peekOfCode": "def bfs_queue(start):\n    visited = [start]\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        for adj in graph[node]:\n            if adj not in visited:\n                q.append(adj)\n                visited.append(adj)\n    return visited",
        "detail": "ch12_graph.graph_bfs",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "ch12_graph.graph_bfs",
        "description": "ch12_graph.graph_bfs",
        "peekOfCode": "graph = {\n    1: [2, 3, 4],\n    2: [5],\n    3: [5],\n    4: [],\n    5: [6, 7],\n    6: [],\n    7: [3],\n}\ndef bfs_queue(start):",
        "detail": "ch12_graph.graph_bfs",
        "documentation": {}
    },
    {
        "label": "island_dfs_stack",
        "kind": 2,
        "importPath": "ch12_graph.graph_dfs",
        "description": "ch12_graph.graph_dfs",
        "peekOfCode": "def island_dfs_stack(grid):\n    dx = [0, 0, 1, -1]\n    dy = [1, -1, 0, 0]\n    rows, cols = len(grid), len(grid[0])\n    cnt = 0\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] != '1':\n                continue\n            cnt += 1",
        "detail": "ch12_graph.graph_dfs",
        "documentation": {}
    },
    {
        "label": "island_dfs_recursive",
        "kind": 2,
        "importPath": "ch12_graph.graph_dfs",
        "description": "ch12_graph.graph_dfs",
        "peekOfCode": "def island_dfs_recursive(grid):\n    dx = [0, 0, 1, -1]\n    dy = [1, -1, 0, 0]\n    m = len(grid)\n    n = len(grid[0])\n    cnt = 0\n    def dfs_recursive(r, c):\n        if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] != '1':\n            return\n        # 방문처리",
        "detail": "ch12_graph.graph_dfs",
        "documentation": {}
    },
    {
        "label": "letterCombinations",
        "kind": 2,
        "importPath": "ch12_graph.number_combination",
        "description": "ch12_graph.number_combination",
        "peekOfCode": "def letterCombinations(digits):\n    num_pad = {\n        \"2\": ['a', 'b', 'c'],\n        \"3\": ['d', 'e', 'f'],\n        \"4\": ['g', 'h', 'i'],\n        \"5\": ['j', 'k', 'l'],\n        \"6\": ['m', 'n', 'o'],\n        \"7\": ['p', 'q', 'r', 's'],\n        \"8\": ['t', 'u', 'v'],\n        \"9\": ['w', 'x', 'y', 'z'],",
        "detail": "ch12_graph.number_combination",
        "documentation": {}
    },
    {
        "label": "letterCombinations",
        "kind": 2,
        "importPath": "ch12_graph.number_comb_answer",
        "description": "ch12_graph.number_comb_answer",
        "peekOfCode": "def letterCombinations(digits):\n    def make_letter(idx, letter):\n        print('idx:',idx)\n        print('letter:',letter)\n        # base condition\n        if idx == len(digits):\n            ans.append(letter)\n            return\n        # dfs 깊이 별로(번호 2 -> 3) 가능한 모든 조합 호출\n        for i in phone_keyboard[digits[idx]]:",
        "detail": "ch12_graph.number_comb_answer",
        "documentation": {}
    },
    {
        "label": "letterCombinations2",
        "kind": 2,
        "importPath": "ch12_graph.number_comb_answer",
        "description": "ch12_graph.number_comb_answer",
        "peekOfCode": "def letterCombinations2(D):\n    lenD, ans = len(D), []\n    if D == \"\": return []\n    def dfs(pos, st):\n        if pos == lenD:\n            ans.append(st)\n        else:\n            letters = L[D[pos]]\n            for letter in letters:\n                dfs(pos + 1, st + letter)",
        "detail": "ch12_graph.number_comb_answer",
        "documentation": {}
    },
    {
        "label": "L",
        "kind": 5,
        "importPath": "ch12_graph.number_comb_answer",
        "description": "ch12_graph.number_comb_answer",
        "peekOfCode": "L = {'2': \"abc\", '3': \"def\", '4': \"ghi\", '5': \"jkl\",\n     '6': \"mno\", '7': \"pqrs\", '8': \"tuv\", '9': \"wxyz\"}\ndef letterCombinations2(D):\n    lenD, ans = len(D), []\n    if D == \"\": return []\n    def dfs(pos, st):\n        if pos == lenD:\n            ans.append(st)\n        else:\n            letters = L[D[pos]]",
        "detail": "ch12_graph.number_comb_answer",
        "documentation": {}
    },
    {
        "label": "num_island",
        "kind": 2,
        "importPath": "ch12_graph.number_island",
        "description": "ch12_graph.number_island",
        "peekOfCode": "def num_island(grid):\n    cnt = 0\n    dx = [0, 0, 1, -1]  # 상하좌우 좌우이동\n    dy = [1, -1, 0, 0]  # 상하이동\n    m = len(grid)\n    n = len(grid[0])\n    # 재귀적으로 짠다 ==> 가장 중요한 idea는 1) 반복적으로 발생하는 일을 아는 것. 2) 종료 조건을 아는것.\n    def dfs_recur(row, col):\n        #이동할수 없거나 값이 0인경우\n        if row < 0 or row >= m or col < 0 or col >= n or grid[row][col] != '1':",
        "detail": "ch12_graph.number_island",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "ch12_graph.number_island",
        "description": "ch12_graph.number_island",
        "peekOfCode": "grid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"1\", \"0\", \"1\"],\n    [\"1\", \"1\", \"1\", \"0\", \"1\"]\n]\n## 조건1) 0,0으로부터 인접노드를 dfs한다. 더이상 찾을수 없을경우 cnt++ 한다. 검사한 노드는 전부 0으로 돌린다.\n## 조건2) m,n 탐색이 종료되면 cnt를 return한다.\ndef num_island(grid):\n    cnt = 0",
        "detail": "ch12_graph.number_island",
        "documentation": {}
    },
    {
        "label": "island_bfs",
        "kind": 2,
        "importPath": "ch12_graph.number_island_bfs",
        "description": "ch12_graph.number_island_bfs",
        "peekOfCode": "def island_bfs(grid):\n    dx = [0, 0, 1, -1]\n    dy = [1, -1, 0, 0]\n    rows, cols = len(grid), len(grid[0])\n    cnt = 0\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] != '1':\n                continue\n            cnt += 1",
        "detail": "ch12_graph.number_island_bfs",
        "documentation": {}
    },
    {
        "label": "findItinerary",
        "kind": 2,
        "importPath": "ch12_graph.reconst",
        "description": "ch12_graph.reconst",
        "peekOfCode": "def findItinerary(tickets):\n    graph = collections.defaultdict(list)\n    print('graph:',graph)\n    # 그래프 순서대로 구성\n    for a, b in sorted(tickets):\n        graph[a].append(b)\n        print('graph[a]:',graph[a])\n        print('b:',b)\n    route = []\n    def dfs(a):",
        "detail": "ch12_graph.reconst",
        "documentation": {}
    },
    {
        "label": "island_dfs_recursive",
        "kind": 2,
        "importPath": "ch12_graph.recursive_prac",
        "description": "ch12_graph.recursive_prac",
        "peekOfCode": "def island_dfs_recursive(grid):\n    dx = [0, 0, 1, -1]\n    dy = [1, -1, 0, 0]\n    m = len(grid)\n    n = len(grid[0])\n    cnt = 0\n    def dfs_recursive(r, c):\n        if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] != '1':\n            return\n        # 방문처리",
        "detail": "ch12_graph.recursive_prac",
        "documentation": {}
    },
    {
        "label": "subsets",
        "kind": 2,
        "importPath": "ch12_graph.subsets",
        "description": "ch12_graph.subsets",
        "peekOfCode": "def subsets(nums):\n    result = []\n    # 재귀적으로 짠다 ==> 가장 중요한 idea는 1) 반복적으로 발생하는 일을 아는 것.\n    #                                   2) 종료 조건을 아는것.\n    #   dfs를 사용하는 패턴\n    #   1. 초기 값을 넣어서 메인 함수 안의 dfs 함수를 호출한다.\n    #   2. 호출한 값을 result에 반영시킨다.\n    #   3. for 문을 열어서 상위노드임을 알수있고, 인접 노드를 탐색한다.\n    #       >>인접노드 기준으로 다시 dfs함수를 호출한다.\n    #   4. for문 진행중, 값을 얻을수 없을 경우(최종 depth까지 진행한 경우)",
        "detail": "ch12_graph.subsets",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "ch12_graph.subsets",
        "description": "ch12_graph.subsets",
        "peekOfCode": "nums = [1, 2, 3]\ndef subsets(nums):\n    result = []\n    # 재귀적으로 짠다 ==> 가장 중요한 idea는 1) 반복적으로 발생하는 일을 아는 것.\n    #                                   2) 종료 조건을 아는것.\n    #   dfs를 사용하는 패턴\n    #   1. 초기 값을 넣어서 메인 함수 안의 dfs 함수를 호출한다.\n    #   2. 호출한 값을 result에 반영시킨다.\n    #   3. for 문을 열어서 상위노드임을 알수있고, 인접 노드를 탐색한다.\n    #       >>인접노드 기준으로 다시 dfs함수를 호출한다.",
        "detail": "ch12_graph.subsets",
        "documentation": {}
    },
    {
        "label": "make_tree_by",
        "kind": 2,
        "importPath": "ch14_tree.binarytree.prac",
        "description": "ch14_tree.binarytree.prac",
        "peekOfCode": "def make_tree_by(lst, idx):\n    parent = None\n    if idx < len(lst):\n        value = lst[idx]\n        if value == None:\n            return\n        parent = TreeNode(value)\n        parent.left = make_tree_by(lst, 2 * idx + 1)\n        parent.left = make_tree_by(lst, 2 * idx + 2)\n    return parent",
        "detail": "ch14_tree.binarytree.prac",
        "documentation": {}
    },
    {
        "label": "sorted_array_to_bst",
        "kind": 2,
        "importPath": "ch14_tree.binarytree.prac",
        "description": "ch14_tree.binarytree.prac",
        "peekOfCode": "def sorted_array_to_bst(lst):\n    if not lst:\n        return None\n    mid = len(lst) // 2\n    node = TreeNode(lst[mid])\n    node.left = sorted_array_to_bst(lst[:mid])\n    node.right = sorted_array_to_bst(lst[mid + 1:])\n    return node\ndef make_lst_by_bst(root, limit):\n    if not root:",
        "detail": "ch14_tree.binarytree.prac",
        "documentation": {}
    },
    {
        "label": "make_lst_by_bst",
        "kind": 2,
        "importPath": "ch14_tree.binarytree.prac",
        "description": "ch14_tree.binarytree.prac",
        "peekOfCode": "def make_lst_by_bst(root, limit):\n    if not root:\n        return []\n    lst = []\n    q = deque([root])\n    while q:\n        if len(lst) > limit:\n            break\n        node = q.popleft()\n        if node:",
        "detail": "ch14_tree.binarytree.prac",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "ch14_tree.binarytree.structures",
        "description": "ch14_tree.binarytree.structures",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
        "detail": "ch14_tree.binarytree.structures",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "ch14_tree.binarytree.test_max_depth",
        "description": "ch14_tree.binarytree.test_max_depth",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef make_tree_by(lst, idx):\n    parent = None\n    if idx < len(lst):\n        if lst[idx] is None:\n            return",
        "detail": "ch14_tree.binarytree.test_max_depth",
        "documentation": {}
    },
    {
        "label": "make_tree_by",
        "kind": 2,
        "importPath": "ch14_tree.binarytree.test_max_depth",
        "description": "ch14_tree.binarytree.test_max_depth",
        "peekOfCode": "def make_tree_by(lst, idx):\n    parent = None\n    if idx < len(lst):\n        if lst[idx] is None:\n            return\n        parent = TreeNode(lst[idx])\n        parent.left = make_tree_by(lst, 2 * idx + 1)\n        parent.right = make_tree_by(lst, 2 * idx + 2)\n    return parent\ndef test_max_depth(lst):",
        "detail": "ch14_tree.binarytree.test_max_depth",
        "documentation": {}
    },
    {
        "label": "test_max_depth",
        "kind": 2,
        "importPath": "ch14_tree.binarytree.test_max_depth",
        "description": "ch14_tree.binarytree.test_max_depth",
        "peekOfCode": "def test_max_depth(lst):\n    root = make_tree_by(lst, 0)\n    if not root:\n        return 0\n    q = deque([root])\n    depth = 0\n    while q:\n        depth += 1\n        for _ in range(len(q)):\n            cur = q.popleft()",
        "detail": "ch14_tree.binarytree.test_max_depth",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "ch14_tree.Lecture_reverse_tree",
        "description": "ch14_tree.Lecture_reverse_tree",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef sorted_array_to_bst(lst):   #2\n    if not lst:\n        return None\n    mid = len(lst) // 2\n    node = TreeNode(lst[mid])",
        "detail": "ch14_tree.Lecture_reverse_tree",
        "documentation": {}
    },
    {
        "label": "sorted_array_to_bst",
        "kind": 2,
        "importPath": "ch14_tree.Lecture_reverse_tree",
        "description": "ch14_tree.Lecture_reverse_tree",
        "peekOfCode": "def sorted_array_to_bst(lst):   #2\n    if not lst:\n        return None\n    mid = len(lst) // 2\n    node = TreeNode(lst[mid])\n    node.left = sorted_array_to_bst(lst[:mid])\n    node.right = sorted_array_to_bst(lst[mid + 1:])\n    print('sorted_arrray_to_bst_node: ', node.val)\n    return node\ndef test_sorted_array_to_bst(lst):      #1",
        "detail": "ch14_tree.Lecture_reverse_tree",
        "documentation": {}
    },
    {
        "label": "test_sorted_array_to_bst",
        "kind": 2,
        "importPath": "ch14_tree.Lecture_reverse_tree",
        "description": "ch14_tree.Lecture_reverse_tree",
        "peekOfCode": "def test_sorted_array_to_bst(lst):      #1\n    if not lst:\n        return []\n    root = sorted_array_to_bst(lst)     #return node\n    print('test+sorted+array+to+bst/// root: ', root)\n    print('list: ', lst)\n    return make_lst_by_bst(root, len(lst))\ndef make_lst_by_bst(root, limit):       #3\n    if not root:\n        return []",
        "detail": "ch14_tree.Lecture_reverse_tree",
        "documentation": {}
    },
    {
        "label": "make_lst_by_bst",
        "kind": 2,
        "importPath": "ch14_tree.Lecture_reverse_tree",
        "description": "ch14_tree.Lecture_reverse_tree",
        "peekOfCode": "def make_lst_by_bst(root, limit):       #3\n    if not root:\n        return []\n    lst = []\n    q = deque([root])\n    print('makelist+limit_before q: ', limit)\n    while q:\n        print('lst: ', lst)\n        if len(lst) > limit:\n            break",
        "detail": "ch14_tree.Lecture_reverse_tree",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "ch14_tree.Lecture_reverse_tree",
        "description": "ch14_tree.Lecture_reverse_tree",
        "peekOfCode": "lst = [-10, -3, 0, 5, 9]\ntest_sorted_array_to_bst(lst)\n##############################################################################\n# from ch14_tree.binarytree.prac import sorted_array_to_bst, make_lst_by_bst\n#\n#\n# def test_sorted_array_to_bst(lst):\n#     if not lst:\n#         return []\n#     root = sorted_array_to_bst(lst)",
        "detail": "ch14_tree.Lecture_reverse_tree",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "ch14_tree.longest_path",
        "description": "ch14_tree.longest_path",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef make_tree_by(lst, idx):\n    parent = None\n    print('idx,len(lst)',idx,len(lst))\n    print('lst: ',lst)\n    if idx < len(lst):",
        "detail": "ch14_tree.longest_path",
        "documentation": {}
    },
    {
        "label": "make_tree_by",
        "kind": 2,
        "importPath": "ch14_tree.longest_path",
        "description": "ch14_tree.longest_path",
        "peekOfCode": "def make_tree_by(lst, idx):\n    parent = None\n    print('idx,len(lst)',idx,len(lst))\n    print('lst: ',lst)\n    if idx < len(lst):\n        if lst[idx] is None:\n            return\n        parent = TreeNode(lst[idx])\n        parent.left = make_tree_by(lst, 2 * idx + 1)\n        parent.right = make_tree_by(lst, 2 * idx + 2)",
        "detail": "ch14_tree.longest_path",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "ch14_tree.longest_path",
        "description": "ch14_tree.longest_path",
        "peekOfCode": "tree = [1, 2, 3, 4, 5]\nmake_tree_by(tree,1)\n#  최하단 (parent.left = leaf) 노드에서 출발 >> parent노드로 간다.이때 parent까지의 cnt++ 저장\n#                      >> parent.right의 right leaf까지 간다. // 다시 leaf 까지의 cnt 따로 저장.\n#                      >> 재귀를 이용해서 이전 cnt와의 비교를 하면서 더 큰값을 계속 cnt에 갱신하며 반복\n#   parent.val\n# def longestPath(lst):\n#     cnt=0\n#     root = make_tree_by(lst, 0)\n#",
        "detail": "ch14_tree.longest_path",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "ch14_tree.merge_bi_tree",
        "description": "ch14_tree.merge_bi_tree",
        "peekOfCode": "class TreeNode:  # clear\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ntr_lst1 = [1, 3, 2, 5, None, None, None]\ntr_lst2 = [2, 1, 3, None, 4, None, 7]\ndef maketree(lst, idx):  # clear\n    parent = None\n    if idx < len(lst):",
        "detail": "ch14_tree.merge_bi_tree",
        "documentation": {}
    },
    {
        "label": "maketree",
        "kind": 2,
        "importPath": "ch14_tree.merge_bi_tree",
        "description": "ch14_tree.merge_bi_tree",
        "peekOfCode": "def maketree(lst, idx):  # clear\n    parent = None\n    if idx < len(lst):\n        value = lst[idx]\n        if value == None:\n            return\n        parent = TreeNode(value)\n        parent.left = maketree(lst, 2 * idx + 1)\n        parent.right = maketree(lst, 2 * idx + 2)\n    return parent",
        "detail": "ch14_tree.merge_bi_tree",
        "documentation": {}
    },
    {
        "label": "mergetree",
        "kind": 2,
        "importPath": "ch14_tree.merge_bi_tree",
        "description": "ch14_tree.merge_bi_tree",
        "peekOfCode": "def mergetree(tr_lst1, tr_lst2):\n    print(maketree(tr_lst1, 0).val)  # maketree 검증\n    t1 = maketree(tr_lst1, 0)  # list를 tree로 바꿔줌\n    t2 = maketree(tr_lst2, 0)  #\n    def recur(t1, t2):  # tree 1과 2를 입력해서 시작\n        if t1 and t2:  # 둘 다 value가 None이 아니라면\n            node = TreeNode(t1.val + t2.val)\n            node.left = recur(t1.left, t2.left)\n            node.right = recur(t1.right, t2.right)\n            return node",
        "detail": "ch14_tree.merge_bi_tree",
        "documentation": {}
    },
    {
        "label": "make_lst_by_bst",
        "kind": 2,
        "importPath": "ch14_tree.merge_bi_tree",
        "description": "ch14_tree.merge_bi_tree",
        "peekOfCode": "def make_lst_by_bst(root, limit):\n    if not root:\n        return []\n    lst = []\n    q = deque([root])\n    while q:\n        if len(lst) > limit:\n            break\n        node = q.popleft()\n        if node:",
        "detail": "ch14_tree.merge_bi_tree",
        "documentation": {}
    },
    {
        "label": "tr_lst1",
        "kind": 5,
        "importPath": "ch14_tree.merge_bi_tree",
        "description": "ch14_tree.merge_bi_tree",
        "peekOfCode": "tr_lst1 = [1, 3, 2, 5, None, None, None]\ntr_lst2 = [2, 1, 3, None, 4, None, 7]\ndef maketree(lst, idx):  # clear\n    parent = None\n    if idx < len(lst):\n        value = lst[idx]\n        if value == None:\n            return\n        parent = TreeNode(value)\n        parent.left = maketree(lst, 2 * idx + 1)",
        "detail": "ch14_tree.merge_bi_tree",
        "documentation": {}
    },
    {
        "label": "tr_lst2",
        "kind": 5,
        "importPath": "ch14_tree.merge_bi_tree",
        "description": "ch14_tree.merge_bi_tree",
        "peekOfCode": "tr_lst2 = [2, 1, 3, None, 4, None, 7]\ndef maketree(lst, idx):  # clear\n    parent = None\n    if idx < len(lst):\n        value = lst[idx]\n        if value == None:\n            return\n        parent = TreeNode(value)\n        parent.left = maketree(lst, 2 * idx + 1)\n        parent.right = maketree(lst, 2 * idx + 2)",
        "detail": "ch14_tree.merge_bi_tree",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "ch14_tree.treePrac",
        "description": "ch14_tree.treePrac",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef make_lst_by_bst(root, limit):\n    if not root:\n        return []\n    lst = []\n    q = deque([root])",
        "detail": "ch14_tree.treePrac",
        "documentation": {}
    },
    {
        "label": "make_lst_by_bst",
        "kind": 2,
        "importPath": "ch14_tree.treePrac",
        "description": "ch14_tree.treePrac",
        "peekOfCode": "def make_lst_by_bst(root, limit):\n    if not root:\n        return []\n    lst = []\n    q = deque([root])\n    print('makelist+limit_before q: ', limit)\n    while q:\n        print('lst: ', lst)\n        if len(lst) > limit:\n            break",
        "detail": "ch14_tree.treePrac",
        "documentation": {}
    },
    {
        "label": "BinaryMaxHeap",
        "kind": 6,
        "importPath": "ch15_heap.kth_lagest_",
        "description": "ch15_heap.kth_lagest_",
        "peekOfCode": "class BinaryMaxHeap:  # __xxx__ << magic method\n    def __init__(self):  # 클래스가 시작될때 실행되는 명령문\n        # 계산 편의를 위해 0이 아닌 1번째 인덱스부터 사용한다.\n        self.items = [None]\n        print('__init__self.items: ',self.items)\n    def __len__(self): ## 처음에 none을 넣었으니\n        # len() 연산을 가능하게 하는 매직 메서드 덮어쓰기(Override).\n        return len(self.items) - 1\n    def _percolate_up(self):\n        cur = len(self)",
        "detail": "ch15_heap.kth_lagest_",
        "documentation": {}
    },
    {
        "label": "test_maxheap_we_made",
        "kind": 2,
        "importPath": "ch15_heap.kth_lagest_",
        "description": "ch15_heap.kth_lagest_",
        "peekOfCode": "def test_maxheap_we_made(lst, k):\n    maxheap = BinaryMaxHeap()\n    for elem in lst:\n        maxheap.insert(elem)\n    print('maxdddddddddddddd',maxheap.items)\n    answer = [maxheap.extract() for _ in range(k)][k - 1]\n    print('answer: ', answer)\n    return answer\nnums = [3, 2, 3, 1, 2, 4, 5, 5, 6]\nk = 4",
        "detail": "ch15_heap.kth_lagest_",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "ch15_heap.kth_lagest_",
        "description": "ch15_heap.kth_lagest_",
        "peekOfCode": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6]\nk = 4\ntest_maxheap_we_made(nums, k)",
        "detail": "ch15_heap.kth_lagest_",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "ch15_heap.kth_lagest_",
        "description": "ch15_heap.kth_lagest_",
        "peekOfCode": "k = 4\ntest_maxheap_we_made(nums, k)",
        "detail": "ch15_heap.kth_lagest_",
        "documentation": {}
    },
    {
        "label": "BinaryMaxHeap",
        "kind": 6,
        "importPath": "ch15_heap.Lecture_heap",
        "description": "ch15_heap.Lecture_heap",
        "peekOfCode": "class BinaryMaxHeap:    #__xxx__ << magic method\n    def __init__(self): #클래스가 시작될때 실행되는 명령문\n        # 계산 편의를 위해 0이 아닌 1번째 인덱스부터 사용한다.\n        self.items = [None]\n    def __len__(self):\n        # len() 연산을 가능하게 하는 매직 메서드 덮어쓰기(Override).\n        return len(self.items) - 1\n    def _percolate_up(self):\n        # percolate: 스며들다.\n        cur = len(self)",
        "detail": "ch15_heap.Lecture_heap",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "ch17_sort.insert_linkedlist",
        "description": "ch17_sort.insert_linkedlist",
        "peekOfCode": "class Node:\n    def __init__(self, val=None, next=None):\n        self.val = val\n        self.next = next\nclass L_List:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    # 노드가 없을경우에 예외처리\n    def isempty(self):",
        "detail": "ch17_sort.insert_linkedlist",
        "documentation": {}
    },
    {
        "label": "L_List",
        "kind": 6,
        "importPath": "ch17_sort.insert_linkedlist",
        "description": "ch17_sort.insert_linkedlist",
        "peekOfCode": "class L_List:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    # 노드가 없을경우에 예외처리\n    def isempty(self):\n        return not bool(self.head)\n    # 노드의 가장 앞에 입력\n    def add_front(self, val):\n        node = Node(val)",
        "detail": "ch17_sort.insert_linkedlist",
        "documentation": {}
    },
    {
        "label": "insertionsort",
        "kind": 2,
        "importPath": "ch17_sort.insert_linkedlist",
        "description": "ch17_sort.insert_linkedlist",
        "peekOfCode": "def insertionsort(lst):\n    # 0번째 요소는 이미 정렬되어있으니, 1번째 ~ lst(len)-1 번째를 정렬하면 된다.\n    for cur in range(1, len(lst)):\n        for delta in range(1, cur + 1):\n            cmp = cur - delta  # delta 만큼 역순으로 비교하고 swap\n            if lst[cmp] > lst[cmp + 1]:\n                lst[cmp], lst[cmp + 1] = lst[cmp + 1], lst[cmp]\n            else:\n                break\n    return lst",
        "detail": "ch17_sort.insert_linkedlist",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "ch17_sort.insert_linkedlist",
        "description": "ch17_sort.insert_linkedlist",
        "peekOfCode": "lst = [4, 2, 1, 3]\nif __name__ == '__main__':\n    Linklist = L_List()\n    for i in range(len(lst)):\n        Linklist.add_end(lst[i])\n    #[4 > 2 > 1 > 3]\n    de = []\n    de = Linklist.deserial_linkedlist()\n    #[4,2,1,3]\n    answer = insertionsort(de)",
        "detail": "ch17_sort.insert_linkedlist",
        "documentation": {}
    },
    {
        "label": "qsort",
        "kind": 2,
        "importPath": "ch17_sort.Lecture2_quicksort",
        "description": "ch17_sort.Lecture2_quicksort",
        "peekOfCode": "def qsort(lst):  # 피벗을 기준으로 왼편, 오른편을 각각 다시 분할화 해야함.\n    def recur(lst, left, right):\n        if left >= right:  # 종료 조건\n            return\n        pivot = lst[right]  # 현재 리스트의 가장 오른편 요소를 pivot으로 한다.\n        cursor = left - 1  # 현재 커서의 위치\n        for i in range(left, right):  # 현재 리스트를 돌면서 비교한다.\n            if pivot < lst[i]:  # lst값이 더 클경우는 상관없음\n                print('pass', lst)\n            else:  # 더 작을 경우에 swap이 일어남",
        "detail": "ch17_sort.Lecture2_quicksort",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "ch17_sort.Lecture2_quicksort",
        "description": "ch17_sort.Lecture2_quicksort",
        "peekOfCode": "lst = [1, 2, 3, 4, 7, 6, 5, 8]\ndef qsort(lst):  # 피벗을 기준으로 왼편, 오른편을 각각 다시 분할화 해야함.\n    def recur(lst, left, right):\n        if left >= right:  # 종료 조건\n            return\n        pivot = lst[right]  # 현재 리스트의 가장 오른편 요소를 pivot으로 한다.\n        cursor = left - 1  # 현재 커서의 위치\n        for i in range(left, right):  # 현재 리스트를 돌면서 비교한다.\n            if pivot < lst[i]:  # lst값이 더 클경우는 상관없음\n                print('pass', lst)",
        "detail": "ch17_sort.Lecture2_quicksort",
        "documentation": {}
    },
    {
        "label": "mergesort",
        "kind": 2,
        "importPath": "ch17_sort.Lecture3_mergesort",
        "description": "ch17_sort.Lecture3_mergesort",
        "peekOfCode": "def mergesort(lst):\n    def scatter(lst):  # 분리시키는 함수\n        if len(lst) <= 1:  # 1개씩 분리시킨다.\n            return lst\n        mid = len(lst) // 2  # 중간 index 기준\n        left = lst[0:mid]  # 왼쪽 파트\n        right = lst[mid:]  # 오른쪽 파트\n        scatter(left)  # 왼쪽 재귀하여 파티션\n        scatter(right)  # 오른쪽 재귀하여 파티션\n        return merge(scatter(left), scatter(right))  # 분리가 끝났다면 merge 함수로 간다.",
        "detail": "ch17_sort.Lecture3_mergesort",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "ch17_sort.Lecture3_mergesort",
        "description": "ch17_sort.Lecture3_mergesort",
        "peekOfCode": "lst = [1, 7, 2, 5, 11, 21, 3, 4, 1111, 0]\nprint(mergesort(lst))\n#\n#\n#\n# lst1 = [1, 1, 2, 3, 5, 6, 10, 12, 14, 15, 222]\n# lst2 = [1, 4, 8, 9]\n# merge(lst1, lst2)",
        "detail": "ch17_sort.Lecture3_mergesort",
        "documentation": {}
    },
    {
        "label": "MaxHeap",
        "kind": 6,
        "importPath": "ch17_sort.Lecture4_heapsort",
        "description": "ch17_sort.Lecture4_heapsort",
        "peekOfCode": "class MaxHeap:  # class 부르기\n    def __init__(self):  # parent 값에서 left right 때문에\n        self.val = [None]  # 초기값 None으로 시작함.\n    def __len__(self):  # 매직 메서드 덮어쓰기\n        return len(self.val) - 1  # None값을 넣어주었으니, len계산때 1을 빼주는것\n    def insert(self, k):  # heap에 leaf를 입력 하는 함수\n        self.val.append(k)  # 변수k를 val 리스트에 append\n        cursor = len(self)  # 가장 끝 요소에 커서 위치.\n        parent = cursor // 2  # left 라면 2*cursor, right 라면 2*cursor + 1 이므로 # parent 는 항상 cursor // 2\n        # 스왑하며 올라가는 로직",
        "detail": "ch17_sort.Lecture4_heapsort",
        "documentation": {}
    },
    {
        "label": "Maxheapsort",
        "kind": 2,
        "importPath": "ch17_sort.Lecture4_heapsort",
        "description": "ch17_sort.Lecture4_heapsort",
        "peekOfCode": "def Maxheapsort(lst):\n    heap = MaxHeap()\n    for i in lst:\n        heap.insert(i)\n    res = []\n    for _ in range(len(lst)):\n        res.append(heap.extract())\n    res.sort(reverse=False)\n    return res\nlst = [3, 4, 1, 5, 5, 7, 21, 543, 1212, 2, 3, 55, 100, 22222, 0, 123, -3]",
        "detail": "ch17_sort.Lecture4_heapsort",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "ch17_sort.Lecture4_heapsort",
        "description": "ch17_sort.Lecture4_heapsort",
        "peekOfCode": "lst = [3, 4, 1, 5, 5, 7, 21, 543, 1212, 2, 3, 55, 100, 22222, 0, 123, -3]\nprint(Maxheapsort(lst))",
        "detail": "ch17_sort.Lecture4_heapsort",
        "documentation": {}
    },
    {
        "label": "quicksort",
        "kind": 2,
        "importPath": "ch17_sort.Lecture_quicksort_answer",
        "description": "ch17_sort.Lecture_quicksort_answer",
        "peekOfCode": "def quicksort(lst, start, end):\n    def partition(part, ps, pe):  # part인 list, part start, part end\n        pivot = part[pe]  # pivot을 part의 end값으로 초기화\n        i = ps - 1  # i = ps-1 => 커서 위치를 초기화\n        for j in range(ps, pe):  # ps~pe-1까지, pivot을 제외하고 비교.\n            if part[j] <= pivot:  # part[j]를 pivot의 왼편에둘지, 바꾸지 않을지.\n                i += 1  # 바꿀 커서 위치를 [-1]부터 한칸씩 +1씩 바꿀자리로 옮겨준다.\n                part[i], part[j] = part[j], part[i]  # swap\n        part[i + 1], part[pe] = part[pe], part[i + 1]\n        # ==>for문이 끝난뒤에 pivot을 구분기준 왼편의+1 요소와 스왑한다.",
        "detail": "ch17_sort.Lecture_quicksort_answer",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "ch17_sort.Lecture_quicksort_answer",
        "description": "ch17_sort.Lecture_quicksort_answer",
        "peekOfCode": "lst = [1, 6, 4, 2, 5, 3]\ndef quicksort(lst, start, end):\n    def partition(part, ps, pe):  # part인 list, part start, part end\n        pivot = part[pe]  # pivot을 part의 end값으로 초기화\n        i = ps - 1  # i = ps-1 => 커서 위치를 초기화\n        for j in range(ps, pe):  # ps~pe-1까지, pivot을 제외하고 비교.\n            if part[j] <= pivot:  # part[j]를 pivot의 왼편에둘지, 바꾸지 않을지.\n                i += 1  # 바꿀 커서 위치를 [-1]부터 한칸씩 +1씩 바꿀자리로 옮겨준다.\n                part[i], part[j] = part[j], part[i]  # swap\n        part[i + 1], part[pe] = part[pe], part[i + 1]",
        "detail": "ch17_sort.Lecture_quicksort_answer",
        "documentation": {}
    },
    {
        "label": "bubble",
        "kind": 2,
        "importPath": "ch17_sort.Lecture_sort",
        "description": "ch17_sort.Lecture_sort",
        "peekOfCode": "def bubble(lst):\n    bound=len(lst)-1\n    for _ in range(len(lst)-1):\n        for i in range(bound):\n            if lst[i] > lst[i + 1]:\n                lst[i], lst[i + 1] = lst[i + 1], lst[i]\n        bound -=1\n    print(lst)\nbubble(lst)\ndef select(lst):",
        "detail": "ch17_sort.Lecture_sort",
        "documentation": {}
    },
    {
        "label": "select",
        "kind": 2,
        "importPath": "ch17_sort.Lecture_sort",
        "description": "ch17_sort.Lecture_sort",
        "peekOfCode": "def select(lst):\n    # 이중포문으로 0 >1~len(lst)까지 비교하여 가장 작은 값의 idx와 idx i 스왑 반복.\n    for i in range(len(lst) - 1):\n        small = lst[i]  # small 초기화\n        for cur in range(i + 1, len(lst)):\n            if small > lst[cur]:\n                small = lst[cur]  # 최소값 갱신\n                temp = cur  # 후에 swap 해줄 idx 갱신\n        if lst[i] > small:  # swap\n            lst[i], lst[temp] = lst[temp], lst[i]",
        "detail": "ch17_sort.Lecture_sort",
        "documentation": {}
    },
    {
        "label": "insertionsort",
        "kind": 2,
        "importPath": "ch17_sort.Lecture_sort",
        "description": "ch17_sort.Lecture_sort",
        "peekOfCode": "def insertionsort(lst):\n    # 0번째 요소는 이미 정렬되어있으니, 1번째 ~ lst(len)-1 번째를 정렬하면 된다.\n    for cur in range(1, len(lst)):\n        # 비교지점이 cur-1 ~ 0(=cur-cur)까지 내려간다.\n        for delta in range(1, cur + 1):\n            cmp = cur - delta\n            if lst[cmp] > lst[cmp + 1]:\n                lst[cmp], lst[cmp + 1] = lst[cmp + 1], lst[cmp]\n            else:\n                break",
        "detail": "ch17_sort.Lecture_sort",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "ch17_sort.Lecture_sort",
        "description": "ch17_sort.Lecture_sort",
        "peekOfCode": "lst = [2, 5, 7, 3, 4, 9, 1]  # len=7 // idx0~6\ndef bubble(lst):\n    bound=len(lst)-1\n    for _ in range(len(lst)-1):\n        for i in range(bound):\n            if lst[i] > lst[i + 1]:\n                lst[i], lst[i + 1] = lst[i + 1], lst[i]\n        bound -=1\n    print(lst)\nbubble(lst)",
        "detail": "ch17_sort.Lecture_sort",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "ch17_sort.listsort",
        "description": "ch17_sort.listsort",
        "peekOfCode": "class Node:\n    def __init__(self, val=None, next=None):\n        self.val = val\n        self.next = next\nclass L_List:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    # 노드가 없을경우에 예외처리\n    def isempty(self):",
        "detail": "ch17_sort.listsort",
        "documentation": {}
    },
    {
        "label": "L_List",
        "kind": 6,
        "importPath": "ch17_sort.listsort",
        "description": "ch17_sort.listsort",
        "peekOfCode": "class L_List:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    # 노드가 없을경우에 예외처리\n    def isempty(self):\n        return not bool(self.head)\n    # 마지막 노드의 뒤에 입력\n    def add_end(self, val):\n        if not self.isempty():",
        "detail": "ch17_sort.listsort",
        "documentation": {}
    },
    {
        "label": "binary_search_builtin",
        "kind": 2,
        "importPath": "ch18_binarysearch.Lecture",
        "description": "ch18_binarysearch.Lecture",
        "peekOfCode": "def binary_search_builtin(nums, target):\n    idx = bisect.bisect_left(nums, target)\n    # idx == len(nums) 가능하기 떄문.\n    if idx < len(nums) and nums[idx] == target:\n        return idx\n    else:\n        return -1",
        "detail": "ch18_binarysearch.Lecture",
        "documentation": {}
    },
    {
        "label": "dijkstra_pq",
        "kind": 2,
        "importPath": "ch19_dijkstra.Lecture",
        "description": "ch19_dijkstra.Lecture",
        "peekOfCode": "def dijkstra_pq(graph, start):\n    N = len(graph)\n    dist = [INF] * N\n    q = []\n    # 튜플일 경우 0번째 요소 기준으로 최소 힙 구조.\n    # 첫 번째 방문 누적 비용은 0이다.\n    heapq.heappush(q, (0, start))\n    dist[start] = 0\n    while q:\n        # 누적 비용이 가장 작은 녀석을 꺼낸다.",
        "detail": "ch19_dijkstra.Lecture",
        "documentation": {}
    },
    {
        "label": "INF",
        "kind": 5,
        "importPath": "ch19_dijkstra.Lecture",
        "description": "ch19_dijkstra.Lecture",
        "peekOfCode": "INF = int(1e9)\ndef dijkstra_pq(graph, start):\n    N = len(graph)\n    dist = [INF] * N\n    q = []\n    # 튜플일 경우 0번째 요소 기준으로 최소 힙 구조.\n    # 첫 번째 방문 누적 비용은 0이다.\n    heapq.heappush(q, (0, start))\n    dist[start] = 0\n    while q:",
        "detail": "ch19_dijkstra.Lecture",
        "documentation": {}
    },
    {
        "label": "isPalindrom",
        "kind": 2,
        "importPath": "ch6_7_char_array.6-1",
        "description": "ch6_7_char_array.6-1",
        "peekOfCode": "def isPalindrom(str):\n    # 조건1) 대소문자 구별x >> 모든 문자를 소문자로 바꿔주기\n    result = str.lower()\n    # 조건2) 영문과 숫자만 받고 특수문자는 패스하기>> 정규 표현식 사용\n    # [a-zA-Z0-9] : 모든 알파벳 문자 및 숫자\n    # [^0-9] : ^가 맨 앞에 사용 되는 경우 해당 문자 패턴이 아닌 것과 매칭\n    result = re.sub(\"[^a-z0-9]\",\"\", result)\n    print(result)\n    # 조건3) 팰린드롬 >> slicing\n    if result == result[::-1]:",
        "detail": "ch6_7_char_array.6-1",
        "documentation": {}
    },
    {
        "label": "mostCommonword",
        "kind": 2,
        "importPath": "ch6_7_char_array.6-2",
        "description": "ch6_7_char_array.6-2",
        "peekOfCode": "def mostCommonword(str,ban):\n    # 조건2) 대소문자 구분x, 특수문자 건너뜀 >> 소문자로 통일 , 특수문자 건너뜀\n    temp = str.lower()\n    temp = re.sub(\"[^a-z0-9]\", \" \", temp)\n    # 조건1) 띄어쓰기를 기준으로 입력값 구분 >> 공백 기준으로 list에 넣기\n    # https://wikidocs.net/14055\n    list_str = temp.split()\n    # print(list_str)\n    # 조건3) 금지문자 설정 >> 조건문으로 금지문자 list에서 날리기\n    #https://latte-is-horse.tistory.com/200",
        "detail": "ch6_7_char_array.6-2",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "ch6_7_char_array.6-3",
        "description": "ch6_7_char_array.6-3",
        "peekOfCode": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        anagrams = collections.defaultdict(list)\n        for word in strs:\n            anagrams[''.join(sorted(word))].append(word)\n        print(anagrams)\n        return anagrams.values()\n# sorted()는 문자열도 잘 정렬하며 결과를 리스트 형태로 리턴하는데, 이를 다시 키로 사용하기 위해 join()으로 합쳐 이 값을 키로 하는 딕셔너리로 구성한다.\n#\n# ''.join(list())는 리스트를 문자열로 바꿔준다.",
        "detail": "ch6_7_char_array.6-3",
        "documentation": {}
    },
    {
        "label": "longestPalindrom",
        "kind": 2,
        "importPath": "ch6_7_char_array.6-4",
        "description": "ch6_7_char_array.6-4",
        "peekOfCode": "def longestPalindrom(s):\n    # 조건1) 문자열 내에서 팰린드롬 구하기\n    # 기준점으로부터 좌우가 같은지 판단하여 같다면 좌우 한칸더 보기\n    # 홀수개의 경우.. 가능하지만 짝수개의 팰린드럼이라면 불가능\n    # 좌우가 같지 않다면, 문자열 임시저장하고 기준점 이동하기\n    # 더이상 좌우가 같은 지점을 못찾을경우, 임시저장값 출력\n    # left = 0\n    # evenpal =[]\n    # evenpal = [None] * len(s)\n    # oddpal = [None] * len(s)",
        "detail": "ch6_7_char_array.6-4",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "ch8_linkedList.linkedlist_prac",
        "description": "ch8_linkedList.linkedlist_prac",
        "peekOfCode": "class Node(object):\n    def __init__(self, value=None, pointer=None):\n        self.value = value\n        self.pointer = pointer\nclass Linked_List(object):\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    def isempty(self):\n        return not bool(self.head)",
        "detail": "ch8_linkedList.linkedlist_prac",
        "documentation": {}
    },
    {
        "label": "Linked_List",
        "kind": 6,
        "importPath": "ch8_linkedList.linkedlist_prac",
        "description": "ch8_linkedList.linkedlist_prac",
        "peekOfCode": "class Linked_List(object):\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    def isempty(self):\n        return not bool(self.head)\n    def add_first(self, item):\n        node = Node(item)\n        if not self.isempty():\n            node.pointer = self.head",
        "detail": "ch8_linkedList.linkedlist_prac",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "ch8_linkedList.linked_list",
        "description": "ch8_linkedList.linked_list",
        "peekOfCode": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n# 리스트 선언\nclass L_List:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    # 노드가 없을경우에 예외처리",
        "detail": "ch8_linkedList.linked_list",
        "documentation": {}
    },
    {
        "label": "L_List",
        "kind": 6,
        "importPath": "ch8_linkedList.linked_list",
        "description": "ch8_linkedList.linked_list",
        "peekOfCode": "class L_List:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    # 노드가 없을경우에 예외처리\n    def isempty(self):\n        return not bool(self.head)\n    # 현재 노드의 앞에 입력\n    def add_front(self, val):\n        node = Node(val)",
        "detail": "ch8_linkedList.linked_list",
        "documentation": {}
    },
    {
        "label": "is_vaild",
        "kind": 2,
        "importPath": "ch9_stack_queue.9_1",
        "description": "ch9_stack_queue.9_1",
        "peekOfCode": "def is_vaild(s):\n    pair = {\n        '}': '{',\n        ']': '[',\n        ')': '('\n    }\n    opener = \"{[(\"\n    stack =[]\n    for char in s:\n        if char in opener:",
        "detail": "ch9_stack_queue.9_1",
        "documentation": {}
    },
    {
        "label": "get_card",
        "kind": 2,
        "importPath": "ch9_stack_queue.9_queue",
        "description": "ch9_stack_queue.9_queue",
        "peekOfCode": "def get_card(num):\n    # 1. 제일 위의 카드를 버린다.\n    queue = deque([n for n in range(1, num + 1)])  # range범위내의 n을 리스트에 넣어줘\n    while len(queue) > 1:\n        queue.popleft()\n        queue.append(queue.popleft())\n    return queue.popleft()\n    # queue = Queue([1,2,3,4,...N])\n    # while len(queue) > 1:\n    #     queue.pop()",
        "detail": "ch9_stack_queue.9_queue",
        "documentation": {}
    },
    {
        "label": "CircularQueue",
        "kind": 6,
        "importPath": "ch9_stack_queue.circle_queue",
        "description": "ch9_stack_queue.circle_queue",
        "peekOfCode": "class CircularQueue:\n    def __init__(self):\n        self.front = 0\n        self.rear = 0\n        self.items = [None] * Q_size\n    def isEmpty(self):\n        return self.front == self.rear\n    def isFull(self):\n        return self.front == (self.rear + 1) % Q_size\n    def clear(self):",
        "detail": "ch9_stack_queue.circle_queue",
        "documentation": {}
    },
    {
        "label": "Q_size",
        "kind": 5,
        "importPath": "ch9_stack_queue.circle_queue",
        "description": "ch9_stack_queue.circle_queue",
        "peekOfCode": "Q_size = 6\nclass CircularQueue:\n    def __init__(self):\n        self.front = 0\n        self.rear = 0\n        self.items = [None] * Q_size\n    def isEmpty(self):\n        return self.front == self.rear\n    def isFull(self):\n        return self.front == (self.rear + 1) % Q_size",
        "detail": "ch9_stack_queue.circle_queue",
        "documentation": {}
    },
    {
        "label": "del_dup",
        "kind": 2,
        "importPath": "ch9_stack_queue.delDup_Letter",
        "description": "ch9_stack_queue.delDup_Letter",
        "peekOfCode": "def del_dup(s):\n    stack = []\n    flag = 0\n    # 1) 알파벳 갯수를 카운트 한다.\n    cnter = Counter(s)\n    for char in s:  ##   1342 cbac dcbc 3213 4323// c:4 b:2 a: 1 d: 1\n        cnter[char] -= 1\n        if cnter[char] == 0 and char not in stack:\n            #  단 한개뿐이라면 건너뛰기 불가능\n            stack.append(char)",
        "detail": "ch9_stack_queue.delDup_Letter",
        "documentation": {}
    },
    {
        "label": "test_node",
        "kind": 2,
        "importPath": "ch9_stack_queue.STACK_QUEUE",
        "description": "ch9_stack_queue.STACK_QUEUE",
        "peekOfCode": "def test_node():\n    assert Node(1, None).item == 1  # assert = 주장한다// node(myval,nextadd)\ndef test_stack():  # stack은 3가지 기능이 요구된다.\n    stack = Stack()  # push,pop,is_empty\n    stack.push(1)\n    stack.push(2)\n    stack.push(3)\n    stack.push(4)\n    stack.push(5)\n    assert stack.pop() == 5",
        "detail": "ch9_stack_queue.STACK_QUEUE",
        "documentation": {}
    },
    {
        "label": "test_stack",
        "kind": 2,
        "importPath": "ch9_stack_queue.STACK_QUEUE",
        "description": "ch9_stack_queue.STACK_QUEUE",
        "peekOfCode": "def test_stack():  # stack은 3가지 기능이 요구된다.\n    stack = Stack()  # push,pop,is_empty\n    stack.push(1)\n    stack.push(2)\n    stack.push(3)\n    stack.push(4)\n    stack.push(5)\n    assert stack.pop() == 5\n    assert stack.pop() == 4\n    assert stack.pop() == 3",
        "detail": "ch9_stack_queue.STACK_QUEUE",
        "documentation": {}
    },
    {
        "label": "test_queue",
        "kind": 2,
        "importPath": "ch9_stack_queue.STACK_QUEUE",
        "description": "ch9_stack_queue.STACK_QUEUE",
        "peekOfCode": "def test_queue():  # stack은 3가지 기능이 요구된다.\n    queue = Queue()  # push,pop,is_empty\n    queue.push(1)\n    queue.push(2)\n    queue.push(3)\n    queue.push(4)\n    queue.push(5)\n    assert queue.pop() == 1\n    assert queue.pop() == 2\n    assert queue.pop() == 3",
        "detail": "ch9_stack_queue.STACK_QUEUE",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "ch9_stack_queue.structures",
        "description": "ch9_stack_queue.structures",
        "peekOfCode": "class Node:\n    def __init__(self, item, next):\n        self.item = item\n        self.next = next\nclass Stack:\n    def __init__(self):\n        self.top = None\n    def push(self, value):\n        self.top = Node(value, self.top)\n    def pop(self):",
        "detail": "ch9_stack_queue.structures",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "ch9_stack_queue.structures",
        "description": "ch9_stack_queue.structures",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.top = None\n    def push(self, value):\n        self.top = Node(value, self.top)\n    def pop(self):\n        if self.top is None:\n            return None\n        topNode = self.top\n        self.top = self.top.next",
        "detail": "ch9_stack_queue.structures",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "ch9_stack_queue.structures",
        "description": "ch9_stack_queue.structures",
        "peekOfCode": "class Queue:\n    def __init__(self):\n        self.front = None\n    def push(self, value):\n        if not self.front:\n            self.front=Node(value,None)\n            return\n        node = self.front\n        while node and node.next:\n            node=node.next",
        "detail": "ch9_stack_queue.structures",
        "documentation": {}
    },
    {
        "label": "MyCircularQueue",
        "kind": 6,
        "importPath": "ch9_stack_queue.test",
        "description": "ch9_stack_queue.test",
        "peekOfCode": "class MyCircularQueue:\n    def __init__(self, k: int):\n        # 원형 큐의 최대 갯수\n        self.maxlength = k\n        # 값이 들어있는 큐의 갯수    >>> node index 로 쓰이고 있음.\n        self.items = [None] * k\n        # 값이 들어있는 가장 앞의 큐 >>> 포인터가 가르키고 있는 index\n        self.front = 0\n        # 값이 들어있는 가장 뒤의 큐 >>> 포인터가 가르키고 있는 index\n        self.rear = 0",
        "detail": "ch9_stack_queue.test",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "have_no_idea.12907",
        "description": "have_no_idea.12907",
        "peekOfCode": "def solution(n, money):\n    # dp로 접근\n    # money의 동전을 순회하면서 coin으로 n원을 만드는법을 갱신시킨다.\n    # dp[n] => 누적되며 더해지는 n원을 만드는 방법의 수\n    # n원까지 가는거지만 n원을 만드는법은 예를들어 5원을 만드는 방법은 기존 5원까지 구했던 방법의수 + 5-coin 원을 만드는 방법의 수\n    dp = [0] * (n+1)\n    dp[0] = 1\n    for m in money:\n        for i in range(m, n+1):\n            dp[i] = dp[i] + dp[i-m]",
        "detail": "have_no_idea.12907",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "have_no_idea.154538",
        "description": "have_no_idea.154538",
        "peekOfCode": "def solution(x, y, n):\n    queue = deque([(x, 0)])  # (현재 숫자, 연산 횟수)\n    visited = set()\n    while queue:\n        current, count = queue.popleft()\n        if current == y:\n            return count\n        if current in visited:\n            continue\n        visited.add(current)",
        "detail": "have_no_idea.154538",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "have_no_idea.17679",
        "description": "have_no_idea.17679",
        "peekOfCode": "def solution(m, n, board):\n    board = [list(row) for row in board]\n    while True:\n        removed = set()\n        for i in range(m - 1):\n            for j in range(n - 1):\n                if board[i][j] == board[i][j + 1] == board[i + 1][j] == board[i + 1][j + 1] != '.':\n                    removed |= {(i, j), (i, j + 1), (i + 1, j), (i + 1, j + 1)}\n        for i, j in removed:\n            board[i][j] = '.'",
        "detail": "have_no_idea.17679",
        "documentation": {}
    },
    {
        "label": "max_score",
        "kind": 2,
        "importPath": "have_no_idea.2579",
        "description": "have_no_idea.2579",
        "peekOfCode": "def max_score(stairs):\n    n = len(stairs)\n    if n == 1:  # 계단이 한 개일 때는 해당 계단의 점수가 최대 점수\n        return stairs[0]\n    elif n == 2:  # 계단이 두 개일 때는 두 계단의 점수를 합한 값이 최대 점수\n        return stairs[0] + stairs[1]\n    # dp 배열 초기화\n    dp = [0] * n\n    dp[0] = stairs[0]  # 첫 번째 계단의 점수\n    dp[1] = stairs[0] + stairs[1]  # 두 번째 계단까지의 최대 점수",
        "detail": "have_no_idea.2579",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "have_no_idea.2579",
        "description": "have_no_idea.2579",
        "peekOfCode": "input = sys.stdin.readline\n# 못푼 문제\n# DP 문제의 접근방식\n# f(0),f(1),f(2) 를 통해 f(3),…,f(n) 을 수식으로 풀어내는 식으로 한다.\ndef max_score(stairs):\n    n = len(stairs)\n    if n == 1:  # 계단이 한 개일 때는 해당 계단의 점수가 최대 점수\n        return stairs[0]\n    elif n == 2:  # 계단이 두 개일 때는 두 계단의 점수를 합한 값이 최대 점수\n        return stairs[0] + stairs[1]",
        "detail": "have_no_idea.2579",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "have_no_idea.92343",
        "description": "have_no_idea.92343",
        "peekOfCode": "def dfs(sheep, wolf, cur_node, next_nodes, info, graph):\n    if info[cur_node] == 0:\n        sheep += 1\n    else:\n        wolf += 1\n    answer = sheep\n    if sheep <= wolf:\n        return answer\n    for idx, next_node in enumerate(next_nodes):\n        next_candidates = next_nodes[:idx] + next_nodes[idx+1:]  # next_nodes의 복사로 next_candidates를 만들되, 현재 인덱스의 값을 제외한 나머지 값을 사용",
        "detail": "have_no_idea.92343",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 2,
        "importPath": "have_no_idea.92343",
        "description": "have_no_idea.92343",
        "peekOfCode": "def solution(info, edges):\n    graph = [[] for _ in range(len(info))]\n    print(graph)\n    # 그래프를 초기화, 선언\n    # 0번노드에서 시작한다.\n    # dfs 종료조건 => sheep = wolf\n    # 현재 존재하는 노드에서, 후보군에 해당하는 점들을 방문할것. 방문객 명단은 기존 후보군+ n+1차례에서 갈 후보군\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n    next_nodes = graph[0]",
        "detail": "have_no_idea.92343",
        "documentation": {}
    },
    {
        "label": "info",
        "kind": 5,
        "importPath": "have_no_idea.92343",
        "description": "have_no_idea.92343",
        "peekOfCode": "info = [0,1,0,1,1,0,1,0,0,1,0]\nedges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6],[3,7],[4,8],[6,9],[9,10]]\nprint(solution(info, edges))  # Output: 5",
        "detail": "have_no_idea.92343",
        "documentation": {}
    },
    {
        "label": "edges",
        "kind": 5,
        "importPath": "have_no_idea.92343",
        "description": "have_no_idea.92343",
        "peekOfCode": "edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6],[3,7],[4,8],[6,9],[9,10]]\nprint(solution(info, edges))  # Output: 5",
        "detail": "have_no_idea.92343",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "codingtest",
        "description": "codingtest",
        "peekOfCode": "p = '010-5108-1201'\np = re.compile()\nanswer = 0\nreturn answer\n# #######################################\n# # 실행시간 체크 모듈\n# import math\n# import time\n#\n# start = time.time()",
        "detail": "codingtest",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "codingtest",
        "description": "codingtest",
        "peekOfCode": "p = re.compile()\nanswer = 0\nreturn answer\n# #######################################\n# # 실행시간 체크 모듈\n# import math\n# import time\n#\n# start = time.time()\n# math.factorial(100000)",
        "detail": "codingtest",
        "documentation": {}
    },
    {
        "label": "answer",
        "kind": 5,
        "importPath": "codingtest",
        "description": "codingtest",
        "peekOfCode": "answer = 0\nreturn answer\n# #######################################\n# # 실행시간 체크 모듈\n# import math\n# import time\n#\n# start = time.time()\n# math.factorial(100000)\n# end = time.time()",
        "detail": "codingtest",
        "documentation": {}
    }
]