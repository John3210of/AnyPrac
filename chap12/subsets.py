# 고유한 요소의 정수 배열 숫자가 주어지면 가능한 모든 하위 집합(전력 집합)을 반환합니다.
# 솔루션 세트에는 중복 서브세트가 포함되어서는 안 됩니다. 임의의 순서로 솔루션을 반환합니다.

# 반복적으로 발생하는일 => 숫자의 조합을 result에 넣는 일
# 종료 조건 => len(result) == 2 ** len(nums) 일때
#            or 왼쪽으로부터 dfs를 해서 [3]이 나왔을때

nums = [1, 2, 3]

def subsets(nums):

    result = []

    # 재귀적으로 짠다 ==> 가장 중요한 idea는 1) 반복적으로 발생하는 일을 아는 것.
    #                                   2) 종료 조건을 아는것.
    #   dfs를 사용하는 패턴
    #   1. 초기 값을 넣어서 메인 함수 안의 dfs 함수를 호출한다.
    #   2. 호출한 값을 result에 반영시킨다.
    #   3. for 문을 열어서 상위노드임을 알수있고, 인접 노드를 탐색한다.
    #       >>인접노드 기준으로 다시 dfs함수를 호출한다.
    #   4. for문 진행중, 값을 얻을수 없을 경우(최종 depth까지 진행한 경우)
    #      >>재귀된 함수들(dfs)이 다음 탐색할 값이 있는 상위노드까지 닫히게 된다.
    #   5. 상위 노드에서 이전에 갔던 루트를 제외하고 다음 루트부터 탐색한다. (상위 노드의 for문이 끝나지 않았기 때문)
    #   6. 종료조건의 경우 재귀함수가 모두 닫히고 result를 return하면서 main 함수가 종료된다.
    #       >>종료조건 : 완전탐색되었거나, 조건이 만족되었을 때

    def dfs(idx_num,sub):

        result.append(sub)
        # = result list+ sub list
        for i in range(idx_num,len(nums)):
            dfs(i+1,sub+[nums[i]])  #dfs(1,[1]) >> dfs(2,[1,2]) >> dfs(3,[1,2,3]) >>dfs(1,[1])의 i=1

    dfs(0,[])

    return result


if __name__ == "__main__":
    print(subsets(nums))
